"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@gradio";
exports.ids = ["vendor-chunks/@gradio"];
exports.modules = {

/***/ "(rsc)/./node_modules/@gradio/client/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@gradio/client/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   FileData: () => (/* binding */ FileData),\n/* harmony export */   MISSING_CREDENTIALS_MSG: () => (/* binding */ MISSING_CREDENTIALS_MSG),\n/* harmony export */   client: () => (/* binding */ client),\n/* harmony export */   duplicate: () => (/* binding */ duplicate_space),\n/* harmony export */   handle_file: () => (/* binding */ handle_file),\n/* harmony export */   predict: () => (/* binding */ predict),\n/* harmony export */   prepare_files: () => (/* binding */ prepare_files),\n/* harmony export */   submit: () => (/* binding */ submit),\n/* harmony export */   upload: () => (/* binding */ upload),\n/* harmony export */   upload_files: () => (/* binding */ upload_files)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _currentLine;\nvar fn = new Intl.Collator(0, { numeric: 1 }).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nconst HOST_URL = `host`;\nconst SSE_URL = `queue/data`;\nconst SSE_DATA_URL = `queue/join`;\nconst UPLOAD_URL = `upload`;\nconst LOGIN_URL = `login`;\nconst CONFIG_URL = `config`;\nconst API_INFO_URL = `info`;\nconst RUNTIME_URL = `runtime`;\nconst SLEEPTIME_URL = `sleeptime`;\nconst HEARTBEAT_URL = `heartbeat`;\nconst COMPONENT_SERVER_URL = `component_server`;\nconst RESET_URL = `reset`;\nconst CANCEL_URL = `cancel`;\nconst APP_ID_URL = `app_id`;\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nasync function get_jwt(space, token, cookies) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...cookies ? { Cookie: cookies } : {}\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({ api_name, id }) => {\n    if (api_name)\n      apis[api_name] = id;\n  });\n  return apis;\n}\nasync function resolve_config(endpoint) {\n  const headers = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {};\n  headers[\"Content-Type\"] = \"application/json\";\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    if (window.gradio_config.current_page) {\n      endpoint = endpoint.substring(0, endpoint.lastIndexOf(\"/\"));\n    }\n    window.gradio_config.root = endpoint;\n    return { ...window.gradio_config };\n  } else if (endpoint) {\n    let config_url = join_urls(\n      endpoint,\n      this.deep_link ? CONFIG_URL + \"?deep_link=\" + this.deep_link : CONFIG_URL\n    );\n    const response = await this.fetch(config_url, {\n      headers,\n      credentials: \"include\"\n    });\n    return handleConfigResponse(response, endpoint, !!this.options.auth);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function handleConfigResponse(response, endpoint, authorized) {\n  var _a, _b;\n  if ((response == null ? void 0 : response.status) === 401 && !authorized) {\n    const error_data = await response.json();\n    const auth_message = (_a = error_data == null ? void 0 : error_data.detail) == null ? void 0 : _a.auth_message;\n    throw new Error(auth_message || MISSING_CREDENTIALS_MSG);\n  } else if ((response == null ? void 0 : response.status) === 401 && authorized) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  }\n  if ((response == null ? void 0 : response.status) === 200) {\n    let config = await response.json();\n    config.root = endpoint;\n    (_b = config.dependencies) == null ? void 0 : _b.forEach((dep, i) => {\n      if (dep.id === void 0) {\n        dep.id = i;\n      }\n    });\n    return config;\n  } else if ((response == null ? void 0 : response.status) === 401) {\n    throw new Error(UNAUTHORIZED_MSG);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function resolve_cookies() {\n  const { http_protocol, host } = await process_endpoint(\n    this.app_reference,\n    this.options.hf_token\n  );\n  try {\n    if (this.options.auth) {\n      const cookie_header = await get_cookie_header(\n        http_protocol,\n        host,\n        this.options.auth,\n        this.fetch,\n        this.options.hf_token\n      );\n      if (cookie_header)\n        this.set_cookies(cookie_header);\n    }\n  } catch (e) {\n    throw Error(e.message);\n  }\n}\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\n  const formData = new FormData();\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\n  let headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\n    headers,\n    method: \"POST\",\n    body: formData,\n    credentials: \"include\"\n  });\n  if (res.status === 200) {\n    return res.headers.get(\"set-cookie\");\n  } else if (res.status === 401) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  } else {\n    throw new Error(SPACE_METADATA_ERROR_MSG);\n  }\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const { protocol, host, pathname } = new URL(endpoint);\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host: host + (pathname !== \"/\" ? pathname : \"\")\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: new URL(endpoint).host\n  };\n}\nconst parse_and_set_cookies = (cookie_header) => {\n  let cookies = [];\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\n  parts.forEach((cookie) => {\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\n    if (cookie_name && cookie_value) {\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\n    }\n  });\n  return cookies;\n};\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}.*$/;\nasync function process_endpoint(app_reference, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(\n        `https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`,\n        { headers }\n      );\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(SPACE_METADATA_ERROR_MSG);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);\n    return {\n      space_id: host.split(\"/\")[0].replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nconst join_urls = (...urls) => {\n  try {\n    return urls.reduce((base_url, part) => {\n      base_url = base_url.replace(/\\/+$/, \"\");\n      part = part.replace(/^\\/+/, \"\");\n      return new URL(part, base_url + \"/\").toString();\n    });\n  } catch (e) {\n    throw new Error(INVALID_URL_MSG);\n  }\n};\nfunction transform_api_info(api_info, config, api_map) {\n  const transformed_info = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  Object.keys(api_info).forEach((category) => {\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\n      transformed_info[category] = {};\n      Object.entries(api_info[category]).forEach(\n        ([endpoint, { parameters, returns }]) => {\n          var _a, _b, _c, _d;\n          const dependencyIndex = ((_a = config.dependencies.find(\n            (dep) => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\")\n          )) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\n          const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _b.types : { generator: false, cancel: false };\n          if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\n            const components = config.dependencies.find((dep) => dep.id == dependencyIndex).inputs.map(\n              (input) => {\n                var _a2;\n                return (_a2 = config.components.find((c) => c.id === input)) == null ? void 0 : _a2.type;\n              }\n            );\n            try {\n              components.forEach((comp, idx) => {\n                if (comp === \"state\") {\n                  const new_param = {\n                    component: \"state\",\n                    example: null,\n                    parameter_default: null,\n                    parameter_has_default: true,\n                    parameter_name: null,\n                    hidden: true\n                  };\n                  parameters.splice(idx, 0, new_param);\n                }\n              });\n            } catch (e) {\n              console.error(e);\n            }\n          }\n          const transform_type = (data, component, serializer, signature_type) => ({\n            ...data,\n            description: get_description(data == null ? void 0 : data.type, serializer),\n            type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\n          });\n          transformed_info[category][endpoint] = {\n            parameters: parameters.map(\n              (p) => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")\n            ),\n            returns: returns.map(\n              (r) => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")\n            ),\n            type: dependencyTypes\n          };\n        }\n      );\n    }\n  });\n  return transformed_info;\n}\nfunction get_type(type, component, serializer, signature_type) {\n  if (component === \"Api\")\n    return type.type;\n  switch (type == null ? void 0 : type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type == null ? void 0 : type.description;\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return { type: \"data\" };\n    case \"send_hash\":\n      return { type: \"hash\" };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          session_not_found: data.session_not_found,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"broken_connection\":\n      return {\n        type: \"broken_connection\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return { type: \"log\", data };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_streaming\":\n      return {\n        type: \"streaming\",\n        status: {\n          queue,\n          message: data.output.error,\n          stage: \"streaming\",\n          time_limit: data.time_limit,\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.eta\n        },\n        data: data.output\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            title: data.output.title,\n            message: data.output.error,\n            visible: data.output.visible,\n            duration: data.output.duration,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        },\n        original_msg: \"process_starts\"\n      };\n  }\n  return { type: \"none\", status: { stage: \"error\", queue } };\n}\nconst map_data_to_params = (data = [], endpoint_info) => {\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\n  if (Array.isArray(data)) {\n    if (endpoint_info && parameters.length > 0 && data.length > parameters.length) {\n      console.warn(\"Too many arguments provided for the endpoint.\");\n    }\n    return data;\n  }\n  const resolved_data = [];\n  const provided_keys = Object.keys(data);\n  parameters.forEach((param, index) => {\n    if (data.hasOwnProperty(param.parameter_name)) {\n      resolved_data[index] = data[param.parameter_name];\n    } else if (param.parameter_has_default) {\n      resolved_data[index] = param.parameter_default;\n    } else {\n      throw new Error(\n        `No value provided for required parameter: ${param.parameter_name}`\n      );\n    }\n  });\n  provided_keys.forEach((key) => {\n    if (!parameters.some((param) => param.parameter_name === key)) {\n      throw new Error(\n        `Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`\n      );\n    }\n  });\n  resolved_data.forEach((value, idx) => {\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\n      throw new Error(\n        `No value provided for required parameter: ${parameters[idx].parameter_name}`\n      );\n    }\n  });\n  return resolved_data;\n};\nasync function view_api() {\n  if (this.api_info)\n    return this.api_info;\n  const { hf_token } = this.options;\n  const { config } = this;\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  if (!config) {\n    return;\n  }\n  try {\n    let response;\n    let api_info;\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\n      api_info = window.gradio_api_info;\n    } else {\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\n        response = await this.fetch(SPACE_FETCHER_URL, {\n          method: \"POST\",\n          body: JSON.stringify({\n            serialize: false,\n            config: JSON.stringify(config)\n          }),\n          headers,\n          credentials: \"include\"\n        });\n      } else {\n        const url = join_urls(config.root, this.api_prefix, API_INFO_URL);\n        response = await this.fetch(url, {\n          headers,\n          credentials: \"include\"\n        });\n      }\n      if (!response.ok) {\n        throw new Error(BROKEN_CONNECTION_MSG);\n      }\n      api_info = await response.json();\n    }\n    if (\"api\" in api_info) {\n      api_info = api_info.api;\n    }\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n    }\n    return transform_api_info(api_info, config, this.api_map);\n  } catch (e) {\n    throw new Error(\"Could not get API info. \" + e.message);\n  }\n}\nasync function upload_files(root_url, files, upload_id) {\n  var _a;\n  const headers = {};\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  const chunkSize = 1e3;\n  const uploadResponses = [];\n  let response;\n  for (let i = 0; i < files.length; i += chunkSize) {\n    const chunk = files.slice(i, i + chunkSize);\n    const formData = new FormData();\n    chunk.forEach((file) => {\n      formData.append(\"files\", file);\n    });\n    try {\n      const upload_url = upload_id ? `${root_url}${this.api_prefix}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}${this.api_prefix}/${UPLOAD_URL}`;\n      response = await this.fetch(upload_url, {\n        method: \"POST\",\n        body: formData,\n        headers,\n        credentials: \"include\"\n      });\n    } catch (e) {\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\n    }\n    if (!response.ok) {\n      const error_text = await response.text();\n      return { error: `HTTP ${response.status}: ${error_text}` };\n    }\n    const output = await response.json();\n    if (output) {\n      uploadResponses.push(...output);\n    }\n  }\n  return { files: uploadResponses };\n}\nasync function upload(file_data, root_url, upload_id, max_file_size) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(\n    (file_data2) => file_data2.blob\n  );\n  const oversized_files = files.filter(\n    (f) => f.size > (max_file_size ?? Infinity)\n  );\n  if (oversized_files.length) {\n    throw new Error(\n      `File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map((f) => f.name).join(\", \")}`\n    );\n  }\n  return await Promise.all(\n    await this.upload_files(root_url, files, upload_id).then(\n      async (response) => {\n        if (response.error) {\n          throw new Error(response.error);\n        } else {\n          if (response.files) {\n            return response.files.map((f, i) => {\n              const file = new FileData({\n                ...file_data[i],\n                path: f,\n                url: `${root_url}${this.api_prefix}/file=${f}`\n              });\n              return file;\n            });\n          }\n          return [];\n        }\n      }\n    )\n  );\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(\n    (f) => new FileData({\n      path: f.name,\n      orig_name: f.name,\n      blob: f,\n      size: f.size,\n      mime_type: f.type,\n      is_stream\n    })\n  );\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text,\n    b64\n  }) {\n    __publicField(this, \"path\");\n    __publicField(this, \"url\");\n    __publicField(this, \"orig_name\");\n    __publicField(this, \"size\");\n    __publicField(this, \"blob\");\n    __publicField(this, \"is_stream\");\n    __publicField(this, \"mime_type\");\n    __publicField(this, \"alt_text\");\n    __publicField(this, \"b64\");\n    __publicField(this, \"meta\", { _type: \"gradio.FileData\" });\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n    this.b64 = b64;\n  }\n}\nclass Command {\n  constructor(command, meta) {\n    __publicField(this, \"type\");\n    __publicField(this, \"command\");\n    __publicField(this, \"meta\");\n    __publicField(this, \"fileData\");\n    this.type = \"command\";\n    this.command = command;\n    this.meta = meta;\n  }\n}\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    const key2 = stack.shift();\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\n      object = object[key2];\n    } else {\n      throw new Error(\"Invalid key type\");\n    }\n  }\n  const key = stack.shift();\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    object[key] = newValue;\n  } else {\n    throw new Error(\"Invalid key type\");\n  }\n}\nasync function walk_and_store_blobs(data, type = void 0, path = [], root = false, endpoint_info = void 0) {\n  if (Array.isArray(data)) {\n    let blob_refs = [];\n    await Promise.all(\n      data.map(async (_, index) => {\n        var _a;\n        let new_path = path.slice();\n        new_path.push(String(index));\n        const array_refs = await walk_and_store_blobs(\n          data[index],\n          root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type,\n          new_path,\n          false,\n          endpoint_info\n        );\n        blob_refs = blob_refs.concat(array_refs);\n      })\n    );\n    return blob_refs;\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\n    return [\n      {\n        path,\n        blob: new Blob([data]),\n        type\n      }\n    ];\n  } else if (typeof data === \"object\" && data !== null) {\n    let blob_refs = [];\n    for (const key of Object.keys(data)) {\n      const new_path = [...path, key];\n      const value = data[key];\n      blob_refs = blob_refs.concat(\n        await walk_and_store_blobs(\n          value,\n          void 0,\n          new_path,\n          false,\n          endpoint_info\n        )\n      );\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b;\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find((dep) => dep.id == id)) == null ? void 0 : _b.queue;\n  if (fn_queue != null) {\n    return !fn_queue;\n  }\n  return !config.enable_queue;\n}\nfunction post_message(message, origin) {\n  return new Promise((res, _rej) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = ({ data }) => {\n      channel.port1.close();\n      res(data);\n    };\n    window.parent.postMessage(message, origin, [channel.port2]);\n  });\n}\nfunction handle_file(file_or_url) {\n  if (typeof file_or_url === \"string\") {\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\n      return {\n        path: file_or_url,\n        url: file_or_url,\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\n        meta: { _type: \"gradio.FileData\" }\n      };\n    }\n    if (is_node) {\n      return new Command(\"upload_file\", {\n        path: file_or_url,\n        name: file_or_url,\n        orig_path: file_or_url\n      });\n    }\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Buffer) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Blob) {\n    return file_or_url;\n  }\n  throw new Error(\n    \"Invalid input: must be a URL, File, Blob, or Buffer object.\"\n  );\n}\nfunction handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {\n  if (type === \"input\" && !with_null_state) {\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\n  }\n  if (type === \"output\" && with_null_state) {\n    return resolved_payload;\n  }\n  let updated_payload = [];\n  let payload_index = 0;\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\n  for (let i = 0; i < deps.length; i++) {\n    const input_id = deps[i];\n    const component = components.find((c) => c.id === input_id);\n    if ((component == null ? void 0 : component.type) === \"state\") {\n      if (with_null_state) {\n        if (resolved_payload.length === deps.length) {\n          const value = resolved_payload[payload_index];\n          updated_payload.push(value);\n          payload_index++;\n        } else {\n          updated_payload.push(null);\n        }\n      } else {\n        payload_index++;\n        continue;\n      }\n      continue;\n    } else {\n      const value = resolved_payload[payload_index];\n      updated_payload.push(value);\n      payload_index++;\n    }\n  }\n  return updated_payload;\n}\nasync function handle_blob(endpoint, data, api_info) {\n  const self = this;\n  await process_local_file_commands(self, data);\n  const blobRefs = await walk_and_store_blobs(\n    data,\n    void 0,\n    [],\n    true,\n    api_info\n  );\n  const results = await Promise.all(\n    blobRefs.map(async ({ path, blob, type }) => {\n      if (!blob)\n        return { path, type };\n      const response = await self.upload_files(endpoint, [blob]);\n      const file_url = response.files && response.files[0];\n      return {\n        path,\n        file_url,\n        type,\n        name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\n      };\n    })\n  );\n  results.forEach(({ path, file_url, type, name }) => {\n    if (type === \"Gallery\") {\n      update_object(data, file_url, path);\n    } else if (file_url) {\n      const file = new FileData({ path: file_url, orig_name: name });\n      update_object(data, file, path);\n    }\n  });\n  return data;\n}\nasync function process_local_file_commands(client2, data) {\n  var _a, _b;\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  await recursively_process_commands(client2, data);\n}\nasync function recursively_process_commands(client2, data, path = []) {\n  for (const key in data) {\n    if (data[key] instanceof Command) {\n      await process_single_command(client2, data, key);\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\n      await recursively_process_commands(client2, data[key], [...path, key]);\n    }\n  }\n}\nasync function process_single_command(client2, data, key) {\n  var _a, _b;\n  let cmd_item = data[key];\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  try {\n    let fileBuffer;\n    let fullPath;\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n      const fs = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! fs/promises */ \"fs/promises\", 19));\n      const path = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! path */ \"path\", 19));\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\n      fileBuffer = await fs.readFile(fullPath);\n    } else {\n      throw new Error(NODEJS_FS_ERROR_MSG);\n    }\n    const file = new Blob([fileBuffer], { type: \"application/octet-stream\" });\n    const response = await client2.upload_files(root, [file]);\n    const file_url = response.files && response.files[0];\n    if (file_url) {\n      const fileData = new FileData({\n        path: file_url,\n        orig_name: cmd_item.meta.name || \"\"\n      });\n      data[key] = fileData;\n    }\n  } catch (error) {\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\n  }\n}\nasync function post_data(url, body, additional_headers) {\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (this.options.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  try {\n    var response = await this.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: { ...headers, ...additional_headers },\n      credentials: \"include\"\n    });\n  } catch (e) {\n    return [{ error: BROKEN_CONNECTION_MSG }, 500];\n  }\n  let output;\n  let status;\n  try {\n    output = await response.json();\n    status = response.status;\n  } catch (e) {\n    output = { error: `Could not parse server response: ${e}` };\n    status = 500;\n  }\n  return [output, status];\n}\nasync function predict(endpoint, data = {}) {\n  let data_returned = false;\n  let status_complete = false;\n  if (!this.config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  if (typeof endpoint === \"number\") {\n    this.config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    this.config.dependencies.find(\n      (dep) => dep.id == this.api_map[trimmed_endpoint]\n    );\n  }\n  return new Promise(async (resolve, reject) => {\n    const app = this.submit(endpoint, data, null, null, true);\n    let result;\n    for await (const message of app) {\n      if (message.type === \"data\") {\n        if (status_complete) {\n          resolve(result);\n        }\n        data_returned = true;\n        result = message;\n      }\n      if (message.type === \"status\") {\n        if (message.stage === \"error\")\n          reject(message);\n        if (message.stage === \"complete\") {\n          status_complete = true;\n          if (data_returned) {\n            resolve(result);\n          }\n        }\n      }\n    }\n  });\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: SPACE_STATUS_ERROR_MSG,\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200)\n    return;\n  const {\n    runtime: { stage },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"Space is running.\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"APP_STARTING\":\n      status_callback({\n        status: \"starting\",\n        load_status: \"pending\",\n        message: \"Space is starting...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nconst check_and_wake_space = async (space_id, status_callback) => {\n  let retries = 0;\n  const max_retries = 12;\n  const check_interval = 5e3;\n  return new Promise((resolve) => {\n    check_space_status(\n      space_id,\n      RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n      (status) => {\n        status_callback(status);\n        if (status.status === \"running\") {\n          resolve();\n        } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\n          resolve();\n        } else if (status.status === \"sleeping\" || status.status === \"building\") {\n          if (retries < max_retries) {\n            retries++;\n            setTimeout(() => {\n              check_and_wake_space(space_id, status_callback).then(resolve);\n            }, check_interval);\n          } else {\n            resolve();\n          }\n        }\n      }\n    );\n  });\n};\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/discussions`,\n      {\n        method: \"HEAD\"\n      }\n    );\n    const error = r.headers.get(\"x-error-message\");\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error))\n      return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`,\n      { headers }\n    );\n    if (res.status !== 200)\n      throw new Error(\"Space hardware could not be obtained.\");\n    const { hardware } = await res.json();\n    return hardware.current;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const body = {\n    seconds: timeout\n  };\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\", ...headers },\n        body: JSON.stringify(body)\n      }\n    );\n    if (res.status !== 200) {\n      throw new Error(\n        \"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\"\n      );\n    }\n    const response = await res.json();\n    return response;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\n  \"cpu-basic\",\n  \"cpu-upgrade\",\n  \"cpu-xl\",\n  \"t4-small\",\n  \"t4-medium\",\n  \"a10g-small\",\n  \"a10g-large\",\n  \"a10g-largex2\",\n  \"a10g-largex4\",\n  \"a100-large\",\n  \"zero-a10g\",\n  \"h100\",\n  \"h100x8\"\n];\nasync function duplicate(app_reference, options) {\n  const { hf_token, private: _private, hardware, timeout, auth } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(\n      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `\"${v}\"`).join(\",\")}.`\n    );\n  }\n  const { http_protocol, host } = await process_endpoint(\n    app_reference,\n    hf_token\n  );\n  let cookies = null;\n  if (auth) {\n    const cookie_header = await get_cookie_header(\n      http_protocol,\n      host,\n      auth,\n      fetch\n    );\n    if (cookie_header)\n      cookies = parse_and_set_cookies(cookie_header);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`,\n    \"Content-Type\": \"application/json\",\n    ...cookies ? { Cookie: cookies.join(\"; \") } : {}\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  let original_hardware;\n  try {\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n  } catch (e) {\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\n  }\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n  body.hardware = requested_hardware;\n  try {\n    const response = await fetch(\n      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,\n      {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n      }\n    );\n    if (response.status === 409) {\n      try {\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\n        return client2;\n      } catch (error) {\n        console.error(\"Failed to connect Client instance:\", error);\n        throw error;\n      }\n    } else if (response.status !== 200) {\n      throw new Error(response.statusText);\n    }\n    const duplicated_space = await response.json();\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return await Client.connect(\n      get_space_reference(duplicated_space.url),\n      options\n    );\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction get_space_reference(url) {\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\n  const match = url.match(regex);\n  if (match) {\n    return match[1];\n  }\n}\nclass TextLineStream extends TransformStream {\n  /** Constructs a new instance. */\n  constructor(options = { allowCR: false }) {\n    super({\n      transform: (chars, controller) => {\n        chars = __privateGet(this, _currentLine) + chars;\n        while (true) {\n          const lfIndex = chars.indexOf(\"\\n\");\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\n            controller.enqueue(chars.slice(0, crIndex));\n            chars = chars.slice(crIndex + 1);\n            continue;\n          }\n          if (lfIndex === -1)\n            break;\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\n          controller.enqueue(chars.slice(0, endIndex));\n          chars = chars.slice(lfIndex + 1);\n        }\n        __privateSet(this, _currentLine, chars);\n      },\n      flush: (controller) => {\n        if (__privateGet(this, _currentLine) === \"\")\n          return;\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\n        controller.enqueue(currentLine);\n      }\n    });\n    __privateAdd(this, _currentLine, \"\");\n  }\n}\n_currentLine = new WeakMap();\nfunction stream$1(input) {\n  let decoder = new TextDecoderStream();\n  let split2 = new TextLineStream({ allowCR: true });\n  return input.pipeThrough(decoder).pipeThrough(split2);\n}\nfunction split(input) {\n  let rgx = /[:]\\s*/;\n  let match = rgx.exec(input);\n  let idx = match && match.index;\n  if (idx) {\n    return [\n      input.substring(0, idx),\n      input.substring(idx + match[0].length)\n    ];\n  }\n}\nfunction fallback(headers, key, value) {\n  let tmp = headers.get(key);\n  if (!tmp)\n    headers.set(key, value);\n}\nasync function* events(res, signal) {\n  if (!res.body)\n    return;\n  let iter = stream$1(res.body);\n  let line, reader = iter.getReader();\n  let event;\n  for (; ; ) {\n    if (signal && signal.aborted) {\n      return reader.cancel();\n    }\n    line = await reader.read();\n    if (line.done)\n      return;\n    if (!line.value) {\n      if (event)\n        yield event;\n      event = void 0;\n      continue;\n    }\n    let [field, value] = split(line.value) || [];\n    if (!field)\n      continue;\n    if (field === \"data\") {\n      event || (event = {});\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\n    } else if (field === \"event\") {\n      event || (event = {});\n      event[field] = value;\n    } else if (field === \"id\") {\n      event || (event = {});\n      event[field] = +value || value;\n    } else if (field === \"retry\") {\n      event || (event = {});\n      event[field] = +value || void 0;\n    }\n  }\n}\nasync function stream(input, init) {\n  let req = new Request(input, init);\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\n  fallback(req.headers, \"Content-Type\", \"application/json\");\n  let r = await fetch(req);\n  if (!r.ok)\n    throw r;\n  return events(r, req.signal);\n}\nasync function open_stream() {\n  let {\n    event_callbacks,\n    unclosed_events,\n    pending_stream_messages,\n    stream_status,\n    config,\n    jwt\n  } = this;\n  const that = this;\n  if (!config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  stream_status.open = true;\n  let stream2 = null;\n  let params = new URLSearchParams({\n    session_hash: this.session_hash\n  }).toString();\n  let url = new URL(`${config.root}${this.api_prefix}/${SSE_URL}?${params}`);\n  if (jwt) {\n    url.searchParams.set(\"__sign\", jwt);\n  }\n  stream2 = this.stream(url);\n  if (!stream2) {\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\n    return;\n  }\n  stream2.onmessage = async function(event) {\n    let _data = JSON.parse(event.data);\n    if (_data.msg === \"close_stream\") {\n      close_stream(stream_status, that.abort_controller);\n      return;\n    }\n    const event_id = _data.event_id;\n    if (!event_id) {\n      await Promise.all(\n        Object.keys(event_callbacks).map(\n          (event_id2) => event_callbacks[event_id2](_data)\n        )\n      );\n    } else if (event_callbacks[event_id] && config) {\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(\n        config.protocol\n      )) {\n        unclosed_events.delete(event_id);\n      }\n      let fn2 = event_callbacks[event_id];\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        setTimeout(fn2, 0, _data);\n      } else {\n        fn2(_data);\n      }\n    } else {\n      if (!pending_stream_messages[event_id]) {\n        pending_stream_messages[event_id] = [];\n      }\n      pending_stream_messages[event_id].push(_data);\n    }\n  };\n  stream2.onerror = async function(e) {\n    console.error(e);\n    await Promise.all(\n      Object.keys(event_callbacks).map(\n        (event_id) => event_callbacks[event_id]({\n          msg: \"broken_connection\",\n          message: BROKEN_CONNECTION_MSG\n        })\n      )\n    );\n  };\n}\nfunction close_stream(stream_status, abort_controller) {\n  if (stream_status) {\n    stream_status.open = false;\n    abort_controller == null ? void 0 : abort_controller.abort();\n  }\n}\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\n  let is_first_generation = !pending_diff_streams[event_id];\n  if (is_first_generation) {\n    pending_diff_streams[event_id] = [];\n    data.data.forEach((value, i) => {\n      pending_diff_streams[event_id][i] = value;\n    });\n  } else {\n    data.data.forEach((value, i) => {\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\n      pending_diff_streams[event_id][i] = new_data;\n      data.data[i] = new_data;\n    });\n  }\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(([action, path, value]) => {\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction readable_stream(input, init = {}) {\n  const instance = {\n    close: () => {\n      console.warn(\"Method not implemented.\");\n    },\n    onerror: null,\n    onmessage: null,\n    onopen: null,\n    readyState: 0,\n    url: input.toString(),\n    withCredentials: false,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n    addEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    dispatchEvent: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    removeEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    }\n  };\n  stream(input, init).then(async (res) => {\n    instance.readyState = instance.OPEN;\n    try {\n      for await (const chunk of res) {\n        instance.onmessage && instance.onmessage(chunk);\n      }\n      instance.readyState = instance.CLOSED;\n    } catch (e) {\n      instance.onerror && instance.onerror(e);\n      instance.readyState = instance.CLOSED;\n    }\n  }).catch((e) => {\n    console.error(e);\n    instance.onerror && instance.onerror(e);\n    instance.readyState = instance.CLOSED;\n  });\n  return instance;\n}\nfunction submit(endpoint, data = {}, event_data, trigger_id, all_events) {\n  var _a;\n  try {\n    let fire_event = function(event) {\n      if (all_events || events_to_publish[event.type]) {\n        push_event(event);\n      }\n    }, close = function() {\n      done = true;\n      while (resolvers.length > 0)\n        resolvers.shift()({\n          value: void 0,\n          done: true\n        });\n    }, push = function(data2) {\n      if (done)\n        return;\n      if (resolvers.length > 0) {\n        resolvers.shift()(data2);\n      } else {\n        values.push(data2);\n      }\n    }, push_error = function(error) {\n      push(thenable_reject(error));\n      close();\n    }, push_event = function(event) {\n      push({ value: event, done: false });\n    }, next = function() {\n      if (values.length > 0)\n        return Promise.resolve(values.shift());\n      if (done)\n        return Promise.resolve({ value: void 0, done: true });\n      return new Promise((resolve) => resolvers.push(resolve));\n    };\n    const { hf_token } = this.options;\n    const {\n      fetch: fetch2,\n      app_reference,\n      config,\n      session_hash,\n      api_info,\n      api_map,\n      stream_status,\n      pending_stream_messages,\n      pending_diff_streams,\n      event_callbacks,\n      unclosed_events,\n      post_data: post_data2,\n      options,\n      api_prefix\n    } = this;\n    const that = this;\n    if (!api_info)\n      throw new Error(\"No API found\");\n    if (!config)\n      throw new Error(\"Could not resolve app config\");\n    let { fn_index, endpoint_info, dependency } = get_endpoint_info(\n      api_info,\n      endpoint,\n      api_map,\n      config\n    );\n    let resolved_data = map_data_to_params(data, endpoint_info);\n    let websocket;\n    let stream2;\n    let protocol = config.protocol ?? \"ws\";\n    let event_id_final = \"\";\n    let event_id_cb = () => event_id_final;\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n    let payload;\n    let event_id = null;\n    let complete = false;\n    let last_status = {};\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce(\n      (acc, event) => {\n        acc[event] = true;\n        return acc;\n      },\n      {}\n    )) || {};\n    async function cancel() {\n      const _status = {\n        stage: \"complete\",\n        queue: false,\n        time: /* @__PURE__ */ new Date()\n      };\n      complete = _status;\n      fire_event({\n        ..._status,\n        type: \"status\",\n        endpoint: _endpoint,\n        fn_index\n      });\n      let reset_request = {};\n      let cancel_request = {};\n      if (protocol === \"ws\") {\n        if (websocket && websocket.readyState === 0) {\n          websocket.addEventListener(\"open\", () => {\n            websocket.close();\n          });\n        } else {\n          websocket.close();\n        }\n        reset_request = { fn_index, session_hash };\n      } else {\n        reset_request = { event_id };\n        cancel_request = { event_id, session_hash, fn_index };\n      }\n      try {\n        if (!config) {\n          throw new Error(\"Could not resolve app config\");\n        }\n        if (\"event_id\" in cancel_request) {\n          await fetch2(`${config.root}${api_prefix}/${CANCEL_URL}`, {\n            headers: { \"Content-Type\": \"application/json\" },\n            method: \"POST\",\n            body: JSON.stringify(cancel_request)\n          });\n        }\n        await fetch2(`${config.root}${api_prefix}/${RESET_URL}`, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\",\n          body: JSON.stringify(reset_request)\n        });\n      } catch (e) {\n        console.warn(\n          \"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\"\n        );\n      }\n    }\n    const resolve_heartbeat = async (config2) => {\n      await this._resolve_heartbeat(config2);\n    };\n    async function handle_render_config(render_config) {\n      if (!config)\n        return;\n      let render_id = render_config.render_id;\n      config.components = [\n        ...config.components.filter((c) => c.props.rendered_in !== render_id),\n        ...render_config.components\n      ];\n      config.dependencies = [\n        ...config.dependencies.filter((d) => d.rendered_in !== render_id),\n        ...render_config.dependencies\n      ];\n      const any_state = config.components.some((c) => c.type === \"state\");\n      const any_unload = config.dependencies.some(\n        (d) => d.targets.some((t) => t[1] === \"unload\")\n      );\n      config.connect_heartbeat = any_state || any_unload;\n      await resolve_heartbeat(config);\n      fire_event({\n        type: \"render\",\n        data: render_config,\n        endpoint: _endpoint,\n        fn_index\n      });\n    }\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(\n      async (_payload) => {\n        var _a2;\n        let input_data = handle_payload(\n          _payload,\n          dependency,\n          config.components,\n          \"input\",\n          true\n        );\n        payload = {\n          data: input_data || [],\n          event_data,\n          fn_index,\n          trigger_id\n        };\n        if (skip_queue(fn_index, config)) {\n          fire_event({\n            type: \"status\",\n            endpoint: _endpoint,\n            stage: \"pending\",\n            queue: false,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          post_data2(\n            `${config.root}${api_prefix}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`,\n            {\n              ...payload,\n              session_hash\n            }\n          ).then(([output, status_code]) => {\n            const data2 = output.data;\n            if (status_code == 200) {\n              fire_event({\n                type: \"data\",\n                endpoint: _endpoint,\n                fn_index,\n                data: handle_payload(\n                  data2,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                time: /* @__PURE__ */ new Date(),\n                event_data,\n                trigger_id\n              });\n              if (output.render_config) {\n                handle_render_config(output.render_config);\n              }\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                stage: \"complete\",\n                eta: output.average_duration,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                endpoint: _endpoint,\n                fn_index,\n                message: output.error,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          }).catch((e) => {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: e.message,\n              endpoint: _endpoint,\n              fn_index,\n              queue: false,\n              time: /* @__PURE__ */ new Date()\n            });\n          });\n        } else if (protocol == \"ws\") {\n          const { ws_protocol, host } = await process_endpoint(\n            app_reference,\n            hf_token\n          );\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let url = new URL(\n            `${ws_protocol}://${resolve_root(\n              host,\n              config.root,\n              true\n            )}/queue/join${url_params ? \"?\" + url_params : \"\"}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          websocket = new WebSocket(url);\n          websocket.onclose = (evt) => {\n            if (!evt.wasClean) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                broken: true,\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          };\n          websocket.onmessage = function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                websocket.close();\n              }\n            } else if (type === \"hash\") {\n              websocket.send(JSON.stringify({ fn_index, session_hash }));\n              return;\n            } else if (type === \"data\") {\n              websocket.send(JSON.stringify({ ...payload, session_hash }));\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                title: data2.title,\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                websocket.close();\n              }\n            }\n          };\n          if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n            addEventListener(\n              \"open\",\n              () => websocket.send(JSON.stringify({ hash: session_hash }))\n            );\n          }\n        } else if (protocol == \"sse\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          var params = new URLSearchParams({\n            fn_index: fn_index.toString(),\n            session_hash\n          }).toString();\n          let url = new URL(\n            `${config.root}${api_prefix}/${SSE_URL}?${url_params ? url_params + \"&\" : \"\"}${params}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          stream2 = this.stream(url);\n          if (!stream2) {\n            return Promise.reject(\n              new Error(\"Cannot connect to SSE endpoint: \" + url.toString())\n            );\n          }\n          stream2.onmessage = async function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"data\") {\n              let [_, status2] = await post_data2(\n                `${config.root}${api_prefix}/queue/data`,\n                {\n                  ...payload,\n                  session_hash,\n                  event_id\n                }\n              );\n              if (status2 !== 200) {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: BROKEN_CONNECTION_MSG,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */ new Date()\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                title: data2.title,\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\" || type === \"streaming\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            }\n          };\n        } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let hostname = \"\";\n          if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n            hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\n          }\n          let hfhubdev = \"dev.spaces.huggingface.tech\";\n          const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\n          const is_zerogpu_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window && window.supports_zerogpu_headers;\n          const zerogpu_auth_promise = is_zerogpu_iframe ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\n          const post_data_promise = zerogpu_auth_promise.then((headers) => {\n            return post_data2(\n              `${config.root}${api_prefix}/${SSE_DATA_URL}?${url_params}`,\n              {\n                ...payload,\n                session_hash\n              },\n              headers\n            );\n          });\n          post_data_promise.then(async ([response, status]) => {\n            if (status === 503) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: QUEUE_FULL_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else if (status !== 200) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                broken: true,\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              event_id = response.event_id;\n              event_id_final = event_id;\n              let callback = async function(_data) {\n                try {\n                  const { type, status: status2, data: data2, original_msg } = handle_message(\n                    _data,\n                    last_status[fn_index]\n                  );\n                  if (type == \"heartbeat\") {\n                    return;\n                  }\n                  if (type === \"update\" && status2 && !complete) {\n                    fire_event({\n                      type: \"status\",\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date(),\n                      original_msg,\n                      ...status2\n                    });\n                  } else if (type === \"complete\") {\n                    complete = status2;\n                  } else if (type == \"unexpected_error\" || type == \"broken_connection\") {\n                    console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                    const broken = type === \"broken_connection\";\n                    fire_event({\n                      type: \"status\",\n                      stage: \"error\",\n                      message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                      queue: true,\n                      endpoint: _endpoint,\n                      broken,\n                      session_not_found: status2 == null ? void 0 : status2.session_not_found,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date()\n                    });\n                  } else if (type === \"log\") {\n                    fire_event({\n                      type: \"log\",\n                      title: data2.title,\n                      log: data2.log,\n                      level: data2.level,\n                      endpoint: _endpoint,\n                      duration: data2.duration,\n                      visible: data2.visible,\n                      fn_index\n                    });\n                    return;\n                  } else if (type === \"generating\" || type === \"streaming\") {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */ new Date(),\n                      ...status2,\n                      stage: status2 == null ? void 0 : status2.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2 && dependency.connection !== \"stream\" && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                      apply_diff_stream(pending_diff_streams, event_id, data2);\n                    }\n                  }\n                  if (data2) {\n                    fire_event({\n                      type: \"data\",\n                      time: /* @__PURE__ */ new Date(),\n                      data: handle_payload(\n                        data2.data,\n                        dependency,\n                        config.components,\n                        \"output\",\n                        options.with_null_state\n                      ),\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2.render_config) {\n                      await handle_render_config(data2.render_config);\n                    }\n                    if (complete) {\n                      fire_event({\n                        type: \"status\",\n                        time: /* @__PURE__ */ new Date(),\n                        ...complete,\n                        stage: status2 == null ? void 0 : status2.stage,\n                        queue: true,\n                        endpoint: _endpoint,\n                        fn_index\n                      });\n                      close();\n                    }\n                  }\n                  if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                    if (event_callbacks[event_id]) {\n                      delete event_callbacks[event_id];\n                    }\n                    if (event_id in pending_diff_streams) {\n                      delete pending_diff_streams[event_id];\n                    }\n                  }\n                } catch (e) {\n                  console.error(\"Unexpected client exception\", e);\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: \"An Unexpected Error Occurred!\",\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                  if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                    close_stream(stream_status, that.abort_controller);\n                    stream_status.open = false;\n                    close();\n                  }\n                }\n              };\n              if (event_id in pending_stream_messages) {\n                pending_stream_messages[event_id].forEach(\n                  (msg) => callback(msg)\n                );\n                delete pending_stream_messages[event_id];\n              }\n              event_callbacks[event_id] = callback;\n              unclosed_events.add(event_id);\n              if (!stream_status.open) {\n                await this.open_stream();\n              }\n            }\n          });\n        }\n      }\n    );\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const iterator = {\n      [Symbol.asyncIterator]: () => iterator,\n      next,\n      throw: async (value) => {\n        push_error(value);\n        return next();\n      },\n      return: async () => {\n        close();\n        return next();\n      },\n      cancel,\n      event_id: event_id_cb\n    };\n    return iterator;\n  } catch (error) {\n    console.error(\"Submit function encountered an error:\", error);\n    throw error;\n  }\n}\nfunction thenable_reject(error) {\n  return {\n    then: (resolve, reject) => reject(error)\n  };\n}\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\n  let fn_index;\n  let endpoint_info;\n  let dependency;\n  if (typeof endpoint === \"number\") {\n    fn_index = endpoint;\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\n    dependency = config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    fn_index = api_map[trimmed_endpoint];\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\n    dependency = config.dependencies.find(\n      (dep) => dep.id == api_map[trimmed_endpoint]\n    );\n  }\n  if (typeof fn_index !== \"number\") {\n    throw new Error(\n      \"There is no endpoint matching that name of fn_index matching that number.\"\n    );\n  }\n  return { fn_index, endpoint_info, dependency };\n}\nclass Client {\n  constructor(app_reference, options = { events: [\"data\"] }) {\n    __publicField(this, \"app_reference\");\n    __publicField(this, \"options\");\n    __publicField(this, \"deep_link\", null);\n    __publicField(this, \"config\");\n    __publicField(this, \"api_prefix\", \"\");\n    __publicField(this, \"api_info\");\n    __publicField(this, \"api_map\", {});\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\n    __publicField(this, \"jwt\", false);\n    __publicField(this, \"last_status\", {});\n    __publicField(this, \"cookies\", null);\n    // streaming\n    __publicField(this, \"stream_status\", { open: false });\n    __publicField(this, \"closed\", false);\n    __publicField(this, \"pending_stream_messages\", {});\n    __publicField(this, \"pending_diff_streams\", {});\n    __publicField(this, \"event_callbacks\", {});\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */ new Set());\n    __publicField(this, \"heartbeat_event\", null);\n    __publicField(this, \"abort_controller\", null);\n    __publicField(this, \"stream_instance\", null);\n    __publicField(this, \"current_payload\");\n    __publicField(this, \"ws_map\", {});\n    __publicField(this, \"view_api\");\n    __publicField(this, \"upload_files\");\n    __publicField(this, \"upload\");\n    __publicField(this, \"handle_blob\");\n    __publicField(this, \"post_data\");\n    __publicField(this, \"submit\");\n    __publicField(this, \"predict\");\n    __publicField(this, \"open_stream\");\n    __publicField(this, \"resolve_config\");\n    __publicField(this, \"resolve_cookies\");\n    var _a;\n    this.app_reference = app_reference;\n    this.deep_link = ((_a = options.query_params) == null ? void 0 : _a.deep_link) || null;\n    if (!options.events) {\n      options.events = [\"data\"];\n    }\n    this.options = options;\n    this.current_payload = {};\n    this.view_api = view_api.bind(this);\n    this.upload_files = upload_files.bind(this);\n    this.handle_blob = handle_blob.bind(this);\n    this.post_data = post_data.bind(this);\n    this.submit = submit.bind(this);\n    this.predict = predict.bind(this);\n    this.open_stream = open_stream.bind(this);\n    this.resolve_config = resolve_config.bind(this);\n    this.resolve_cookies = resolve_cookies.bind(this);\n    this.upload = upload.bind(this);\n    this.fetch = this.fetch.bind(this);\n    this.handle_space_success = this.handle_space_success.bind(this);\n    this.stream = this.stream.bind(this);\n  }\n  get_url_config(url = null) {\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    if (url === null) {\n      url = window.location.href;\n    }\n    const stripSlashes = (str) => str.replace(/^\\/+|\\/+$/g, \"\");\n    let root_path = stripSlashes(new URL(this.config.root).pathname);\n    let url_path = stripSlashes(new URL(url).pathname);\n    let page;\n    if (!url_path.startsWith(root_path)) {\n      page = \"\";\n    } else {\n      page = stripSlashes(url_path.substring(root_path.length));\n    }\n    return this.get_page_config(page);\n  }\n  get_page_config(page) {\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    let config = this.config;\n    if (!(page in config.page)) {\n      page = \"\";\n    }\n    return {\n      ...config,\n      current_page: page,\n      layout: config.page[page].layout,\n      components: config.components.filter(\n        (c) => config.page[page].components.includes(c.id)\n      ),\n      dependencies: this.config.dependencies.filter(\n        (d) => config.page[page].dependencies.includes(d.id)\n      )\n    };\n  }\n  fetch(input, init) {\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    if (this && this.options.headers) {\n      for (const name in this.options.headers) {\n        headers.append(name, this.options.headers[name]);\n      }\n    }\n    return fetch(input, { ...init, headers });\n  }\n  stream(url) {\n    const headers = new Headers();\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    if (this && this.options.headers) {\n      for (const name in this.options.headers) {\n        headers.append(name, this.options.headers[name]);\n      }\n    }\n    if (this && this.options.hf_token) {\n      headers.append(\"Authorization\", `Bearer ${this.options.hf_token}`);\n    }\n    this.abort_controller = new AbortController();\n    this.stream_instance = readable_stream(url.toString(), {\n      credentials: \"include\",\n      headers,\n      signal: this.abort_controller.signal\n    });\n    return this.stream_instance;\n  }\n  async init() {\n    var _a;\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\n      {\n        const ws = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@gradio\").then(__webpack_require__.bind(__webpack_require__, /*! ./wrapper-CviSselG.js */ \"(rsc)/./node_modules/@gradio/client/dist/wrapper-CviSselG.js\"));\n        global.WebSocket = ws.WebSocket;\n      }\n    }\n    if (this.options.auth) {\n      await this.resolve_cookies();\n    }\n    await this._resolve_config().then(\n      ({ config }) => this._resolve_heartbeat(config)\n    );\n    this.api_info = await this.view_api();\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\n  }\n  async _resolve_heartbeat(_config) {\n    if (_config) {\n      this.config = _config;\n      this.api_prefix = _config.api_prefix || \"\";\n      if (this.config && this.config.connect_heartbeat) {\n        if (this.config.space_id && this.options.hf_token) {\n          this.jwt = await get_jwt(\n            this.config.space_id,\n            this.options.hf_token,\n            this.cookies\n          );\n        }\n      }\n    }\n    if (_config.space_id && this.options.hf_token) {\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\n    }\n    if (this.config && this.config.connect_heartbeat) {\n      const heartbeat_url = new URL(\n        `${this.config.root}${this.api_prefix}/${HEARTBEAT_URL}/${this.session_hash}`\n      );\n      if (this.jwt) {\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\n      }\n      if (!this.heartbeat_event) {\n        this.heartbeat_event = this.stream(heartbeat_url);\n      }\n    }\n  }\n  static async connect(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    const client2 = new this(app_reference, options);\n    if (options.session_hash) {\n      client2.session_hash = options.session_hash;\n    }\n    await client2.init();\n    return client2;\n  }\n  async reconnect() {\n    const app_id_url = new URL(\n      `${this.config.root}${this.api_prefix}/${APP_ID_URL}`\n    );\n    let app_id;\n    try {\n      const response = await this.fetch(app_id_url);\n      if (!response.ok) {\n        throw new Error();\n      }\n      app_id = (await response.json()).app_id;\n    } catch (e) {\n      return \"broken\";\n    }\n    if (app_id !== this.config.app_id) {\n      return \"changed\";\n    }\n    return \"connected\";\n  }\n  close() {\n    this.closed = true;\n    close_stream(this.stream_status, this.abort_controller);\n  }\n  set_current_payload(payload) {\n    this.current_payload = payload;\n  }\n  static async duplicate(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    return duplicate(app_reference, options);\n  }\n  async _resolve_config() {\n    const { http_protocol, host, space_id } = await process_endpoint(\n      this.app_reference,\n      this.options.hf_token\n    );\n    const { status_callback } = this.options;\n    if (space_id && status_callback) {\n      await check_and_wake_space(space_id, status_callback);\n    }\n    let config;\n    try {\n      let configUrl = `${http_protocol}//${host}`;\n      config = await this.resolve_config(configUrl);\n      if (!config) {\n        throw new Error(CONFIG_ERROR_MSG);\n      }\n      return this.config_success(config);\n    } catch (e) {\n      if (space_id && status_callback) {\n        check_space_status(\n          space_id,\n          RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n          this.handle_space_success\n        );\n      } else {\n        if (status_callback)\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        throw Error(e);\n      }\n    }\n  }\n  async config_success(_config) {\n    this.config = _config;\n    this.api_prefix = _config.api_prefix || \"\";\n    if (this.config.auth_required) {\n      return this.prepare_return_obj();\n    }\n    try {\n      this.api_info = await this.view_api();\n    } catch (e) {\n      console.error(API_INFO_ERROR_MSG + e.message);\n    }\n    return this.prepare_return_obj();\n  }\n  async handle_space_success(status) {\n    var _a;\n    if (!this) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const { status_callback } = this.options;\n    if (status_callback)\n      status_callback(status);\n    if (status.status === \"running\") {\n      try {\n        this.config = await this._resolve_config();\n        this.api_prefix = ((_a = this == null ? void 0 : this.config) == null ? void 0 : _a.api_prefix) || \"\";\n        if (!this.config) {\n          throw new Error(CONFIG_ERROR_MSG);\n        }\n        const _config = await this.config_success(this.config);\n        return _config;\n      } catch (e) {\n        if (status_callback) {\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n        throw e;\n      }\n    }\n  }\n  async component_server(component_id, fn_name, data) {\n    var _a;\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const headers = {};\n    const { hf_token } = this.options;\n    const { session_hash } = this;\n    if (hf_token) {\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\n    }\n    let root_url;\n    let component = this.config.components.find(\n      (comp) => comp.id === component_id\n    );\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n      root_url = component.props.root_url;\n    } else {\n      root_url = this.config.root;\n    }\n    let body;\n    if (\"binary\" in data) {\n      body = new FormData();\n      for (const key in data.data) {\n        if (key === \"binary\")\n          continue;\n        body.append(key, data.data[key]);\n      }\n      body.set(\"component_id\", component_id.toString());\n      body.set(\"fn_name\", fn_name);\n      body.set(\"session_hash\", session_hash);\n    } else {\n      body = JSON.stringify({\n        data,\n        component_id,\n        fn_name,\n        session_hash\n      });\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (hf_token) {\n      headers.Authorization = `Bearer ${hf_token}`;\n    }\n    try {\n      const response = await this.fetch(\n        `${root_url}${this.api_prefix}/${COMPONENT_SERVER_URL}/`,\n        {\n          method: \"POST\",\n          body,\n          headers,\n          credentials: \"include\"\n        }\n      );\n      if (!response.ok) {\n        throw new Error(\n          \"Could not connect to component server: \" + response.statusText\n        );\n      }\n      const output = await response.json();\n      return output;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  set_cookies(raw_cookies) {\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\n  }\n  prepare_return_obj() {\n    return {\n      config: this.config,\n      predict: this.predict,\n      submit: this.submit,\n      view_api: this.view_api,\n      component_server: this.component_server\n    };\n  }\n  async connect_ws(url) {\n    return new Promise((resolve, reject) => {\n      let ws;\n      try {\n        ws = new WebSocket(url);\n      } catch (e) {\n        this.ws_map[url] = \"failed\";\n        return;\n      }\n      this.ws_map[url] = \"pending\";\n      ws.onopen = () => {\n        this.ws_map[url] = ws;\n        resolve();\n      };\n      ws.onerror = (error) => {\n        console.error(\"WebSocket error:\", error);\n        this.close_ws(url);\n        this.ws_map[url] = \"failed\";\n        resolve();\n      };\n      ws.onclose = () => {\n        this.ws_map[url] = \"closed\";\n      };\n      ws.onmessage = (event) => {\n      };\n    });\n  }\n  async send_ws_message(url, data) {\n    if (!(url in this.ws_map)) {\n      await this.connect_ws(url);\n    } else if (this.ws_map[url] === \"pending\" || this.ws_map[url] === \"closed\" || this.ws_map[url] === \"failed\") {\n      return;\n    }\n    const ws = this.ws_map[url];\n    if (ws instanceof WebSocket) {\n      ws.send(JSON.stringify(data));\n    } else {\n      this.post_data(url, data);\n    }\n  }\n  async close_ws(url) {\n    if (url in this.ws_map) {\n      const ws = this.ws_map[url];\n      if (ws instanceof WebSocket) {\n        ws.close();\n        delete this.ws_map[url];\n      }\n    }\n  }\n}\nasync function client(app_reference, options = {\n  events: [\"data\"]\n}) {\n  return await Client.connect(app_reference, options);\n}\nasync function duplicate_space(app_reference, options) {\n  return await Client.duplicate(app_reference, options);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdyYWRpby9jbGllbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxNQUFNO0FBQ3JFO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkMsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUIsc0JBQXNCLElBQUk7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFD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QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcU2hsb2tcXENvbGxlZ2VcXGRpdHRvLXRhbGtpbmdoZWFkXFxJbnRlcmZhY2VcXG5vZGVfbW9kdWxlc1xcQGdyYWRpb1xcY2xpZW50XFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfY3VycmVudExpbmU7XG52YXIgZm4gPSBuZXcgSW50bC5Db2xsYXRvcigwLCB7IG51bWVyaWM6IDEgfSkuY29tcGFyZTtcbmZ1bmN0aW9uIHNlbWl2ZXIoYSwgYiwgYm9vbCkge1xuICBhID0gYS5zcGxpdChcIi5cIik7XG4gIGIgPSBiLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIGZuKGFbMF0sIGJbMF0pIHx8IGZuKGFbMV0sIGJbMV0pIHx8IChiWzJdID0gYi5zbGljZSgyKS5qb2luKFwiLlwiKSwgYm9vbCA9IC9bLi1dLy50ZXN0KGFbMl0gPSBhLnNsaWNlKDIpLmpvaW4oXCIuXCIpKSwgYm9vbCA9PSAvWy4tXS8udGVzdChiWzJdKSA/IGZuKGFbMl0sIGJbMl0pIDogYm9vbCA/IC0xIDogMSk7XG59XG5jb25zdCBIT1NUX1VSTCA9IGBob3N0YDtcbmNvbnN0IFNTRV9VUkwgPSBgcXVldWUvZGF0YWA7XG5jb25zdCBTU0VfREFUQV9VUkwgPSBgcXVldWUvam9pbmA7XG5jb25zdCBVUExPQURfVVJMID0gYHVwbG9hZGA7XG5jb25zdCBMT0dJTl9VUkwgPSBgbG9naW5gO1xuY29uc3QgQ09ORklHX1VSTCA9IGBjb25maWdgO1xuY29uc3QgQVBJX0lORk9fVVJMID0gYGluZm9gO1xuY29uc3QgUlVOVElNRV9VUkwgPSBgcnVudGltZWA7XG5jb25zdCBTTEVFUFRJTUVfVVJMID0gYHNsZWVwdGltZWA7XG5jb25zdCBIRUFSVEJFQVRfVVJMID0gYGhlYXJ0YmVhdGA7XG5jb25zdCBDT01QT05FTlRfU0VSVkVSX1VSTCA9IGBjb21wb25lbnRfc2VydmVyYDtcbmNvbnN0IFJFU0VUX1VSTCA9IGByZXNldGA7XG5jb25zdCBDQU5DRUxfVVJMID0gYGNhbmNlbGA7XG5jb25zdCBBUFBfSURfVVJMID0gYGFwcF9pZGA7XG5jb25zdCBTUEFDRV9GRVRDSEVSX1VSTCA9IFwiaHR0cHM6Ly9ncmFkaW8tc3BhY2UtYXBpLWZldGNoZXItdjIuaGYuc3BhY2UvYXBpXCI7XG5jb25zdCBRVUVVRV9GVUxMX01TRyA9IFwiVGhpcyBhcHBsaWNhdGlvbiBpcyBjdXJyZW50bHkgYnVzeS4gUGxlYXNlIHRyeSBhZ2Fpbi4gXCI7XG5jb25zdCBCUk9LRU5fQ09OTkVDVElPTl9NU0cgPSBcIkNvbm5lY3Rpb24gZXJyb3JlZCBvdXQuIFwiO1xuY29uc3QgQ09ORklHX0VSUk9SX01TRyA9IFwiQ291bGQgbm90IHJlc29sdmUgYXBwIGNvbmZpZy4gXCI7XG5jb25zdCBTUEFDRV9TVEFUVVNfRVJST1JfTVNHID0gXCJDb3VsZCBub3QgZ2V0IHNwYWNlIHN0YXR1cy4gXCI7XG5jb25zdCBBUElfSU5GT19FUlJPUl9NU0cgPSBcIkNvdWxkIG5vdCBnZXQgQVBJIGluZm8uIFwiO1xuY29uc3QgU1BBQ0VfTUVUQURBVEFfRVJST1JfTVNHID0gXCJTcGFjZSBtZXRhZGF0YSBjb3VsZCBub3QgYmUgbG9hZGVkLiBcIjtcbmNvbnN0IElOVkFMSURfVVJMX01TRyA9IFwiSW52YWxpZCBVUkwuIEEgZnVsbCBVUkwgcGF0aCBpcyByZXF1aXJlZC5cIjtcbmNvbnN0IFVOQVVUSE9SSVpFRF9NU0cgPSBcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIHNwYWNlLiBcIjtcbmNvbnN0IElOVkFMSURfQ1JFREVOVElBTFNfTVNHID0gXCJJbnZhbGlkIGNyZWRlbnRpYWxzLiBDb3VsZCBub3QgbG9naW4uIFwiO1xuY29uc3QgTUlTU0lOR19DUkVERU5USUFMU19NU0cgPSBcIkxvZ2luIGNyZWRlbnRpYWxzIGFyZSByZXF1aXJlZCB0byBhY2Nlc3MgdGhpcyBzcGFjZS5cIjtcbmNvbnN0IE5PREVKU19GU19FUlJPUl9NU0cgPSBcIkZpbGUgc3lzdGVtIGFjY2VzcyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlLmpzIGVudmlyb25tZW50c1wiO1xuY29uc3QgUk9PVF9VUkxfRVJST1JfTVNHID0gXCJSb290IFVSTCBub3QgZm91bmQgaW4gY2xpZW50IGNvbmZpZ1wiO1xuY29uc3QgRklMRV9QUk9DRVNTSU5HX0VSUk9SX01TRyA9IFwiRXJyb3IgdXBsb2FkaW5nIGZpbGVcIjtcbmZ1bmN0aW9uIHJlc29sdmVfcm9vdChiYXNlX3VybCwgcm9vdF9wYXRoLCBwcmlvcml0aXplX2Jhc2UpIHtcbiAgaWYgKHJvb3RfcGF0aC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCByb290X3BhdGguc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgcmV0dXJuIHByaW9yaXRpemVfYmFzZSA/IGJhc2VfdXJsIDogcm9vdF9wYXRoO1xuICB9XG4gIHJldHVybiBiYXNlX3VybCArIHJvb3RfcGF0aDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldF9qd3Qoc3BhY2UsIHRva2VuLCBjb29raWVzKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgciA9IGF3YWl0IGZldGNoKGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS9zcGFjZXMvJHtzcGFjZX0vand0YCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgICAgLi4uY29va2llcyA/IHsgQ29va2llOiBjb29raWVzIH0gOiB7fVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGp3dCA9IChhd2FpdCByLmpzb24oKSkudG9rZW47XG4gICAgcmV0dXJuIGp3dCB8fCBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwX25hbWVzX3RvX2lkcyhmbnMpIHtcbiAgbGV0IGFwaXMgPSB7fTtcbiAgZm5zLmZvckVhY2goKHsgYXBpX25hbWUsIGlkIH0pID0+IHtcbiAgICBpZiAoYXBpX25hbWUpXG4gICAgICBhcGlzW2FwaV9uYW1lXSA9IGlkO1xuICB9KTtcbiAgcmV0dXJuIGFwaXM7XG59XG5hc3luYyBmdW5jdGlvbiByZXNvbHZlX2NvbmZpZyhlbmRwb2ludCkge1xuICBjb25zdCBoZWFkZXJzID0gdGhpcy5vcHRpb25zLmhmX3Rva2VuID8geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5vcHRpb25zLmhmX3Rva2VufWAgfSA6IHt9O1xuICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5ncmFkaW9fY29uZmlnICYmIGxvY2F0aW9uLm9yaWdpbiAhPT0gXCJodHRwOi8vbG9jYWxob3N0Ojk4NzZcIiAmJiAhd2luZG93LmdyYWRpb19jb25maWcuZGV2X21vZGUpIHtcbiAgICBpZiAod2luZG93LmdyYWRpb19jb25maWcuY3VycmVudF9wYWdlKSB7XG4gICAgICBlbmRwb2ludCA9IGVuZHBvaW50LnN1YnN0cmluZygwLCBlbmRwb2ludC5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgIH1cbiAgICB3aW5kb3cuZ3JhZGlvX2NvbmZpZy5yb290ID0gZW5kcG9pbnQ7XG4gICAgcmV0dXJuIHsgLi4ud2luZG93LmdyYWRpb19jb25maWcgfTtcbiAgfSBlbHNlIGlmIChlbmRwb2ludCkge1xuICAgIGxldCBjb25maWdfdXJsID0gam9pbl91cmxzKFxuICAgICAgZW5kcG9pbnQsXG4gICAgICB0aGlzLmRlZXBfbGluayA/IENPTkZJR19VUkwgKyBcIj9kZWVwX2xpbms9XCIgKyB0aGlzLmRlZXBfbGluayA6IENPTkZJR19VUkxcbiAgICApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaChjb25maWdfdXJsLCB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiXG4gICAgfSk7XG4gICAgcmV0dXJuIGhhbmRsZUNvbmZpZ1Jlc3BvbnNlKHJlc3BvbnNlLCBlbmRwb2ludCwgISF0aGlzLm9wdGlvbnMuYXV0aCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKENPTkZJR19FUlJPUl9NU0cpO1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlQ29uZmlnUmVzcG9uc2UocmVzcG9uc2UsIGVuZHBvaW50LCBhdXRob3JpemVkKSB7XG4gIHZhciBfYSwgX2I7XG4gIGlmICgocmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLnN0YXR1cykgPT09IDQwMSAmJiAhYXV0aG9yaXplZCkge1xuICAgIGNvbnN0IGVycm9yX2RhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgYXV0aF9tZXNzYWdlID0gKF9hID0gZXJyb3JfZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JfZGF0YS5kZXRhaWwpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hdXRoX21lc3NhZ2U7XG4gICAgdGhyb3cgbmV3IEVycm9yKGF1dGhfbWVzc2FnZSB8fCBNSVNTSU5HX0NSRURFTlRJQUxTX01TRyk7XG4gIH0gZWxzZSBpZiAoKHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMpID09PSA0MDEgJiYgYXV0aG9yaXplZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0NSRURFTlRJQUxTX01TRyk7XG4gIH1cbiAgaWYgKChyZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2Uuc3RhdHVzKSA9PT0gMjAwKSB7XG4gICAgbGV0IGNvbmZpZyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25maWcucm9vdCA9IGVuZHBvaW50O1xuICAgIChfYiA9IGNvbmZpZy5kZXBlbmRlbmNpZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mb3JFYWNoKChkZXAsIGkpID0+IHtcbiAgICAgIGlmIChkZXAuaWQgPT09IHZvaWQgMCkge1xuICAgICAgICBkZXAuaWQgPSBpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb25maWc7XG4gIH0gZWxzZSBpZiAoKHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMpID09PSA0MDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVU5BVVRIT1JJWkVEX01TRyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKENPTkZJR19FUlJPUl9NU0cpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZV9jb29raWVzKCkge1xuICBjb25zdCB7IGh0dHBfcHJvdG9jb2wsIGhvc3QgfSA9IGF3YWl0IHByb2Nlc3NfZW5kcG9pbnQoXG4gICAgdGhpcy5hcHBfcmVmZXJlbmNlLFxuICAgIHRoaXMub3B0aW9ucy5oZl90b2tlblxuICApO1xuICB0cnkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0aCkge1xuICAgICAgY29uc3QgY29va2llX2hlYWRlciA9IGF3YWl0IGdldF9jb29raWVfaGVhZGVyKFxuICAgICAgICBodHRwX3Byb3RvY29sLFxuICAgICAgICBob3N0LFxuICAgICAgICB0aGlzLm9wdGlvbnMuYXV0aCxcbiAgICAgICAgdGhpcy5mZXRjaCxcbiAgICAgICAgdGhpcy5vcHRpb25zLmhmX3Rva2VuXG4gICAgICApO1xuICAgICAgaWYgKGNvb2tpZV9oZWFkZXIpXG4gICAgICAgIHRoaXMuc2V0X2Nvb2tpZXMoY29va2llX2hlYWRlcik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgRXJyb3IoZS5tZXNzYWdlKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0X2Nvb2tpZV9oZWFkZXIoaHR0cF9wcm90b2NvbCwgaG9zdCwgYXV0aCwgX2ZldGNoLCBoZl90b2tlbikge1xuICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBmb3JtRGF0YS5hcHBlbmQoXCJ1c2VybmFtZVwiLCBhdXRoID09IG51bGwgPyB2b2lkIDAgOiBhdXRoWzBdKTtcbiAgZm9ybURhdGEuYXBwZW5kKFwicGFzc3dvcmRcIiwgYXV0aCA9PSBudWxsID8gdm9pZCAwIDogYXV0aFsxXSk7XG4gIGxldCBoZWFkZXJzID0ge307XG4gIGlmIChoZl90b2tlbikge1xuICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHtoZl90b2tlbn1gO1xuICB9XG4gIGNvbnN0IHJlcyA9IGF3YWl0IF9mZXRjaChgJHtodHRwX3Byb3RvY29sfS8vJHtob3N0fS8ke0xPR0lOX1VSTH1gLCB7XG4gICAgaGVhZGVycyxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIlxuICB9KTtcbiAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgIHJldHVybiByZXMuaGVhZGVycy5nZXQoXCJzZXQtY29va2llXCIpO1xuICB9IGVsc2UgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0NSRURFTlRJQUxTX01TRyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFNQQUNFX01FVEFEQVRBX0VSUk9SX01TRyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZV9wcm90b2NvbChlbmRwb2ludCkge1xuICBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICBjb25zdCB7IHByb3RvY29sLCBob3N0LCBwYXRobmFtZSB9ID0gbmV3IFVSTChlbmRwb2ludCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdzX3Byb3RvY29sOiBwcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwid3NzXCIgOiBcIndzXCIsXG4gICAgICBodHRwX3Byb3RvY29sOiBwcm90b2NvbCxcbiAgICAgIGhvc3Q6IGhvc3QgKyAocGF0aG5hbWUgIT09IFwiL1wiID8gcGF0aG5hbWUgOiBcIlwiKVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZW5kcG9pbnQuc3RhcnRzV2l0aChcImZpbGU6XCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdzX3Byb3RvY29sOiBcIndzXCIsXG4gICAgICBodHRwX3Byb3RvY29sOiBcImh0dHA6XCIsXG4gICAgICBob3N0OiBcImxpdGUubG9jYWxcIlxuICAgICAgLy8gU3BlY2lhbCBmYWtlIGhvc3RuYW1lIG9ubHkgdXNlZCBmb3IgdGhpcyBjYXNlLiBUaGlzIG1hdGNoZXMgdGhlIGhvc3RuYW1lIGFsbG93ZWQgaW4gYGlzX3NlbGZfaG9zdCgpYCBpbiBganMvd2FzbS9uZXR3b3JrL2hvc3QudHNgLlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3c19wcm90b2NvbDogXCJ3c3NcIixcbiAgICBodHRwX3Byb3RvY29sOiBcImh0dHBzOlwiLFxuICAgIGhvc3Q6IG5ldyBVUkwoZW5kcG9pbnQpLmhvc3RcbiAgfTtcbn1cbmNvbnN0IHBhcnNlX2FuZF9zZXRfY29va2llcyA9IChjb29raWVfaGVhZGVyKSA9PiB7XG4gIGxldCBjb29raWVzID0gW107XG4gIGNvbnN0IHBhcnRzID0gY29va2llX2hlYWRlci5zcGxpdCgvLCg/PVxccypbXlxccz07XSs9W15cXHM9O10rKS8pO1xuICBwYXJ0cy5mb3JFYWNoKChjb29raWUpID0+IHtcbiAgICBjb25zdCBbY29va2llX25hbWUsIGNvb2tpZV92YWx1ZV0gPSBjb29raWUuc3BsaXQoXCI7XCIpWzBdLnNwbGl0KFwiPVwiKTtcbiAgICBpZiAoY29va2llX25hbWUgJiYgY29va2llX3ZhbHVlKSB7XG4gICAgICBjb29raWVzLnB1c2goYCR7Y29va2llX25hbWUudHJpbSgpfT0ke2Nvb2tpZV92YWx1ZS50cmltKCl9YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvb2tpZXM7XG59O1xuY29uc3QgUkVfU1BBQ0VfTkFNRSA9IC9eW2EtekEtWjAtOV9cXC1cXC5dK1xcL1thLXpBLVowLTlfXFwtXFwuXSskLztcbmNvbnN0IFJFX1NQQUNFX0RPTUFJTiA9IC8uKmhmXFwuc3BhY2VcXC97MCwxfS4qJC87XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzX2VuZHBvaW50KGFwcF9yZWZlcmVuY2UsIGhmX3Rva2VuKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGhmX3Rva2VuKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2hmX3Rva2VufWA7XG4gIH1cbiAgY29uc3QgX2FwcF9yZWZlcmVuY2UgPSBhcHBfcmVmZXJlbmNlLnRyaW0oKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIGlmIChSRV9TUEFDRV9OQU1FLnRlc3QoX2FwcF9yZWZlcmVuY2UpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvc3BhY2VzLyR7X2FwcF9yZWZlcmVuY2V9LyR7SE9TVF9VUkx9YCxcbiAgICAgICAgeyBoZWFkZXJzIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBfaG9zdCA9IChhd2FpdCByZXMuanNvbigpKS5ob3N0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3BhY2VfaWQ6IGFwcF9yZWZlcmVuY2UsXG4gICAgICAgIC4uLmRldGVybWluZV9wcm90b2NvbChfaG9zdClcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFNQQUNFX01FVEFEQVRBX0VSUk9SX01TRyk7XG4gICAgfVxuICB9XG4gIGlmIChSRV9TUEFDRV9ET01BSU4udGVzdChfYXBwX3JlZmVyZW5jZSkpIHtcbiAgICBjb25zdCB7IHdzX3Byb3RvY29sLCBodHRwX3Byb3RvY29sLCBob3N0IH0gPSBkZXRlcm1pbmVfcHJvdG9jb2woX2FwcF9yZWZlcmVuY2UpO1xuICAgIHJldHVybiB7XG4gICAgICBzcGFjZV9pZDogaG9zdC5zcGxpdChcIi9cIilbMF0ucmVwbGFjZShcIi5oZi5zcGFjZVwiLCBcIlwiKSxcbiAgICAgIHdzX3Byb3RvY29sLFxuICAgICAgaHR0cF9wcm90b2NvbCxcbiAgICAgIGhvc3RcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3BhY2VfaWQ6IGZhbHNlLFxuICAgIC4uLmRldGVybWluZV9wcm90b2NvbChfYXBwX3JlZmVyZW5jZSlcbiAgfTtcbn1cbmNvbnN0IGpvaW5fdXJscyA9ICguLi51cmxzKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHVybHMucmVkdWNlKChiYXNlX3VybCwgcGFydCkgPT4ge1xuICAgICAgYmFzZV91cmwgPSBiYXNlX3VybC5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuICAgICAgcGFydCA9IHBhcnQucmVwbGFjZSgvXlxcLysvLCBcIlwiKTtcbiAgICAgIHJldHVybiBuZXcgVVJMKHBhcnQsIGJhc2VfdXJsICsgXCIvXCIpLnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VUkxfTVNHKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybV9hcGlfaW5mbyhhcGlfaW5mbywgY29uZmlnLCBhcGlfbWFwKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkX2luZm8gPSB7XG4gICAgbmFtZWRfZW5kcG9pbnRzOiB7fSxcbiAgICB1bm5hbWVkX2VuZHBvaW50czoge31cbiAgfTtcbiAgT2JqZWN0LmtleXMoYXBpX2luZm8pLmZvckVhY2goKGNhdGVnb3J5KSA9PiB7XG4gICAgaWYgKGNhdGVnb3J5ID09PSBcIm5hbWVkX2VuZHBvaW50c1wiIHx8IGNhdGVnb3J5ID09PSBcInVubmFtZWRfZW5kcG9pbnRzXCIpIHtcbiAgICAgIHRyYW5zZm9ybWVkX2luZm9bY2F0ZWdvcnldID0ge307XG4gICAgICBPYmplY3QuZW50cmllcyhhcGlfaW5mb1tjYXRlZ29yeV0pLmZvckVhY2goXG4gICAgICAgIChbZW5kcG9pbnQsIHsgcGFyYW1ldGVycywgcmV0dXJucyB9XSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBjb25zdCBkZXBlbmRlbmN5SW5kZXggPSAoKF9hID0gY29uZmlnLmRlcGVuZGVuY2llcy5maW5kKFxuICAgICAgICAgICAgKGRlcCkgPT4gZGVwLmFwaV9uYW1lID09PSBlbmRwb2ludCB8fCBkZXAuYXBpX25hbWUgPT09IGVuZHBvaW50LnJlcGxhY2UoXCIvXCIsIFwiXCIpXG4gICAgICAgICAgKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmlkKSB8fCBhcGlfbWFwW2VuZHBvaW50LnJlcGxhY2UoXCIvXCIsIFwiXCIpXSB8fCAtMTtcbiAgICAgICAgICBjb25zdCBkZXBlbmRlbmN5VHlwZXMgPSBkZXBlbmRlbmN5SW5kZXggIT09IC0xID8gKF9iID0gY29uZmlnLmRlcGVuZGVuY2llcy5maW5kKChkZXApID0+IGRlcC5pZCA9PSBkZXBlbmRlbmN5SW5kZXgpKSA9PSBudWxsID8gdm9pZCAwIDogX2IudHlwZXMgOiB7IGdlbmVyYXRvcjogZmFsc2UsIGNhbmNlbDogZmFsc2UgfTtcbiAgICAgICAgICBpZiAoZGVwZW5kZW5jeUluZGV4ICE9PSAtMSAmJiAoKF9kID0gKF9jID0gY29uZmlnLmRlcGVuZGVuY2llcy5maW5kKChkZXApID0+IGRlcC5pZCA9PSBkZXBlbmRlbmN5SW5kZXgpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaW5wdXRzKSA9PSBudWxsID8gdm9pZCAwIDogX2QubGVuZ3RoKSAhPT0gcGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBjb25maWcuZGVwZW5kZW5jaWVzLmZpbmQoKGRlcCkgPT4gZGVwLmlkID09IGRlcGVuZGVuY3lJbmRleCkuaW5wdXRzLm1hcChcbiAgICAgICAgICAgICAgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hMiA9IGNvbmZpZy5jb21wb25lbnRzLmZpbmQoKGMpID0+IGMuaWQgPT09IGlucHV0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi50eXBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKChjb21wLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcCA9PT0gXCJzdGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdfcGFyYW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogXCJzdGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBleGFtcGxlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyX2hhc19kZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJfbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycy5zcGxpY2UoaWR4LCAwLCBuZXdfcGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybV90eXBlID0gKGRhdGEsIGNvbXBvbmVudCwgc2VyaWFsaXplciwgc2lnbmF0dXJlX3R5cGUpID0+ICh7XG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGdldF9kZXNjcmlwdGlvbihkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLnR5cGUsIHNlcmlhbGl6ZXIpLFxuICAgICAgICAgICAgdHlwZTogZ2V0X3R5cGUoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS50eXBlLCBjb21wb25lbnQsIHNlcmlhbGl6ZXIsIHNpZ25hdHVyZV90eXBlKSB8fCBcIlwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNmb3JtZWRfaW5mb1tjYXRlZ29yeV1bZW5kcG9pbnRdID0ge1xuICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycy5tYXAoXG4gICAgICAgICAgICAgIChwKSA9PiB0cmFuc2Zvcm1fdHlwZShwLCBwID09IG51bGwgPyB2b2lkIDAgOiBwLmNvbXBvbmVudCwgcCA9PSBudWxsID8gdm9pZCAwIDogcC5zZXJpYWxpemVyLCBcInBhcmFtZXRlclwiKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVybnMubWFwKFxuICAgICAgICAgICAgICAocikgPT4gdHJhbnNmb3JtX3R5cGUociwgciA9PSBudWxsID8gdm9pZCAwIDogci5jb21wb25lbnQsIHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc2VyaWFsaXplciwgXCJyZXR1cm5cIilcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0eXBlOiBkZXBlbmRlbmN5VHlwZXNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0cmFuc2Zvcm1lZF9pbmZvO1xufVxuZnVuY3Rpb24gZ2V0X3R5cGUodHlwZSwgY29tcG9uZW50LCBzZXJpYWxpemVyLCBzaWduYXR1cmVfdHlwZSkge1xuICBpZiAoY29tcG9uZW50ID09PSBcIkFwaVwiKVxuICAgIHJldHVybiB0eXBlLnR5cGU7XG4gIHN3aXRjaCAodHlwZSA9PSBudWxsID8gdm9pZCAwIDogdHlwZS50eXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgfVxuICBpZiAoc2VyaWFsaXplciA9PT0gXCJKU09OU2VyaWFsaXphYmxlXCIgfHwgc2VyaWFsaXplciA9PT0gXCJTdHJpbmdTZXJpYWxpemFibGVcIikge1xuICAgIHJldHVybiBcImFueVwiO1xuICB9IGVsc2UgaWYgKHNlcmlhbGl6ZXIgPT09IFwiTGlzdFN0cmluZ1NlcmlhbGl6YWJsZVwiKSB7XG4gICAgcmV0dXJuIFwic3RyaW5nW11cIjtcbiAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09IFwiSW1hZ2VcIikge1xuICAgIHJldHVybiBzaWduYXR1cmVfdHlwZSA9PT0gXCJwYXJhbWV0ZXJcIiA/IFwiQmxvYiB8IEZpbGUgfCBCdWZmZXJcIiA6IFwic3RyaW5nXCI7XG4gIH0gZWxzZSBpZiAoc2VyaWFsaXplciA9PT0gXCJGaWxlU2VyaWFsaXphYmxlXCIpIHtcbiAgICBpZiAoKHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUudHlwZSkgPT09IFwiYXJyYXlcIikge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZV90eXBlID09PSBcInBhcmFtZXRlclwiID8gXCIoQmxvYiB8IEZpbGUgfCBCdWZmZXIpW11cIiA6IGB7IG5hbWU6IHN0cmluZzsgZGF0YTogc3RyaW5nOyBzaXplPzogbnVtYmVyOyBpc19maWxlPzogYm9vbGVhbjsgb3JpZ19uYW1lPzogc3RyaW5nfVtdYDtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25hdHVyZV90eXBlID09PSBcInBhcmFtZXRlclwiID8gXCJCbG9iIHwgRmlsZSB8IEJ1ZmZlclwiIDogYHsgbmFtZTogc3RyaW5nOyBkYXRhOiBzdHJpbmc7IHNpemU/OiBudW1iZXI7IGlzX2ZpbGU/OiBib29sZWFuOyBvcmlnX25hbWU/OiBzdHJpbmd9YDtcbiAgfSBlbHNlIGlmIChzZXJpYWxpemVyID09PSBcIkdhbGxlcnlTZXJpYWxpemFibGVcIikge1xuICAgIHJldHVybiBzaWduYXR1cmVfdHlwZSA9PT0gXCJwYXJhbWV0ZXJcIiA/IFwiWyhCbG9iIHwgRmlsZSB8IEJ1ZmZlciksIChzdHJpbmcgfCBudWxsKV1bXVwiIDogYFt7IG5hbWU6IHN0cmluZzsgZGF0YTogc3RyaW5nOyBzaXplPzogbnVtYmVyOyBpc19maWxlPzogYm9vbGVhbjsgb3JpZ19uYW1lPzogc3RyaW5nfSwgKHN0cmluZyB8IG51bGwpKV1bXWA7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldF9kZXNjcmlwdGlvbih0eXBlLCBzZXJpYWxpemVyKSB7XG4gIGlmIChzZXJpYWxpemVyID09PSBcIkdhbGxlcnlTZXJpYWxpemFibGVcIikge1xuICAgIHJldHVybiBcImFycmF5IG9mIFtmaWxlLCBsYWJlbF0gdHVwbGVzXCI7XG4gIH0gZWxzZSBpZiAoc2VyaWFsaXplciA9PT0gXCJMaXN0U3RyaW5nU2VyaWFsaXphYmxlXCIpIHtcbiAgICByZXR1cm4gXCJhcnJheSBvZiBzdHJpbmdzXCI7XG4gIH0gZWxzZSBpZiAoc2VyaWFsaXplciA9PT0gXCJGaWxlU2VyaWFsaXphYmxlXCIpIHtcbiAgICByZXR1cm4gXCJhcnJheSBvZiBmaWxlcyBvciBzaW5nbGUgZmlsZVwiO1xuICB9XG4gIHJldHVybiB0eXBlID09IG51bGwgPyB2b2lkIDAgOiB0eXBlLmRlc2NyaXB0aW9uO1xufVxuZnVuY3Rpb24gaGFuZGxlX21lc3NhZ2UoZGF0YSwgbGFzdF9zdGF0dXMpIHtcbiAgY29uc3QgcXVldWUgPSB0cnVlO1xuICBzd2l0Y2ggKGRhdGEubXNnKSB7XG4gICAgY2FzZSBcInNlbmRfZGF0YVwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIgfTtcbiAgICBjYXNlIFwic2VuZF9oYXNoXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImhhc2hcIiB9O1xuICAgIGNhc2UgXCJxdWV1ZV9mdWxsXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBRVUVVRV9GVUxMX01TRyxcbiAgICAgICAgICBzdGFnZTogXCJlcnJvclwiLFxuICAgICAgICAgIGNvZGU6IGRhdGEuY29kZSxcbiAgICAgICAgICBzdWNjZXNzOiBkYXRhLnN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBjYXNlIFwiaGVhcnRiZWF0XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImhlYXJ0YmVhdFwiXG4gICAgICB9O1xuICAgIGNhc2UgXCJ1bmV4cGVjdGVkX2Vycm9yXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVuZXhwZWN0ZWRfZXJyb3JcIixcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlLFxuICAgICAgICAgIHNlc3Npb25fbm90X2ZvdW5kOiBkYXRhLnNlc3Npb25fbm90X2ZvdW5kLFxuICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBjYXNlIFwiYnJva2VuX2Nvbm5lY3Rpb25cIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYnJva2VuX2Nvbm5lY3Rpb25cIixcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgbWVzc2FnZTogZGF0YS5tZXNzYWdlLFxuICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBjYXNlIFwiZXN0aW1hdGlvblwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgc3RhZ2U6IGxhc3Rfc3RhdHVzIHx8IFwicGVuZGluZ1wiLFxuICAgICAgICAgIGNvZGU6IGRhdGEuY29kZSxcbiAgICAgICAgICBzaXplOiBkYXRhLnF1ZXVlX3NpemUsXG4gICAgICAgICAgcG9zaXRpb246IGRhdGEucmFuayxcbiAgICAgICAgICBldGE6IGRhdGEucmFua19ldGEsXG4gICAgICAgICAgc3VjY2VzczogZGF0YS5zdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgY2FzZSBcInByb2dyZXNzXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxuICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICBzdGFnZTogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgY29kZTogZGF0YS5jb2RlLFxuICAgICAgICAgIHByb2dyZXNzX2RhdGE6IGRhdGEucHJvZ3Jlc3NfZGF0YSxcbiAgICAgICAgICBzdWNjZXNzOiBkYXRhLnN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICBjYXNlIFwibG9nXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxvZ1wiLCBkYXRhIH07XG4gICAgY2FzZSBcInByb2Nlc3NfZ2VuZXJhdGluZ1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJnZW5lcmF0aW5nXCIsXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIG1lc3NhZ2U6ICFkYXRhLnN1Y2Nlc3MgPyBkYXRhLm91dHB1dC5lcnJvciA6IG51bGwsXG4gICAgICAgICAgc3RhZ2U6IGRhdGEuc3VjY2VzcyA/IFwiZ2VuZXJhdGluZ1wiIDogXCJlcnJvclwiLFxuICAgICAgICAgIGNvZGU6IGRhdGEuY29kZSxcbiAgICAgICAgICBwcm9ncmVzc19kYXRhOiBkYXRhLnByb2dyZXNzX2RhdGEsXG4gICAgICAgICAgZXRhOiBkYXRhLmF2ZXJhZ2VfZHVyYXRpb24sXG4gICAgICAgICAgY2hhbmdlZF9zdGF0ZV9pZHM6IGRhdGEuc3VjY2VzcyA/IGRhdGEub3V0cHV0LmNoYW5nZWRfc3RhdGVfaWRzIDogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IGRhdGEuc3VjY2VzcyA/IGRhdGEub3V0cHV0IDogbnVsbFxuICAgICAgfTtcbiAgICBjYXNlIFwicHJvY2Vzc19zdHJlYW1pbmdcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RyZWFtaW5nXCIsXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRhdGEub3V0cHV0LmVycm9yLFxuICAgICAgICAgIHN0YWdlOiBcInN0cmVhbWluZ1wiLFxuICAgICAgICAgIHRpbWVfbGltaXQ6IGRhdGEudGltZV9saW1pdCxcbiAgICAgICAgICBjb2RlOiBkYXRhLmNvZGUsXG4gICAgICAgICAgcHJvZ3Jlc3NfZGF0YTogZGF0YS5wcm9ncmVzc19kYXRhLFxuICAgICAgICAgIGV0YTogZGF0YS5ldGFcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogZGF0YS5vdXRwdXRcbiAgICAgIH07XG4gICAgY2FzZSBcInByb2Nlc3NfY29tcGxldGVkXCI6XG4gICAgICBpZiAoXCJlcnJvclwiIGluIGRhdGEub3V0cHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgdGl0bGU6IGRhdGEub3V0cHV0LnRpdGxlLFxuICAgICAgICAgICAgbWVzc2FnZTogZGF0YS5vdXRwdXQuZXJyb3IsXG4gICAgICAgICAgICB2aXNpYmxlOiBkYXRhLm91dHB1dC52aXNpYmxlLFxuICAgICAgICAgICAgZHVyYXRpb246IGRhdGEub3V0cHV0LmR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhZ2U6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIGNvZGU6IGRhdGEuY29kZSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGRhdGEuc3VjY2Vzc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29tcGxldGVcIixcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgbWVzc2FnZTogIWRhdGEuc3VjY2VzcyA/IGRhdGEub3V0cHV0LmVycm9yIDogdm9pZCAwLFxuICAgICAgICAgIHN0YWdlOiBkYXRhLnN1Y2Nlc3MgPyBcImNvbXBsZXRlXCIgOiBcImVycm9yXCIsXG4gICAgICAgICAgY29kZTogZGF0YS5jb2RlLFxuICAgICAgICAgIHByb2dyZXNzX2RhdGE6IGRhdGEucHJvZ3Jlc3NfZGF0YSxcbiAgICAgICAgICBjaGFuZ2VkX3N0YXRlX2lkczogZGF0YS5zdWNjZXNzID8gZGF0YS5vdXRwdXQuY2hhbmdlZF9zdGF0ZV9pZHMgOiB2b2lkIDBcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YTogZGF0YS5zdWNjZXNzID8gZGF0YS5vdXRwdXQgOiBudWxsXG4gICAgICB9O1xuICAgIGNhc2UgXCJwcm9jZXNzX3N0YXJ0c1wiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgc3RhZ2U6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIGNvZGU6IGRhdGEuY29kZSxcbiAgICAgICAgICBzaXplOiBkYXRhLnJhbmssXG4gICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgc3VjY2VzczogZGF0YS5zdWNjZXNzLFxuICAgICAgICAgIGV0YTogZGF0YS5ldGFcbiAgICAgICAgfSxcbiAgICAgICAgb3JpZ2luYWxfbXNnOiBcInByb2Nlc3Nfc3RhcnRzXCJcbiAgICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJub25lXCIsIHN0YXR1czogeyBzdGFnZTogXCJlcnJvclwiLCBxdWV1ZSB9IH07XG59XG5jb25zdCBtYXBfZGF0YV90b19wYXJhbXMgPSAoZGF0YSA9IFtdLCBlbmRwb2ludF9pbmZvKSA9PiB7XG4gIGNvbnN0IHBhcmFtZXRlcnMgPSBlbmRwb2ludF9pbmZvID8gZW5kcG9pbnRfaW5mby5wYXJhbWV0ZXJzIDogW107XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgaWYgKGVuZHBvaW50X2luZm8gJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwICYmIGRhdGEubGVuZ3RoID4gcGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRvbyBtYW55IGFyZ3VtZW50cyBwcm92aWRlZCBmb3IgdGhlIGVuZHBvaW50LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRfZGF0YSA9IFtdO1xuICBjb25zdCBwcm92aWRlZF9rZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHBhcmFtZXRlcnMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkocGFyYW0ucGFyYW1ldGVyX25hbWUpKSB7XG4gICAgICByZXNvbHZlZF9kYXRhW2luZGV4XSA9IGRhdGFbcGFyYW0ucGFyYW1ldGVyX25hbWVdO1xuICAgIH0gZWxzZSBpZiAocGFyYW0ucGFyYW1ldGVyX2hhc19kZWZhdWx0KSB7XG4gICAgICByZXNvbHZlZF9kYXRhW2luZGV4XSA9IHBhcmFtLnBhcmFtZXRlcl9kZWZhdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyB2YWx1ZSBwcm92aWRlZCBmb3IgcmVxdWlyZWQgcGFyYW1ldGVyOiAke3BhcmFtLnBhcmFtZXRlcl9uYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcHJvdmlkZWRfa2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIXBhcmFtZXRlcnMuc29tZSgocGFyYW0pID0+IHBhcmFtLnBhcmFtZXRlcl9uYW1lID09PSBrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBQYXJhbWV0ZXIgXFxgJHtrZXl9XFxgIGlzIG5vdCBhIHZhbGlkIGtleXdvcmQgYXJndW1lbnQuIFBsZWFzZSByZWZlciB0byB0aGUgQVBJIGZvciB1c2FnZS5gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJlc29sdmVkX2RhdGEuZm9yRWFjaCgodmFsdWUsIGlkeCkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwICYmICFwYXJhbWV0ZXJzW2lkeF0ucGFyYW1ldGVyX2hhc19kZWZhdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBObyB2YWx1ZSBwcm92aWRlZCBmb3IgcmVxdWlyZWQgcGFyYW1ldGVyOiAke3BhcmFtZXRlcnNbaWR4XS5wYXJhbWV0ZXJfbmFtZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNvbHZlZF9kYXRhO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHZpZXdfYXBpKCkge1xuICBpZiAodGhpcy5hcGlfaW5mbylcbiAgICByZXR1cm4gdGhpcy5hcGlfaW5mbztcbiAgY29uc3QgeyBoZl90b2tlbiB9ID0gdGhpcy5vcHRpb25zO1xuICBjb25zdCB7IGNvbmZpZyB9ID0gdGhpcztcbiAgY29uc3QgaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgaWYgKGhmX3Rva2VuKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2hmX3Rva2VufWA7XG4gIH1cbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgbGV0IGFwaV9pbmZvO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5ncmFkaW9fYXBpX2luZm8pIHtcbiAgICAgIGFwaV9pbmZvID0gd2luZG93LmdyYWRpb19hcGlfaW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlbWl2ZXIoKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLnZlcnNpb24pIHx8IFwiMi4wLjBcIiwgXCIzLjMwXCIpIDwgMCkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goU1BBQ0VfRkVUQ0hFUl9VUkwsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWc6IEpTT04uc3RyaW5naWZ5KGNvbmZpZylcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGpvaW5fdXJscyhjb25maWcucm9vdCwgdGhpcy5hcGlfcHJlZml4LCBBUElfSU5GT19VUkwpO1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihCUk9LRU5fQ09OTkVDVElPTl9NU0cpO1xuICAgICAgfVxuICAgICAgYXBpX2luZm8gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGlmIChcImFwaVwiIGluIGFwaV9pbmZvKSB7XG4gICAgICBhcGlfaW5mbyA9IGFwaV9pbmZvLmFwaTtcbiAgICB9XG4gICAgaWYgKGFwaV9pbmZvLm5hbWVkX2VuZHBvaW50c1tcIi9wcmVkaWN0XCJdICYmICFhcGlfaW5mby51bm5hbWVkX2VuZHBvaW50c1tcIjBcIl0pIHtcbiAgICAgIGFwaV9pbmZvLnVubmFtZWRfZW5kcG9pbnRzWzBdID0gYXBpX2luZm8ubmFtZWRfZW5kcG9pbnRzW1wiL3ByZWRpY3RcIl07XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1fYXBpX2luZm8oYXBpX2luZm8sIGNvbmZpZywgdGhpcy5hcGlfbWFwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgQVBJIGluZm8uIFwiICsgZS5tZXNzYWdlKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkX2ZpbGVzKHJvb3RfdXJsLCBmaWxlcywgdXBsb2FkX2lkKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoKF9hID0gdGhpcyA9PSBudWxsID8gdm9pZCAwIDogdGhpcy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGZfdG9rZW4pIHtcbiAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dGhpcy5vcHRpb25zLmhmX3Rva2VufWA7XG4gIH1cbiAgY29uc3QgY2h1bmtTaXplID0gMWUzO1xuICBjb25zdCB1cGxvYWRSZXNwb25zZXMgPSBbXTtcbiAgbGV0IHJlc3BvbnNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICBjb25zdCBjaHVuayA9IGZpbGVzLnNsaWNlKGksIGkgKyBjaHVua1NpemUpO1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgY2h1bmsuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZXNcIiwgZmlsZSk7XG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVwbG9hZF91cmwgPSB1cGxvYWRfaWQgPyBgJHtyb290X3VybH0ke3RoaXMuYXBpX3ByZWZpeH0vJHtVUExPQURfVVJMfT91cGxvYWRfaWQ9JHt1cGxvYWRfaWR9YCA6IGAke3Jvb3RfdXJsfSR7dGhpcy5hcGlfcHJlZml4fS8ke1VQTE9BRF9VUkx9YDtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh1cGxvYWRfdXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCJcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihCUk9LRU5fQ09OTkVDVElPTl9NU0cgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvcl90ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgcmV0dXJuIHsgZXJyb3I6IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvcl90ZXh0fWAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmIChvdXRwdXQpIHtcbiAgICAgIHVwbG9hZFJlc3BvbnNlcy5wdXNoKC4uLm91dHB1dCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGZpbGVzOiB1cGxvYWRSZXNwb25zZXMgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZChmaWxlX2RhdGEsIHJvb3RfdXJsLCB1cGxvYWRfaWQsIG1heF9maWxlX3NpemUpIHtcbiAgbGV0IGZpbGVzID0gKEFycmF5LmlzQXJyYXkoZmlsZV9kYXRhKSA/IGZpbGVfZGF0YSA6IFtmaWxlX2RhdGFdKS5tYXAoXG4gICAgKGZpbGVfZGF0YTIpID0+IGZpbGVfZGF0YTIuYmxvYlxuICApO1xuICBjb25zdCBvdmVyc2l6ZWRfZmlsZXMgPSBmaWxlcy5maWx0ZXIoXG4gICAgKGYpID0+IGYuc2l6ZSA+IChtYXhfZmlsZV9zaXplID8/IEluZmluaXR5KVxuICApO1xuICBpZiAob3ZlcnNpemVkX2ZpbGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBGaWxlIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUgb2YgJHttYXhfZmlsZV9zaXplfSBieXRlczogJHtvdmVyc2l6ZWRfZmlsZXMubWFwKChmKSA9PiBmLm5hbWUpLmpvaW4oXCIsIFwiKX1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgYXdhaXQgdGhpcy51cGxvYWRfZmlsZXMocm9vdF91cmwsIGZpbGVzLCB1cGxvYWRfaWQpLnRoZW4oXG4gICAgICBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzcG9uc2UuZmlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5maWxlcy5tYXAoKGYsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlRGF0YSh7XG4gICAgICAgICAgICAgICAgLi4uZmlsZV9kYXRhW2ldLFxuICAgICAgICAgICAgICAgIHBhdGg6IGYsXG4gICAgICAgICAgICAgICAgdXJsOiBgJHtyb290X3VybH0ke3RoaXMuYXBpX3ByZWZpeH0vZmlsZT0ke2Z9YFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlcGFyZV9maWxlcyhmaWxlcywgaXNfc3RyZWFtKSB7XG4gIHJldHVybiBmaWxlcy5tYXAoXG4gICAgKGYpID0+IG5ldyBGaWxlRGF0YSh7XG4gICAgICBwYXRoOiBmLm5hbWUsXG4gICAgICBvcmlnX25hbWU6IGYubmFtZSxcbiAgICAgIGJsb2I6IGYsXG4gICAgICBzaXplOiBmLnNpemUsXG4gICAgICBtaW1lX3R5cGU6IGYudHlwZSxcbiAgICAgIGlzX3N0cmVhbVxuICAgIH0pXG4gICk7XG59XG5jbGFzcyBGaWxlRGF0YSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXRoLFxuICAgIHVybCxcbiAgICBvcmlnX25hbWUsXG4gICAgc2l6ZSxcbiAgICBibG9iLFxuICAgIGlzX3N0cmVhbSxcbiAgICBtaW1lX3R5cGUsXG4gICAgYWx0X3RleHQsXG4gICAgYjY0XG4gIH0pIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGF0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXJsXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcmlnX25hbWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNpemVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJsb2JcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzX3N0cmVhbVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWltZV90eXBlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhbHRfdGV4dFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYjY0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXRhXCIsIHsgX3R5cGU6IFwiZ3JhZGlvLkZpbGVEYXRhXCIgfSk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLm9yaWdfbmFtZSA9IG9yaWdfbmFtZTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuYmxvYiA9IHVybCA/IHZvaWQgMCA6IGJsb2I7XG4gICAgdGhpcy5pc19zdHJlYW0gPSBpc19zdHJlYW07XG4gICAgdGhpcy5taW1lX3R5cGUgPSBtaW1lX3R5cGU7XG4gICAgdGhpcy5hbHRfdGV4dCA9IGFsdF90ZXh0O1xuICAgIHRoaXMuYjY0ID0gYjY0O1xuICB9XG59XG5jbGFzcyBDb21tYW5kIHtcbiAgY29uc3RydWN0b3IoY29tbWFuZCwgbWV0YSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0eXBlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb21tYW5kXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWxlRGF0YVwiKTtcbiAgICB0aGlzLnR5cGUgPSBcImNvbW1hbmRcIjtcbiAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbn1cbmNvbnN0IGlzX25vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbmZ1bmN0aW9uIHVwZGF0ZV9vYmplY3Qob2JqZWN0LCBuZXdWYWx1ZSwgc3RhY2spIHtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBrZXkyID0gc3RhY2suc2hpZnQoKTtcbiAgICBpZiAodHlwZW9mIGtleTIgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtleTIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtrZXkyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgdHlwZVwiKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qga2V5ID0gc3RhY2suc2hpZnQoKTtcbiAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtleSA9PT0gXCJudW1iZXJcIikge1xuICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgdHlwZVwiKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gd2Fsa19hbmRfc3RvcmVfYmxvYnMoZGF0YSwgdHlwZSA9IHZvaWQgMCwgcGF0aCA9IFtdLCByb290ID0gZmFsc2UsIGVuZHBvaW50X2luZm8gPSB2b2lkIDApIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBsZXQgYmxvYl9yZWZzID0gW107XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBkYXRhLm1hcChhc3luYyAoXywgaW5kZXgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgbmV3X3BhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgIG5ld19wYXRoLnB1c2goU3RyaW5nKGluZGV4KSk7XG4gICAgICAgIGNvbnN0IGFycmF5X3JlZnMgPSBhd2FpdCB3YWxrX2FuZF9zdG9yZV9ibG9icyhcbiAgICAgICAgICBkYXRhW2luZGV4XSxcbiAgICAgICAgICByb290ID8gKChfYSA9IGVuZHBvaW50X2luZm8gPT0gbnVsbCA/IHZvaWQgMCA6IGVuZHBvaW50X2luZm8ucGFyYW1ldGVyc1tpbmRleF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb21wb25lbnQpIHx8IHZvaWQgMCA6IHR5cGUsXG4gICAgICAgICAgbmV3X3BhdGgsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZW5kcG9pbnRfaW5mb1xuICAgICAgICApO1xuICAgICAgICBibG9iX3JlZnMgPSBibG9iX3JlZnMuY29uY2F0KGFycmF5X3JlZnMpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBibG9iX3JlZnM7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgYmxvYjogbmV3IEJsb2IoW2RhdGFdKSxcbiAgICAgICAgdHlwZVxuICAgICAgfVxuICAgIF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCkge1xuICAgIGxldCBibG9iX3JlZnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkYXRhKSkge1xuICAgICAgY29uc3QgbmV3X3BhdGggPSBbLi4ucGF0aCwga2V5XTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgYmxvYl9yZWZzID0gYmxvYl9yZWZzLmNvbmNhdChcbiAgICAgICAgYXdhaXQgd2Fsa19hbmRfc3RvcmVfYmxvYnMoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIG5ld19wYXRoLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGVuZHBvaW50X2luZm9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2JfcmVmcztcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBza2lwX3F1ZXVlKGlkLCBjb25maWcpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IGZuX3F1ZXVlID0gKF9iID0gKF9hID0gY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZGVwZW5kZW5jaWVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmluZCgoZGVwKSA9PiBkZXAuaWQgPT0gaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2IucXVldWU7XG4gIGlmIChmbl9xdWV1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuICFmbl9xdWV1ZTtcbiAgfVxuICByZXR1cm4gIWNvbmZpZy5lbmFibGVfcXVldWU7XG59XG5mdW5jdGlvbiBwb3N0X21lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCBfcmVqKSA9PiB7XG4gICAgY29uc3QgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICBjaGFubmVsLnBvcnQxLmNsb3NlKCk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfTtcbiAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbiwgW2NoYW5uZWwucG9ydDJdKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVfZmlsZShmaWxlX29yX3VybCkge1xuICBpZiAodHlwZW9mIGZpbGVfb3JfdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGZpbGVfb3JfdXJsLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IGZpbGVfb3JfdXJsLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogZmlsZV9vcl91cmwsXG4gICAgICAgIHVybDogZmlsZV9vcl91cmwsXG4gICAgICAgIG9yaWdfbmFtZTogZmlsZV9vcl91cmwuc3BsaXQoXCIvXCIpLnBvcCgpID8/IFwidW5rbm93blwiLFxuICAgICAgICBtZXRhOiB7IF90eXBlOiBcImdyYWRpby5GaWxlRGF0YVwiIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc19ub2RlKSB7XG4gICAgICByZXR1cm4gbmV3IENvbW1hbmQoXCJ1cGxvYWRfZmlsZVwiLCB7XG4gICAgICAgIHBhdGg6IGZpbGVfb3JfdXJsLFxuICAgICAgICBuYW1lOiBmaWxlX29yX3VybCxcbiAgICAgICAgb3JpZ19wYXRoOiBmaWxlX29yX3VybFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVfb3JfdXJsIGluc3RhbmNlb2YgRmlsZSkge1xuICAgIHJldHVybiBuZXcgQmxvYihbZmlsZV9vcl91cmxdKTtcbiAgfSBlbHNlIGlmIChmaWxlX29yX3VybCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgQmxvYihbZmlsZV9vcl91cmxdKTtcbiAgfSBlbHNlIGlmIChmaWxlX29yX3VybCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gZmlsZV9vcl91cmw7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIFwiSW52YWxpZCBpbnB1dDogbXVzdCBiZSBhIFVSTCwgRmlsZSwgQmxvYiwgb3IgQnVmZmVyIG9iamVjdC5cIlxuICApO1xufVxuZnVuY3Rpb24gaGFuZGxlX3BheWxvYWQocmVzb2x2ZWRfcGF5bG9hZCwgZGVwZW5kZW5jeSwgY29tcG9uZW50cywgdHlwZSwgd2l0aF9udWxsX3N0YXRlID0gZmFsc2UpIHtcbiAgaWYgKHR5cGUgPT09IFwiaW5wdXRcIiAmJiAhd2l0aF9udWxsX3N0YXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBhdGguIENhbm5vdCBza2lwIHN0YXRlIGlucHV0cyBmb3IgaW5wdXQuXCIpO1xuICB9XG4gIGlmICh0eXBlID09PSBcIm91dHB1dFwiICYmIHdpdGhfbnVsbF9zdGF0ZSkge1xuICAgIHJldHVybiByZXNvbHZlZF9wYXlsb2FkO1xuICB9XG4gIGxldCB1cGRhdGVkX3BheWxvYWQgPSBbXTtcbiAgbGV0IHBheWxvYWRfaW5kZXggPSAwO1xuICBjb25zdCBkZXBzID0gdHlwZSA9PT0gXCJpbnB1dFwiID8gZGVwZW5kZW5jeS5pbnB1dHMgOiBkZXBlbmRlbmN5Lm91dHB1dHM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGlucHV0X2lkID0gZGVwc1tpXTtcbiAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzLmZpbmQoKGMpID0+IGMuaWQgPT09IGlucHV0X2lkKTtcbiAgICBpZiAoKGNvbXBvbmVudCA9PSBudWxsID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcInN0YXRlXCIpIHtcbiAgICAgIGlmICh3aXRoX251bGxfc3RhdGUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkX3BheWxvYWQubGVuZ3RoID09PSBkZXBzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZWRfcGF5bG9hZFtwYXlsb2FkX2luZGV4XTtcbiAgICAgICAgICB1cGRhdGVkX3BheWxvYWQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgcGF5bG9hZF9pbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZWRfcGF5bG9hZC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXlsb2FkX2luZGV4Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZWRfcGF5bG9hZFtwYXlsb2FkX2luZGV4XTtcbiAgICAgIHVwZGF0ZWRfcGF5bG9hZC5wdXNoKHZhbHVlKTtcbiAgICAgIHBheWxvYWRfaW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZWRfcGF5bG9hZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZV9ibG9iKGVuZHBvaW50LCBkYXRhLCBhcGlfaW5mbykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgYXdhaXQgcHJvY2Vzc19sb2NhbF9maWxlX2NvbW1hbmRzKHNlbGYsIGRhdGEpO1xuICBjb25zdCBibG9iUmVmcyA9IGF3YWl0IHdhbGtfYW5kX3N0b3JlX2Jsb2JzKFxuICAgIGRhdGEsXG4gICAgdm9pZCAwLFxuICAgIFtdLFxuICAgIHRydWUsXG4gICAgYXBpX2luZm9cbiAgKTtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGJsb2JSZWZzLm1hcChhc3luYyAoeyBwYXRoLCBibG9iLCB0eXBlIH0pID0+IHtcbiAgICAgIGlmICghYmxvYilcbiAgICAgICAgcmV0dXJuIHsgcGF0aCwgdHlwZSB9O1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWxmLnVwbG9hZF9maWxlcyhlbmRwb2ludCwgW2Jsb2JdKTtcbiAgICAgIGNvbnN0IGZpbGVfdXJsID0gcmVzcG9uc2UuZmlsZXMgJiYgcmVzcG9uc2UuZmlsZXNbMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBmaWxlX3VybCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbmFtZTogdHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYmxvYiBpbnN0YW5jZW9mIEZpbGUgPyBibG9iID09IG51bGwgPyB2b2lkIDAgOiBibG9iLm5hbWUgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbiAgcmVzdWx0cy5mb3JFYWNoKCh7IHBhdGgsIGZpbGVfdXJsLCB0eXBlLCBuYW1lIH0pID0+IHtcbiAgICBpZiAodHlwZSA9PT0gXCJHYWxsZXJ5XCIpIHtcbiAgICAgIHVwZGF0ZV9vYmplY3QoZGF0YSwgZmlsZV91cmwsIHBhdGgpO1xuICAgIH0gZWxzZSBpZiAoZmlsZV91cmwpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZURhdGEoeyBwYXRoOiBmaWxlX3VybCwgb3JpZ19uYW1lOiBuYW1lIH0pO1xuICAgICAgdXBkYXRlX29iamVjdChkYXRhLCBmaWxlLCBwYXRoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NfbG9jYWxfZmlsZV9jb21tYW5kcyhjbGllbnQyLCBkYXRhKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJvb3QgPSAoKF9hID0gY2xpZW50Mi5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yb290KSB8fCAoKF9iID0gY2xpZW50Mi5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5yb290X3VybCk7XG4gIGlmICghcm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihST09UX1VSTF9FUlJPUl9NU0cpO1xuICB9XG4gIGF3YWl0IHJlY3Vyc2l2ZWx5X3Byb2Nlc3NfY29tbWFuZHMoY2xpZW50MiwgZGF0YSk7XG59XG5hc3luYyBmdW5jdGlvbiByZWN1cnNpdmVseV9wcm9jZXNzX2NvbW1hbmRzKGNsaWVudDIsIGRhdGEsIHBhdGggPSBbXSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGFba2V5XSBpbnN0YW5jZW9mIENvbW1hbmQpIHtcbiAgICAgIGF3YWl0IHByb2Nlc3Nfc2luZ2xlX2NvbW1hbmQoY2xpZW50MiwgZGF0YSwga2V5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhW2tleV0gPT09IFwib2JqZWN0XCIgJiYgZGF0YVtrZXldICE9PSBudWxsKSB7XG4gICAgICBhd2FpdCByZWN1cnNpdmVseV9wcm9jZXNzX2NvbW1hbmRzKGNsaWVudDIsIGRhdGFba2V5XSwgWy4uLnBhdGgsIGtleV0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc19zaW5nbGVfY29tbWFuZChjbGllbnQyLCBkYXRhLCBrZXkpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IGNtZF9pdGVtID0gZGF0YVtrZXldO1xuICBjb25zdCByb290ID0gKChfYSA9IGNsaWVudDIuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2Eucm9vdCkgfHwgKChfYiA9IGNsaWVudDIuY29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2Iucm9vdF91cmwpO1xuICBpZiAoIXJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoUk9PVF9VUkxfRVJST1JfTVNHKTtcbiAgfVxuICB0cnkge1xuICAgIGxldCBmaWxlQnVmZmVyO1xuICAgIGxldCBmdWxsUGF0aDtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUpIHtcbiAgICAgIGNvbnN0IGZzID0gYXdhaXQgaW1wb3J0KFwiZnMvcHJvbWlzZXNcIik7XG4gICAgICBjb25zdCBwYXRoID0gYXdhaXQgaW1wb3J0KFwicGF0aFwiKTtcbiAgICAgIGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIGNtZF9pdGVtLm1ldGEucGF0aCk7XG4gICAgICBmaWxlQnVmZmVyID0gYXdhaXQgZnMucmVhZEZpbGUoZnVsbFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTk9ERUpTX0ZTX0VSUk9SX01TRyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYihbZmlsZUJ1ZmZlcl0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudDIudXBsb2FkX2ZpbGVzKHJvb3QsIFtmaWxlXSk7XG4gICAgY29uc3QgZmlsZV91cmwgPSByZXNwb25zZS5maWxlcyAmJiByZXNwb25zZS5maWxlc1swXTtcbiAgICBpZiAoZmlsZV91cmwpIHtcbiAgICAgIGNvbnN0IGZpbGVEYXRhID0gbmV3IEZpbGVEYXRhKHtcbiAgICAgICAgcGF0aDogZmlsZV91cmwsXG4gICAgICAgIG9yaWdfbmFtZTogY21kX2l0ZW0ubWV0YS5uYW1lIHx8IFwiXCJcbiAgICAgIH0pO1xuICAgICAgZGF0YVtrZXldID0gZmlsZURhdGE7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoRklMRV9QUk9DRVNTSU5HX0VSUk9SX01TRywgZXJyb3IpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBwb3N0X2RhdGEodXJsLCBib2R5LCBhZGRpdGlvbmFsX2hlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgaWYgKHRoaXMub3B0aW9ucy5oZl90b2tlbikge1xuICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0aGlzLm9wdGlvbnMuaGZfdG9rZW59YDtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICBoZWFkZXJzOiB7IC4uLmhlYWRlcnMsIC4uLmFkZGl0aW9uYWxfaGVhZGVycyB9LFxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW3sgZXJyb3I6IEJST0tFTl9DT05ORUNUSU9OX01TRyB9LCA1MDBdO1xuICB9XG4gIGxldCBvdXRwdXQ7XG4gIGxldCBzdGF0dXM7XG4gIHRyeSB7XG4gICAgb3V0cHV0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgfSBjYXRjaCAoZSkge1xuICAgIG91dHB1dCA9IHsgZXJyb3I6IGBDb3VsZCBub3QgcGFyc2Ugc2VydmVyIHJlc3BvbnNlOiAke2V9YCB9O1xuICAgIHN0YXR1cyA9IDUwMDtcbiAgfVxuICByZXR1cm4gW291dHB1dCwgc3RhdHVzXTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWRpY3QoZW5kcG9pbnQsIGRhdGEgPSB7fSkge1xuICBsZXQgZGF0YV9yZXR1cm5lZCA9IGZhbHNlO1xuICBsZXQgc3RhdHVzX2NvbXBsZXRlID0gZmFsc2U7XG4gIGlmICghdGhpcy5jb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBhcHAgY29uZmlnXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5kcG9pbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICB0aGlzLmNvbmZpZy5kZXBlbmRlbmNpZXMuZmluZCgoZGVwKSA9PiBkZXAuaWQgPT0gZW5kcG9pbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRyaW1tZWRfZW5kcG9pbnQgPSBlbmRwb2ludC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgdGhpcy5jb25maWcuZGVwZW5kZW5jaWVzLmZpbmQoXG4gICAgICAoZGVwKSA9PiBkZXAuaWQgPT0gdGhpcy5hcGlfbWFwW3RyaW1tZWRfZW5kcG9pbnRdXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGFwcCA9IHRoaXMuc3VibWl0KGVuZHBvaW50LCBkYXRhLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGZvciBhd2FpdCAoY29uc3QgbWVzc2FnZSBvZiBhcHApIHtcbiAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgIGlmIChzdGF0dXNfY29tcGxldGUpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YV9yZXR1cm5lZCA9IHRydWU7XG4gICAgICAgIHJlc3VsdCA9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcInN0YXR1c1wiKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YWdlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgICBpZiAobWVzc2FnZS5zdGFnZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgc3RhdHVzX2NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZGF0YV9yZXR1cm5lZCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja19zcGFjZV9zdGF0dXMoaWQsIHR5cGUsIHN0YXR1c19jYWxsYmFjaykge1xuICBsZXQgZW5kcG9pbnQgPSB0eXBlID09PSBcInN1YmRvbWFpblwiID8gYGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYXBpL3NwYWNlcy9ieS1zdWJkb21haW4vJHtpZH1gIDogYGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYXBpL3NwYWNlcy8ke2lkfWA7XG4gIGxldCByZXNwb25zZTtcbiAgbGV0IF9zdGF0dXM7XG4gIHRyeSB7XG4gICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCk7XG4gICAgX3N0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBpZiAoX3N0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgcmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzdGF0dXNfY2FsbGJhY2soe1xuICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICBsb2FkX3N0YXR1czogXCJlcnJvclwiLFxuICAgICAgbWVzc2FnZTogU1BBQ0VfU1RBVFVTX0VSUk9SX01TRyxcbiAgICAgIGRldGFpbDogXCJOT1RfRk9VTkRcIlxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXJlc3BvbnNlIHx8IF9zdGF0dXMgIT09IDIwMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHtcbiAgICBydW50aW1lOiB7IHN0YWdlIH0sXG4gICAgaWQ6IHNwYWNlX25hbWVcbiAgfSA9IHJlc3BvbnNlO1xuICBzd2l0Y2ggKHN0YWdlKSB7XG4gICAgY2FzZSBcIlNUT1BQRURcIjpcbiAgICBjYXNlIFwiU0xFRVBJTkdcIjpcbiAgICAgIHN0YXR1c19jYWxsYmFjayh7XG4gICAgICAgIHN0YXR1czogXCJzbGVlcGluZ1wiLFxuICAgICAgICBsb2FkX3N0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiU3BhY2UgaXMgYXNsZWVwLiBXYWtpbmcgaXQgdXAuLi5cIixcbiAgICAgICAgZGV0YWlsOiBzdGFnZVxuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2hlY2tfc3BhY2Vfc3RhdHVzKGlkLCB0eXBlLCBzdGF0dXNfY2FsbGJhY2spO1xuICAgICAgfSwgMWUzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQQVVTRURcIjpcbiAgICAgIHN0YXR1c19jYWxsYmFjayh7XG4gICAgICAgIHN0YXR1czogXCJwYXVzZWRcIixcbiAgICAgICAgbG9hZF9zdGF0dXM6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogXCJUaGlzIHNwYWNlIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgYXV0aG9yLiBJZiB5b3Ugd291bGQgbGlrZSB0byB0cnkgdGhpcyBkZW1vLCBjb25zaWRlciBkdXBsaWNhdGluZyB0aGUgc3BhY2UuXCIsXG4gICAgICAgIGRldGFpbDogc3RhZ2UsXG4gICAgICAgIGRpc2N1c3Npb25zX2VuYWJsZWQ6IGF3YWl0IGRpc2N1c3Npb25zX2VuYWJsZWQoc3BhY2VfbmFtZSlcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlJVTk5JTkdcIjpcbiAgICBjYXNlIFwiUlVOTklOR19CVUlMRElOR1wiOlxuICAgICAgc3RhdHVzX2NhbGxiYWNrKHtcbiAgICAgICAgc3RhdHVzOiBcInJ1bm5pbmdcIixcbiAgICAgICAgbG9hZF9zdGF0dXM6IFwiY29tcGxldGVcIixcbiAgICAgICAgbWVzc2FnZTogXCJTcGFjZSBpcyBydW5uaW5nLlwiLFxuICAgICAgICBkZXRhaWw6IHN0YWdlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJCVUlMRElOR1wiOlxuICAgICAgc3RhdHVzX2NhbGxiYWNrKHtcbiAgICAgICAgc3RhdHVzOiBcImJ1aWxkaW5nXCIsXG4gICAgICAgIGxvYWRfc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgbWVzc2FnZTogXCJTcGFjZSBpcyBidWlsZGluZy4uLlwiLFxuICAgICAgICBkZXRhaWw6IHN0YWdlXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjaGVja19zcGFjZV9zdGF0dXMoaWQsIHR5cGUsIHN0YXR1c19jYWxsYmFjayk7XG4gICAgICB9LCAxZTMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkFQUF9TVEFSVElOR1wiOlxuICAgICAgc3RhdHVzX2NhbGxiYWNrKHtcbiAgICAgICAgc3RhdHVzOiBcInN0YXJ0aW5nXCIsXG4gICAgICAgIGxvYWRfc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgbWVzc2FnZTogXCJTcGFjZSBpcyBzdGFydGluZy4uLlwiLFxuICAgICAgICBkZXRhaWw6IHN0YWdlXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjaGVja19zcGFjZV9zdGF0dXMoaWQsIHR5cGUsIHN0YXR1c19jYWxsYmFjayk7XG4gICAgICB9LCAxZTMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXR1c19jYWxsYmFjayh7XG4gICAgICAgIHN0YXR1czogXCJzcGFjZV9lcnJvclwiLFxuICAgICAgICBsb2FkX3N0YXR1czogXCJlcnJvclwiLFxuICAgICAgICBtZXNzYWdlOiBcIlRoaXMgc3BhY2UgaXMgZXhwZXJpZW5jaW5nIGFuIGlzc3VlLlwiLFxuICAgICAgICBkZXRhaWw6IHN0YWdlLFxuICAgICAgICBkaXNjdXNzaW9uc19lbmFibGVkOiBhd2FpdCBkaXNjdXNzaW9uc19lbmFibGVkKHNwYWNlX25hbWUpXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5jb25zdCBjaGVja19hbmRfd2FrZV9zcGFjZSA9IGFzeW5jIChzcGFjZV9pZCwgc3RhdHVzX2NhbGxiYWNrKSA9PiB7XG4gIGxldCByZXRyaWVzID0gMDtcbiAgY29uc3QgbWF4X3JldHJpZXMgPSAxMjtcbiAgY29uc3QgY2hlY2tfaW50ZXJ2YWwgPSA1ZTM7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNoZWNrX3NwYWNlX3N0YXR1cyhcbiAgICAgIHNwYWNlX2lkLFxuICAgICAgUkVfU1BBQ0VfTkFNRS50ZXN0KHNwYWNlX2lkKSA/IFwic3BhY2VfbmFtZVwiIDogXCJzdWJkb21haW5cIixcbiAgICAgIChzdGF0dXMpID0+IHtcbiAgICAgICAgc3RhdHVzX2NhbGxiYWNrKHN0YXR1cyk7XG4gICAgICAgIGlmIChzdGF0dXMuc3RhdHVzID09PSBcInJ1bm5pbmdcIikge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMuc3RhdHVzID09PSBcImVycm9yXCIgfHwgc3RhdHVzLnN0YXR1cyA9PT0gXCJwYXVzZWRcIiB8fCBzdGF0dXMuc3RhdHVzID09PSBcInNwYWNlX2Vycm9yXCIpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzLnN0YXR1cyA9PT0gXCJzbGVlcGluZ1wiIHx8IHN0YXR1cy5zdGF0dXMgPT09IFwiYnVpbGRpbmdcIikge1xuICAgICAgICAgIGlmIChyZXRyaWVzIDwgbWF4X3JldHJpZXMpIHtcbiAgICAgICAgICAgIHJldHJpZXMrKztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjaGVja19hbmRfd2FrZV9zcGFjZShzcGFjZV9pZCwgc3RhdHVzX2NhbGxiYWNrKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfSwgY2hlY2tfaW50ZXJ2YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59O1xuY29uc3QgUkVfRElTQUJMRURfRElTQ1VTU0lPTiA9IC9eKD89W15dKlxcYltkRF1pc2N1c3Npb25zezAsMX1cXGIpKD89W15dKlxcYltkRF1pc2FibGVkXFxiKVteXSokLztcbmFzeW5jIGZ1bmN0aW9uIGRpc2N1c3Npb25zX2VuYWJsZWQoc3BhY2VfaWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvc3BhY2VzLyR7c3BhY2VfaWR9L2Rpc2N1c3Npb25zYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIlxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZXJyb3IgPSByLmhlYWRlcnMuZ2V0KFwieC1lcnJvci1tZXNzYWdlXCIpO1xuICAgIGlmICghci5vayB8fCBlcnJvciAmJiBSRV9ESVNBQkxFRF9ESVNDVVNTSU9OLnRlc3QoZXJyb3IpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRfc3BhY2VfaGFyZHdhcmUoc3BhY2VfaWQsIGhmX3Rva2VuKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGhmX3Rva2VuKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2hmX3Rva2VufWA7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS9zcGFjZXMvJHtzcGFjZV9pZH0vJHtSVU5USU1FX1VSTH1gLFxuICAgICAgeyBoZWFkZXJzIH1cbiAgICApO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGFjZSBoYXJkd2FyZSBjb3VsZCBub3QgYmUgb2J0YWluZWQuXCIpO1xuICAgIGNvbnN0IHsgaGFyZHdhcmUgfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGhhcmR3YXJlLmN1cnJlbnQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2V0X3NwYWNlX3RpbWVvdXQoc3BhY2VfaWQsIHRpbWVvdXQsIGhmX3Rva2VuKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaWYgKGhmX3Rva2VuKSB7XG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2hmX3Rva2VufWA7XG4gIH1cbiAgY29uc3QgYm9keSA9IHtcbiAgICBzZWNvbmRzOiB0aW1lb3V0XG4gIH07XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvc3BhY2VzLyR7c3BhY2VfaWR9LyR7U0xFRVBUSU1FX1VSTH1gLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ291bGQgbm90IHNldCBzbGVlcCB0aW1lb3V0IG9uIGR1cGxpY2F0ZWQgU3BhY2UuIFBsZWFzZSB2aXNpdCAqQUREIEhGIExJTksgVE8gU0VUVElOR1MqIHRvIHNldCBhIHRpbWVvdXQgbWFudWFsbHkgdG8gcmVkdWNlIGJpbGxpbmcgY2hhcmdlcy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICB9XG59XG5jb25zdCBoYXJkd2FyZV90eXBlcyA9IFtcbiAgXCJjcHUtYmFzaWNcIixcbiAgXCJjcHUtdXBncmFkZVwiLFxuICBcImNwdS14bFwiLFxuICBcInQ0LXNtYWxsXCIsXG4gIFwidDQtbWVkaXVtXCIsXG4gIFwiYTEwZy1zbWFsbFwiLFxuICBcImExMGctbGFyZ2VcIixcbiAgXCJhMTBnLWxhcmdleDJcIixcbiAgXCJhMTBnLWxhcmdleDRcIixcbiAgXCJhMTAwLWxhcmdlXCIsXG4gIFwiemVyby1hMTBnXCIsXG4gIFwiaDEwMFwiLFxuICBcImgxMDB4OFwiXG5dO1xuYXN5bmMgZnVuY3Rpb24gZHVwbGljYXRlKGFwcF9yZWZlcmVuY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBoZl90b2tlbiwgcHJpdmF0ZTogX3ByaXZhdGUsIGhhcmR3YXJlLCB0aW1lb3V0LCBhdXRoIH0gPSBvcHRpb25zO1xuICBpZiAoaGFyZHdhcmUgJiYgIWhhcmR3YXJlX3R5cGVzLmluY2x1ZGVzKGhhcmR3YXJlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGhhcmR3YXJlIHR5cGUgcHJvdmlkZWQuIFZhbGlkIHR5cGVzIGFyZTogJHtoYXJkd2FyZV90eXBlcy5tYXAoKHYpID0+IGBcIiR7dn1cImApLmpvaW4oXCIsXCIpfS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCB7IGh0dHBfcHJvdG9jb2wsIGhvc3QgfSA9IGF3YWl0IHByb2Nlc3NfZW5kcG9pbnQoXG4gICAgYXBwX3JlZmVyZW5jZSxcbiAgICBoZl90b2tlblxuICApO1xuICBsZXQgY29va2llcyA9IG51bGw7XG4gIGlmIChhdXRoKSB7XG4gICAgY29uc3QgY29va2llX2hlYWRlciA9IGF3YWl0IGdldF9jb29raWVfaGVhZGVyKFxuICAgICAgaHR0cF9wcm90b2NvbCxcbiAgICAgIGhvc3QsXG4gICAgICBhdXRoLFxuICAgICAgZmV0Y2hcbiAgICApO1xuICAgIGlmIChjb29raWVfaGVhZGVyKVxuICAgICAgY29va2llcyA9IHBhcnNlX2FuZF9zZXRfY29va2llcyhjb29raWVfaGVhZGVyKTtcbiAgfVxuICBjb25zdCBoZWFkZXJzID0ge1xuICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtoZl90b2tlbn1gLFxuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIC4uLmNvb2tpZXMgPyB7IENvb2tpZTogY29va2llcy5qb2luKFwiOyBcIikgfSA6IHt9XG4gIH07XG4gIGNvbnN0IHVzZXIgPSAoYXdhaXQgKGF3YWl0IGZldGNoKGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS93aG9hbWktdjJgLCB7XG4gICAgaGVhZGVyc1xuICB9KSkuanNvbigpKS5uYW1lO1xuICBjb25zdCBzcGFjZV9uYW1lID0gYXBwX3JlZmVyZW5jZS5zcGxpdChcIi9cIilbMV07XG4gIGNvbnN0IGJvZHkgPSB7XG4gICAgcmVwb3NpdG9yeTogYCR7dXNlcn0vJHtzcGFjZV9uYW1lfWBcbiAgfTtcbiAgaWYgKF9wcml2YXRlKSB7XG4gICAgYm9keS5wcml2YXRlID0gdHJ1ZTtcbiAgfVxuICBsZXQgb3JpZ2luYWxfaGFyZHdhcmU7XG4gIHRyeSB7XG4gICAgaWYgKCFoYXJkd2FyZSkge1xuICAgICAgb3JpZ2luYWxfaGFyZHdhcmUgPSBhd2FpdCBnZXRfc3BhY2VfaGFyZHdhcmUoYXBwX3JlZmVyZW5jZSwgaGZfdG9rZW4pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IEVycm9yKFNQQUNFX01FVEFEQVRBX0VSUk9SX01TRyArIGUubWVzc2FnZSk7XG4gIH1cbiAgY29uc3QgcmVxdWVzdGVkX2hhcmR3YXJlID0gaGFyZHdhcmUgfHwgb3JpZ2luYWxfaGFyZHdhcmUgfHwgXCJjcHUtYmFzaWNcIjtcbiAgYm9keS5oYXJkd2FyZSA9IHJlcXVlc3RlZF9oYXJkd2FyZTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYXBpL3NwYWNlcy8ke2FwcF9yZWZlcmVuY2V9L2R1cGxpY2F0ZWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNsaWVudDIgPSBhd2FpdCBDbGllbnQuY29ubmVjdChgJHt1c2VyfS8ke3NwYWNlX25hbWV9YCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBjbGllbnQyO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IENsaWVudCBpbnN0YW5jZTpcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGR1cGxpY2F0ZWRfc3BhY2UgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgYXdhaXQgc2V0X3NwYWNlX3RpbWVvdXQoYCR7dXNlcn0vJHtzcGFjZV9uYW1lfWAsIHRpbWVvdXQgfHwgMzAwLCBoZl90b2tlbik7XG4gICAgcmV0dXJuIGF3YWl0IENsaWVudC5jb25uZWN0KFxuICAgICAgZ2V0X3NwYWNlX3JlZmVyZW5jZShkdXBsaWNhdGVkX3NwYWNlLnVybCksXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0X3NwYWNlX3JlZmVyZW5jZSh1cmwpIHtcbiAgY29uc3QgcmVnZXggPSAvaHR0cHM6XFwvXFwvaHVnZ2luZ2ZhY2UuY29cXC9zcGFjZXNcXC8oW14vXStcXC9bXi9dKykvO1xuICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZWdleCk7XG4gIGlmIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxufVxuY2xhc3MgVGV4dExpbmVTdHJlYW0gZXh0ZW5kcyBUcmFuc2Zvcm1TdHJlYW0ge1xuICAvKiogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZS4gKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHsgYWxsb3dDUjogZmFsc2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHRyYW5zZm9ybTogKGNoYXJzLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNoYXJzID0gX19wcml2YXRlR2V0KHRoaXMsIF9jdXJyZW50TGluZSkgKyBjaGFycztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBsZkluZGV4ID0gY2hhcnMuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICBjb25zdCBjckluZGV4ID0gb3B0aW9ucy5hbGxvd0NSID8gY2hhcnMuaW5kZXhPZihcIlxcclwiKSA6IC0xO1xuICAgICAgICAgIGlmIChjckluZGV4ICE9PSAtMSAmJiBjckluZGV4ICE9PSBjaGFycy5sZW5ndGggLSAxICYmIChsZkluZGV4ID09PSAtMSB8fCBsZkluZGV4IC0gMSA+IGNySW5kZXgpKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2hhcnMuc2xpY2UoMCwgY3JJbmRleCkpO1xuICAgICAgICAgICAgY2hhcnMgPSBjaGFycy5zbGljZShjckluZGV4ICsgMSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxmSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBjaGFyc1tsZkluZGV4IC0gMV0gPT09IFwiXFxyXCIgPyBsZkluZGV4IC0gMSA6IGxmSW5kZXg7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNoYXJzLnNsaWNlKDAsIGVuZEluZGV4KSk7XG4gICAgICAgICAgY2hhcnMgPSBjaGFycy5zbGljZShsZkluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jdXJyZW50TGluZSwgY2hhcnMpO1xuICAgICAgfSxcbiAgICAgIGZsdXNoOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9jdXJyZW50TGluZSkgPT09IFwiXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50TGluZSA9IG9wdGlvbnMuYWxsb3dDUiAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2N1cnJlbnRMaW5lKS5lbmRzV2l0aChcIlxcclwiKSA/IF9fcHJpdmF0ZUdldCh0aGlzLCBfY3VycmVudExpbmUpLnNsaWNlKDAsIC0xKSA6IF9fcHJpdmF0ZUdldCh0aGlzLCBfY3VycmVudExpbmUpO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY3VycmVudExpbmUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY3VycmVudExpbmUsIFwiXCIpO1xuICB9XG59XG5fY3VycmVudExpbmUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc3RyZWFtJDEoaW5wdXQpIHtcbiAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXJTdHJlYW0oKTtcbiAgbGV0IHNwbGl0MiA9IG5ldyBUZXh0TGluZVN0cmVhbSh7IGFsbG93Q1I6IHRydWUgfSk7XG4gIHJldHVybiBpbnB1dC5waXBlVGhyb3VnaChkZWNvZGVyKS5waXBlVGhyb3VnaChzcGxpdDIpO1xufVxuZnVuY3Rpb24gc3BsaXQoaW5wdXQpIHtcbiAgbGV0IHJneCA9IC9bOl1cXHMqLztcbiAgbGV0IG1hdGNoID0gcmd4LmV4ZWMoaW5wdXQpO1xuICBsZXQgaWR4ID0gbWF0Y2ggJiYgbWF0Y2guaW5kZXg7XG4gIGlmIChpZHgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgaW5wdXQuc3Vic3RyaW5nKDAsIGlkeCksXG4gICAgICBpbnB1dC5zdWJzdHJpbmcoaWR4ICsgbWF0Y2hbMF0ubGVuZ3RoKVxuICAgIF07XG4gIH1cbn1cbmZ1bmN0aW9uIGZhbGxiYWNrKGhlYWRlcnMsIGtleSwgdmFsdWUpIHtcbiAgbGV0IHRtcCA9IGhlYWRlcnMuZ2V0KGtleSk7XG4gIGlmICghdG1wKVxuICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xufVxuYXN5bmMgZnVuY3Rpb24qIGV2ZW50cyhyZXMsIHNpZ25hbCkge1xuICBpZiAoIXJlcy5ib2R5KVxuICAgIHJldHVybjtcbiAgbGV0IGl0ZXIgPSBzdHJlYW0kMShyZXMuYm9keSk7XG4gIGxldCBsaW5lLCByZWFkZXIgPSBpdGVyLmdldFJlYWRlcigpO1xuICBsZXQgZXZlbnQ7XG4gIGZvciAoOyA7ICkge1xuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiByZWFkZXIuY2FuY2VsKCk7XG4gICAgfVxuICAgIGxpbmUgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChsaW5lLmRvbmUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCFsaW5lLnZhbHVlKSB7XG4gICAgICBpZiAoZXZlbnQpXG4gICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgZXZlbnQgPSB2b2lkIDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IFtmaWVsZCwgdmFsdWVdID0gc3BsaXQobGluZS52YWx1ZSkgfHwgW107XG4gICAgaWYgKCFmaWVsZClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChmaWVsZCA9PT0gXCJkYXRhXCIpIHtcbiAgICAgIGV2ZW50IHx8IChldmVudCA9IHt9KTtcbiAgICAgIGV2ZW50W2ZpZWxkXSA9IGV2ZW50W2ZpZWxkXSA/IGV2ZW50W2ZpZWxkXSArIFwiXFxuXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZmllbGQgPT09IFwiZXZlbnRcIikge1xuICAgICAgZXZlbnQgfHwgKGV2ZW50ID0ge30pO1xuICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gXCJpZFwiKSB7XG4gICAgICBldmVudCB8fCAoZXZlbnQgPSB7fSk7XG4gICAgICBldmVudFtmaWVsZF0gPSArdmFsdWUgfHwgdmFsdWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gXCJyZXRyeVwiKSB7XG4gICAgICBldmVudCB8fCAoZXZlbnQgPSB7fSk7XG4gICAgICBldmVudFtmaWVsZF0gPSArdmFsdWUgfHwgdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtKGlucHV0LCBpbml0KSB7XG4gIGxldCByZXEgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG4gIGZhbGxiYWNrKHJlcS5oZWFkZXJzLCBcIkFjY2VwdFwiLCBcInRleHQvZXZlbnQtc3RyZWFtXCIpO1xuICBmYWxsYmFjayhyZXEuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICBsZXQgciA9IGF3YWl0IGZldGNoKHJlcSk7XG4gIGlmICghci5vaylcbiAgICB0aHJvdyByO1xuICByZXR1cm4gZXZlbnRzKHIsIHJlcS5zaWduYWwpO1xufVxuYXN5bmMgZnVuY3Rpb24gb3Blbl9zdHJlYW0oKSB7XG4gIGxldCB7XG4gICAgZXZlbnRfY2FsbGJhY2tzLFxuICAgIHVuY2xvc2VkX2V2ZW50cyxcbiAgICBwZW5kaW5nX3N0cmVhbV9tZXNzYWdlcyxcbiAgICBzdHJlYW1fc3RhdHVzLFxuICAgIGNvbmZpZyxcbiAgICBqd3RcbiAgfSA9IHRoaXM7XG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICBpZiAoIWNvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGFwcCBjb25maWdcIik7XG4gIH1cbiAgc3RyZWFtX3N0YXR1cy5vcGVuID0gdHJ1ZTtcbiAgbGV0IHN0cmVhbTIgPSBudWxsO1xuICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgc2Vzc2lvbl9oYXNoOiB0aGlzLnNlc3Npb25faGFzaFxuICB9KS50b1N0cmluZygpO1xuICBsZXQgdXJsID0gbmV3IFVSTChgJHtjb25maWcucm9vdH0ke3RoaXMuYXBpX3ByZWZpeH0vJHtTU0VfVVJMfT8ke3BhcmFtc31gKTtcbiAgaWYgKGp3dCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiX19zaWduXCIsIGp3dCk7XG4gIH1cbiAgc3RyZWFtMiA9IHRoaXMuc3RyZWFtKHVybCk7XG4gIGlmICghc3RyZWFtMikge1xuICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBjb25uZWN0IHRvIFNTRSBlbmRwb2ludDogXCIgKyB1cmwudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0cmVhbTIub25tZXNzYWdlID0gYXN5bmMgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBsZXQgX2RhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgIGlmIChfZGF0YS5tc2cgPT09IFwiY2xvc2Vfc3RyZWFtXCIpIHtcbiAgICAgIGNsb3NlX3N0cmVhbShzdHJlYW1fc3RhdHVzLCB0aGF0LmFib3J0X2NvbnRyb2xsZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBldmVudF9pZCA9IF9kYXRhLmV2ZW50X2lkO1xuICAgIGlmICghZXZlbnRfaWQpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBPYmplY3Qua2V5cyhldmVudF9jYWxsYmFja3MpLm1hcChcbiAgICAgICAgICAoZXZlbnRfaWQyKSA9PiBldmVudF9jYWxsYmFja3NbZXZlbnRfaWQyXShfZGF0YSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50X2NhbGxiYWNrc1tldmVudF9pZF0gJiYgY29uZmlnKSB7XG4gICAgICBpZiAoX2RhdGEubXNnID09PSBcInByb2Nlc3NfY29tcGxldGVkXCIgJiYgW1wic3NlXCIsIFwic3NlX3YxXCIsIFwic3NlX3YyXCIsIFwic3NlX3YyLjFcIiwgXCJzc2VfdjNcIl0uaW5jbHVkZXMoXG4gICAgICAgIGNvbmZpZy5wcm90b2NvbFxuICAgICAgKSkge1xuICAgICAgICB1bmNsb3NlZF9ldmVudHMuZGVsZXRlKGV2ZW50X2lkKTtcbiAgICAgIH1cbiAgICAgIGxldCBmbjIgPSBldmVudF9jYWxsYmFja3NbZXZlbnRfaWRdO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4yLCAwLCBfZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbjIoX2RhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXBlbmRpbmdfc3RyZWFtX21lc3NhZ2VzW2V2ZW50X2lkXSkge1xuICAgICAgICBwZW5kaW5nX3N0cmVhbV9tZXNzYWdlc1tldmVudF9pZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdfc3RyZWFtX21lc3NhZ2VzW2V2ZW50X2lkXS5wdXNoKF9kYXRhKTtcbiAgICB9XG4gIH07XG4gIHN0cmVhbTIub25lcnJvciA9IGFzeW5jIGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmtleXMoZXZlbnRfY2FsbGJhY2tzKS5tYXAoXG4gICAgICAgIChldmVudF9pZCkgPT4gZXZlbnRfY2FsbGJhY2tzW2V2ZW50X2lkXSh7XG4gICAgICAgICAgbXNnOiBcImJyb2tlbl9jb25uZWN0aW9uXCIsXG4gICAgICAgICAgbWVzc2FnZTogQlJPS0VOX0NPTk5FQ1RJT05fTVNHXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb3NlX3N0cmVhbShzdHJlYW1fc3RhdHVzLCBhYm9ydF9jb250cm9sbGVyKSB7XG4gIGlmIChzdHJlYW1fc3RhdHVzKSB7XG4gICAgc3RyZWFtX3N0YXR1cy5vcGVuID0gZmFsc2U7XG4gICAgYWJvcnRfY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRfY29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5mdW5jdGlvbiBhcHBseV9kaWZmX3N0cmVhbShwZW5kaW5nX2RpZmZfc3RyZWFtcywgZXZlbnRfaWQsIGRhdGEpIHtcbiAgbGV0IGlzX2ZpcnN0X2dlbmVyYXRpb24gPSAhcGVuZGluZ19kaWZmX3N0cmVhbXNbZXZlbnRfaWRdO1xuICBpZiAoaXNfZmlyc3RfZ2VuZXJhdGlvbikge1xuICAgIHBlbmRpbmdfZGlmZl9zdHJlYW1zW2V2ZW50X2lkXSA9IFtdO1xuICAgIGRhdGEuZGF0YS5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgcGVuZGluZ19kaWZmX3N0cmVhbXNbZXZlbnRfaWRdW2ldID0gdmFsdWU7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5kYXRhLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICBsZXQgbmV3X2RhdGEgPSBhcHBseV9kaWZmKHBlbmRpbmdfZGlmZl9zdHJlYW1zW2V2ZW50X2lkXVtpXSwgdmFsdWUpO1xuICAgICAgcGVuZGluZ19kaWZmX3N0cmVhbXNbZXZlbnRfaWRdW2ldID0gbmV3X2RhdGE7XG4gICAgICBkYXRhLmRhdGFbaV0gPSBuZXdfZGF0YTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlfZGlmZihvYmosIGRpZmYpIHtcbiAgZGlmZi5mb3JFYWNoKChbYWN0aW9uLCBwYXRoLCB2YWx1ZV0pID0+IHtcbiAgICBvYmogPSBhcHBseV9lZGl0KG9iaiwgcGF0aCwgYWN0aW9uLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gYXBwbHlfZWRpdCh0YXJnZXQsIHBhdGgsIGFjdGlvbiwgdmFsdWUpIHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGFjdGlvbiA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJhcHBlbmRcIikge1xuICAgICAgcmV0dXJuIHRhcmdldCArIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGlvbjogJHthY3Rpb259YCk7XG4gIH1cbiAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoW2ldXTtcbiAgfVxuICBjb25zdCBsYXN0X3BhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgY2FzZSBcInJlcGxhY2VcIjpcbiAgICAgIGN1cnJlbnRbbGFzdF9wYXRoXSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFwcGVuZFwiOlxuICAgICAgY3VycmVudFtsYXN0X3BhdGhdICs9IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFkZFwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoTnVtYmVyKGxhc3RfcGF0aCksIDAsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRbbGFzdF9wYXRoXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoTnVtYmVyKGxhc3RfcGF0aCksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGN1cnJlbnRbbGFzdF9wYXRoXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0aW9uOiAke2FjdGlvbn1gKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gcmVhZGFibGVfc3RyZWFtKGlucHV0LCBpbml0ID0ge30pIHtcbiAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgY2xvc2U6ICgpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH0sXG4gICAgb25lcnJvcjogbnVsbCxcbiAgICBvbm1lc3NhZ2U6IG51bGwsXG4gICAgb25vcGVuOiBudWxsLFxuICAgIHJlYWR5U3RhdGU6IDAsXG4gICAgdXJsOiBpbnB1dC50b1N0cmluZygpLFxuICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgQ09OTkVDVElORzogMCxcbiAgICBPUEVOOiAxLFxuICAgIENMT1NFRDogMixcbiAgICBhZGRFdmVudExpc3RlbmVyOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXZlbnQ6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH0sXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxuICB9O1xuICBzdHJlYW0oaW5wdXQsIGluaXQpLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgIGluc3RhbmNlLnJlYWR5U3RhdGUgPSBpbnN0YW5jZS5PUEVOO1xuICAgIHRyeSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlcykge1xuICAgICAgICBpbnN0YW5jZS5vbm1lc3NhZ2UgJiYgaW5zdGFuY2Uub25tZXNzYWdlKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLnJlYWR5U3RhdGUgPSBpbnN0YW5jZS5DTE9TRUQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaW5zdGFuY2Uub25lcnJvciAmJiBpbnN0YW5jZS5vbmVycm9yKGUpO1xuICAgICAgaW5zdGFuY2UucmVhZHlTdGF0ZSA9IGluc3RhbmNlLkNMT1NFRDtcbiAgICB9XG4gIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcbiAgICBpbnN0YW5jZS5vbmVycm9yICYmIGluc3RhbmNlLm9uZXJyb3IoZSk7XG4gICAgaW5zdGFuY2UucmVhZHlTdGF0ZSA9IGluc3RhbmNlLkNMT1NFRDtcbiAgfSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHN1Ym1pdChlbmRwb2ludCwgZGF0YSA9IHt9LCBldmVudF9kYXRhLCB0cmlnZ2VyX2lkLCBhbGxfZXZlbnRzKSB7XG4gIHZhciBfYTtcbiAgdHJ5IHtcbiAgICBsZXQgZmlyZV9ldmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoYWxsX2V2ZW50cyB8fCBldmVudHNfdG9fcHVibGlzaFtldmVudC50eXBlXSkge1xuICAgICAgICBwdXNoX2V2ZW50KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCBjbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAocmVzb2x2ZXJzLmxlbmd0aCA+IDApXG4gICAgICAgIHJlc29sdmVycy5zaGlmdCgpKHtcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSwgcHVzaCA9IGZ1bmN0aW9uKGRhdGEyKSB7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHJlc29sdmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc29sdmVycy5zaGlmdCgpKGRhdGEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGRhdGEyKTtcbiAgICAgIH1cbiAgICB9LCBwdXNoX2Vycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIHB1c2godGhlbmFibGVfcmVqZWN0KGVycm9yKSk7XG4gICAgICBjbG9zZSgpO1xuICAgIH0sIHB1c2hfZXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgcHVzaCh7IHZhbHVlOiBldmVudCwgZG9uZTogZmFsc2UgfSk7XG4gICAgfSwgbmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlcy5zaGlmdCgpKTtcbiAgICAgIGlmIChkb25lKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdmFsdWU6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZXJzLnB1c2gocmVzb2x2ZSkpO1xuICAgIH07XG4gICAgY29uc3QgeyBoZl90b2tlbiB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIGZldGNoOiBmZXRjaDIsXG4gICAgICBhcHBfcmVmZXJlbmNlLFxuICAgICAgY29uZmlnLFxuICAgICAgc2Vzc2lvbl9oYXNoLFxuICAgICAgYXBpX2luZm8sXG4gICAgICBhcGlfbWFwLFxuICAgICAgc3RyZWFtX3N0YXR1cyxcbiAgICAgIHBlbmRpbmdfc3RyZWFtX21lc3NhZ2VzLFxuICAgICAgcGVuZGluZ19kaWZmX3N0cmVhbXMsXG4gICAgICBldmVudF9jYWxsYmFja3MsXG4gICAgICB1bmNsb3NlZF9ldmVudHMsXG4gICAgICBwb3N0X2RhdGE6IHBvc3RfZGF0YTIsXG4gICAgICBvcHRpb25zLFxuICAgICAgYXBpX3ByZWZpeFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgIGlmICghYXBpX2luZm8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBBUEkgZm91bmRcIik7XG4gICAgaWYgKCFjb25maWcpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVzb2x2ZSBhcHAgY29uZmlnXCIpO1xuICAgIGxldCB7IGZuX2luZGV4LCBlbmRwb2ludF9pbmZvLCBkZXBlbmRlbmN5IH0gPSBnZXRfZW5kcG9pbnRfaW5mbyhcbiAgICAgIGFwaV9pbmZvLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBhcGlfbWFwLFxuICAgICAgY29uZmlnXG4gICAgKTtcbiAgICBsZXQgcmVzb2x2ZWRfZGF0YSA9IG1hcF9kYXRhX3RvX3BhcmFtcyhkYXRhLCBlbmRwb2ludF9pbmZvKTtcbiAgICBsZXQgd2Vic29ja2V0O1xuICAgIGxldCBzdHJlYW0yO1xuICAgIGxldCBwcm90b2NvbCA9IGNvbmZpZy5wcm90b2NvbCA/PyBcIndzXCI7XG4gICAgbGV0IGV2ZW50X2lkX2ZpbmFsID0gXCJcIjtcbiAgICBsZXQgZXZlbnRfaWRfY2IgPSAoKSA9PiBldmVudF9pZF9maW5hbDtcbiAgICBjb25zdCBfZW5kcG9pbnQgPSB0eXBlb2YgZW5kcG9pbnQgPT09IFwibnVtYmVyXCIgPyBcIi9wcmVkaWN0XCIgOiBlbmRwb2ludDtcbiAgICBsZXQgcGF5bG9hZDtcbiAgICBsZXQgZXZlbnRfaWQgPSBudWxsO1xuICAgIGxldCBjb21wbGV0ZSA9IGZhbHNlO1xuICAgIGxldCBsYXN0X3N0YXR1cyA9IHt9O1xuICAgIGxldCB1cmxfcGFyYW1zID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIGNvbnN0IGV2ZW50c190b19wdWJsaXNoID0gKChfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXZlbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVkdWNlKFxuICAgICAgKGFjYywgZXZlbnQpID0+IHtcbiAgICAgICAgYWNjW2V2ZW50XSA9IHRydWU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge31cbiAgICApKSB8fCB7fTtcbiAgICBhc3luYyBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICBjb25zdCBfc3RhdHVzID0ge1xuICAgICAgICBzdGFnZTogXCJjb21wbGV0ZVwiLFxuICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICB9O1xuICAgICAgY29tcGxldGUgPSBfc3RhdHVzO1xuICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgIC4uLl9zdGF0dXMsXG4gICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgIGZuX2luZGV4XG4gICAgICB9KTtcbiAgICAgIGxldCByZXNldF9yZXF1ZXN0ID0ge307XG4gICAgICBsZXQgY2FuY2VsX3JlcXVlc3QgPSB7fTtcbiAgICAgIGlmIChwcm90b2NvbCA9PT0gXCJ3c1wiKSB7XG4gICAgICAgIGlmICh3ZWJzb2NrZXQgJiYgd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDApIHtcbiAgICAgICAgICB3ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRfcmVxdWVzdCA9IHsgZm5faW5kZXgsIHNlc3Npb25faGFzaCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRfcmVxdWVzdCA9IHsgZXZlbnRfaWQgfTtcbiAgICAgICAgY2FuY2VsX3JlcXVlc3QgPSB7IGV2ZW50X2lkLCBzZXNzaW9uX2hhc2gsIGZuX2luZGV4IH07XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIGFwcCBjb25maWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZXZlbnRfaWRcIiBpbiBjYW5jZWxfcmVxdWVzdCkge1xuICAgICAgICAgIGF3YWl0IGZldGNoMihgJHtjb25maWcucm9vdH0ke2FwaV9wcmVmaXh9LyR7Q0FOQ0VMX1VSTH1gLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2FuY2VsX3JlcXVlc3QpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZmV0Y2gyKGAke2NvbmZpZy5yb290fSR7YXBpX3ByZWZpeH0vJHtSRVNFVF9VUkx9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlc2V0X3JlcXVlc3QpXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYC9yZXNldGAgZW5kcG9pbnQgY291bGQgbm90IGJlIGNhbGxlZC4gU3Vic2VxdWVudCBlbmRwb2ludCByZXN1bHRzIG1heSBiZSB1bnJlbGlhYmxlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVfaGVhcnRiZWF0ID0gYXN5bmMgKGNvbmZpZzIpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuX3Jlc29sdmVfaGVhcnRiZWF0KGNvbmZpZzIpO1xuICAgIH07XG4gICAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlX3JlbmRlcl9jb25maWcocmVuZGVyX2NvbmZpZykge1xuICAgICAgaWYgKCFjb25maWcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCByZW5kZXJfaWQgPSByZW5kZXJfY29uZmlnLnJlbmRlcl9pZDtcbiAgICAgIGNvbmZpZy5jb21wb25lbnRzID0gW1xuICAgICAgICAuLi5jb25maWcuY29tcG9uZW50cy5maWx0ZXIoKGMpID0+IGMucHJvcHMucmVuZGVyZWRfaW4gIT09IHJlbmRlcl9pZCksXG4gICAgICAgIC4uLnJlbmRlcl9jb25maWcuY29tcG9uZW50c1xuICAgICAgXTtcbiAgICAgIGNvbmZpZy5kZXBlbmRlbmNpZXMgPSBbXG4gICAgICAgIC4uLmNvbmZpZy5kZXBlbmRlbmNpZXMuZmlsdGVyKChkKSA9PiBkLnJlbmRlcmVkX2luICE9PSByZW5kZXJfaWQpLFxuICAgICAgICAuLi5yZW5kZXJfY29uZmlnLmRlcGVuZGVuY2llc1xuICAgICAgXTtcbiAgICAgIGNvbnN0IGFueV9zdGF0ZSA9IGNvbmZpZy5jb21wb25lbnRzLnNvbWUoKGMpID0+IGMudHlwZSA9PT0gXCJzdGF0ZVwiKTtcbiAgICAgIGNvbnN0IGFueV91bmxvYWQgPSBjb25maWcuZGVwZW5kZW5jaWVzLnNvbWUoXG4gICAgICAgIChkKSA9PiBkLnRhcmdldHMuc29tZSgodCkgPT4gdFsxXSA9PT0gXCJ1bmxvYWRcIilcbiAgICAgICk7XG4gICAgICBjb25maWcuY29ubmVjdF9oZWFydGJlYXQgPSBhbnlfc3RhdGUgfHwgYW55X3VubG9hZDtcbiAgICAgIGF3YWl0IHJlc29sdmVfaGVhcnRiZWF0KGNvbmZpZyk7XG4gICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgdHlwZTogXCJyZW5kZXJcIixcbiAgICAgICAgZGF0YTogcmVuZGVyX2NvbmZpZyxcbiAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgZm5faW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmhhbmRsZV9ibG9iKGNvbmZpZy5yb290LCByZXNvbHZlZF9kYXRhLCBlbmRwb2ludF9pbmZvKS50aGVuKFxuICAgICAgYXN5bmMgKF9wYXlsb2FkKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGxldCBpbnB1dF9kYXRhID0gaGFuZGxlX3BheWxvYWQoXG4gICAgICAgICAgX3BheWxvYWQsXG4gICAgICAgICAgZGVwZW5kZW5jeSxcbiAgICAgICAgICBjb25maWcuY29tcG9uZW50cyxcbiAgICAgICAgICBcImlucHV0XCIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICBwYXlsb2FkID0ge1xuICAgICAgICAgIGRhdGE6IGlucHV0X2RhdGEgfHwgW10sXG4gICAgICAgICAgZXZlbnRfZGF0YSxcbiAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICB0cmlnZ2VyX2lkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChza2lwX3F1ZXVlKGZuX2luZGV4LCBjb25maWcpKSB7XG4gICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICB0eXBlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgIHN0YWdlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3N0X2RhdGEyKFxuICAgICAgICAgICAgYCR7Y29uZmlnLnJvb3R9JHthcGlfcHJlZml4fS9ydW4ke19lbmRwb2ludC5zdGFydHNXaXRoKFwiL1wiKSA/IF9lbmRwb2ludCA6IGAvJHtfZW5kcG9pbnR9YH0ke3VybF9wYXJhbXMgPyBcIj9cIiArIHVybF9wYXJhbXMgOiBcIlwifWAsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgIHNlc3Npb25faGFzaFxuICAgICAgICAgICAgfVxuICAgICAgICAgICkudGhlbigoW291dHB1dCwgc3RhdHVzX2NvZGVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhMiA9IG91dHB1dC5kYXRhO1xuICAgICAgICAgICAgaWYgKHN0YXR1c19jb2RlID09IDIwMCkge1xuICAgICAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGFcIixcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgIGRhdGE6IGhhbmRsZV9wYXlsb2FkKFxuICAgICAgICAgICAgICAgICAgZGF0YTIsXG4gICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5LFxuICAgICAgICAgICAgICAgICAgY29uZmlnLmNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICBcIm91dHB1dFwiLFxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy53aXRoX251bGxfc3RhdGVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGV2ZW50X2RhdGEsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcl9pZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dC5yZW5kZXJfY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlX3JlbmRlcl9jb25maWcob3V0cHV0LnJlbmRlcl9jb25maWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICBzdGFnZTogXCJjb21wbGV0ZVwiLFxuICAgICAgICAgICAgICAgIGV0YTogb3V0cHV0LmF2ZXJhZ2VfZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICBzdGFnZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3V0cHV0LmVycm9yLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3RvY29sID09IFwid3NcIikge1xuICAgICAgICAgIGNvbnN0IHsgd3NfcHJvdG9jb2wsIGhvc3QgfSA9IGF3YWl0IHByb2Nlc3NfZW5kcG9pbnQoXG4gICAgICAgICAgICBhcHBfcmVmZXJlbmNlLFxuICAgICAgICAgICAgaGZfdG9rZW5cbiAgICAgICAgICApO1xuICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgIHN0YWdlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChcbiAgICAgICAgICAgIGAke3dzX3Byb3RvY29sfTovLyR7cmVzb2x2ZV9yb290KFxuICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgICBjb25maWcucm9vdCxcbiAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgKX0vcXVldWUvam9pbiR7dXJsX3BhcmFtcyA/IFwiP1wiICsgdXJsX3BhcmFtcyA6IFwiXCJ9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRoaXMuand0KSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcIl9fc2lnblwiLCB0aGlzLmp3dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdlYnNvY2tldCA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgICAgICB3ZWJzb2NrZXQub25jbG9zZSA9IChldnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZ0Lndhc0NsZWFuKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgc3RhZ2U6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBicm9rZW46IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogQlJPS0VOX0NPTk5FQ1RJT05fTVNHLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3ZWJzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IF9kYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgc3RhdHVzLCBkYXRhOiBkYXRhMiB9ID0gaGFuZGxlX21lc3NhZ2UoXG4gICAgICAgICAgICAgIF9kYXRhLFxuICAgICAgICAgICAgICBsYXN0X3N0YXR1c1tmbl9pbmRleF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJ1cGRhdGVcIiAmJiBzdGF0dXMgJiYgIWNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAuLi5zdGF0dXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChzdGF0dXMuc3RhZ2UgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaGFzaFwiKSB7XG4gICAgICAgICAgICAgIHdlYnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHsgZm5faW5kZXgsIHNlc3Npb25faGFzaCB9KSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgICAgd2Vic29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoeyAuLi5wYXlsb2FkLCBzZXNzaW9uX2hhc2ggfSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgY29tcGxldGUgPSBzdGF0dXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibG9nXCIpIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogZGF0YTIudGl0bGUsXG4gICAgICAgICAgICAgICAgbG9nOiBkYXRhMi5sb2csXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGRhdGEyLmxldmVsLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGRhdGEyLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IGRhdGEyLnZpc2libGUsXG4gICAgICAgICAgICAgICAgZm5faW5kZXhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZ2VuZXJhdGluZ1wiKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgLi4uc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YWdlOiBzdGF0dXMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXR1cy5zdGFnZSxcbiAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgIGZuX2luZGV4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEyKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0YVwiLFxuICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGRhdGE6IGhhbmRsZV9wYXlsb2FkKFxuICAgICAgICAgICAgICAgICAgZGF0YTIuZGF0YSxcbiAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3ksXG4gICAgICAgICAgICAgICAgICBjb25maWcuY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICAgIFwib3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLndpdGhfbnVsbF9zdGF0ZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICBldmVudF9kYXRhLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJfaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgLi4uY29tcGxldGUsXG4gICAgICAgICAgICAgICAgICBzdGFnZTogc3RhdHVzID09IG51bGwgPyB2b2lkIDAgOiBzdGF0dXMuc3RhZ2UsXG4gICAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICBmbl9pbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoc2VtaXZlcihjb25maWcudmVyc2lvbiB8fCBcIjIuMC4wXCIsIFwiMy42XCIpIDwgMCkge1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgXCJvcGVuXCIsXG4gICAgICAgICAgICAgICgpID0+IHdlYnNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHsgaGFzaDogc2Vzc2lvbl9oYXNoIH0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvdG9jb2wgPT0gXCJzc2VcIikge1xuICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgIHN0YWdlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBmbl9pbmRleDogZm5faW5kZXgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHNlc3Npb25faGFzaFxuICAgICAgICAgIH0pLnRvU3RyaW5nKCk7XG4gICAgICAgICAgbGV0IHVybCA9IG5ldyBVUkwoXG4gICAgICAgICAgICBgJHtjb25maWcucm9vdH0ke2FwaV9wcmVmaXh9LyR7U1NFX1VSTH0/JHt1cmxfcGFyYW1zID8gdXJsX3BhcmFtcyArIFwiJlwiIDogXCJcIn0ke3BhcmFtc31gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodGhpcy5qd3QpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiX19zaWduXCIsIHRoaXMuand0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtMiA9IHRoaXMuc3RyZWFtKHVybCk7XG4gICAgICAgICAgaWYgKCFzdHJlYW0yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcIkNhbm5vdCBjb25uZWN0IHRvIFNTRSBlbmRwb2ludDogXCIgKyB1cmwudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmVhbTIub25tZXNzYWdlID0gYXN5bmMgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IF9kYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgc3RhdHVzLCBkYXRhOiBkYXRhMiB9ID0gaGFuZGxlX21lc3NhZ2UoXG4gICAgICAgICAgICAgIF9kYXRhLFxuICAgICAgICAgICAgICBsYXN0X3N0YXR1c1tmbl9pbmRleF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJ1cGRhdGVcIiAmJiBzdGF0dXMgJiYgIWNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAuLi5zdGF0dXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChzdGF0dXMuc3RhZ2UgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHN0cmVhbTIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0cmVhbTIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICAgIGxldCBbXywgc3RhdHVzMl0gPSBhd2FpdCBwb3N0X2RhdGEyKFxuICAgICAgICAgICAgICAgIGAke2NvbmZpZy5yb290fSR7YXBpX3ByZWZpeH0vcXVldWUvZGF0YWAsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgIHNlc3Npb25faGFzaCxcbiAgICAgICAgICAgICAgICAgIGV2ZW50X2lkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoc3RhdHVzMiAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgc3RhZ2U6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IEJST0tFTl9DT05ORUNUSU9OX01TRyxcbiAgICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdHJlYW0yID09IG51bGwgPyB2b2lkIDAgOiBzdHJlYW0yLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgY29tcGxldGUgPSBzdGF0dXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibG9nXCIpIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogZGF0YTIudGl0bGUsXG4gICAgICAgICAgICAgICAgbG9nOiBkYXRhMi5sb2csXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGRhdGEyLmxldmVsLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGRhdGEyLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IGRhdGEyLnZpc2libGUsXG4gICAgICAgICAgICAgICAgZm5faW5kZXhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZ2VuZXJhdGluZ1wiIHx8IHR5cGUgPT09IFwic3RyZWFtaW5nXCIpIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAuLi5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhZ2U6IHN0YXR1cyA9PSBudWxsID8gdm9pZCAwIDogc3RhdHVzLnN0YWdlLFxuICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiBfZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgZm5faW5kZXhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YTIpIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgZGF0YTogaGFuZGxlX3BheWxvYWQoXG4gICAgICAgICAgICAgICAgICBkYXRhMi5kYXRhLFxuICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5jb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgXCJvdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2l0aF9udWxsX3N0YXRlXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgIGV2ZW50X2RhdGEsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcl9pZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAuLi5jb21wbGV0ZSxcbiAgICAgICAgICAgICAgICAgIHN0YWdlOiBzdGF0dXMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXR1cy5zdGFnZSxcbiAgICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgIGZuX2luZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtMiA9PSBudWxsID8gdm9pZCAwIDogc3RyZWFtMi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHByb3RvY29sID09IFwic3NlX3YxXCIgfHwgcHJvdG9jb2wgPT0gXCJzc2VfdjJcIiB8fCBwcm90b2NvbCA9PSBcInNzZV92Mi4xXCIgfHwgcHJvdG9jb2wgPT0gXCJzc2VfdjNcIikge1xuICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgIHN0YWdlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaG9zdG5hbWUgPSAoX2EyID0gd2luZG93ID09IG51bGwgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaG9zdG5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBoZmh1YmRldiA9IFwiZGV2LnNwYWNlcy5odWdnaW5nZmFjZS50ZWNoXCI7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luID0gaG9zdG5hbWUuaW5jbHVkZXMoXCIuZGV2LlwiKSA/IGBodHRwczovL21vb24tJHtob3N0bmFtZS5zcGxpdChcIi5cIilbMV19LiR7aGZodWJkZXZ9YCA6IGBodHRwczovL2h1Z2dpbmdmYWNlLmNvYDtcbiAgICAgICAgICBjb25zdCBpc196ZXJvZ3B1X2lmcmFtZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5wYXJlbnQgIT0gd2luZG93ICYmIHdpbmRvdy5zdXBwb3J0c196ZXJvZ3B1X2hlYWRlcnM7XG4gICAgICAgICAgY29uc3QgemVyb2dwdV9hdXRoX3Byb21pc2UgPSBpc196ZXJvZ3B1X2lmcmFtZSA/IHBvc3RfbWVzc2FnZShcInplcm9ncHUtaGVhZGVyc1wiLCBvcmlnaW4pIDogUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgIGNvbnN0IHBvc3RfZGF0YV9wcm9taXNlID0gemVyb2dwdV9hdXRoX3Byb21pc2UudGhlbigoaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RfZGF0YTIoXG4gICAgICAgICAgICAgIGAke2NvbmZpZy5yb290fSR7YXBpX3ByZWZpeH0vJHtTU0VfREFUQV9VUkx9PyR7dXJsX3BhcmFtc31gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICBzZXNzaW9uX2hhc2hcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3N0X2RhdGFfcHJvbWlzZS50aGVuKGFzeW5jIChbcmVzcG9uc2UsIHN0YXR1c10pID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDUwMykge1xuICAgICAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXR1c1wiLFxuICAgICAgICAgICAgICAgIHN0YWdlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogUVVFVUVfRlVMTF9NU0csXG4gICAgICAgICAgICAgICAgcXVldWU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICBzdGFnZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGJyb2tlbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBCUk9LRU5fQ09OTkVDVElPTl9NU0csXG4gICAgICAgICAgICAgICAgcXVldWU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV2ZW50X2lkID0gcmVzcG9uc2UuZXZlbnRfaWQ7XG4gICAgICAgICAgICAgIGV2ZW50X2lkX2ZpbmFsID0gZXZlbnRfaWQ7XG4gICAgICAgICAgICAgIGxldCBjYWxsYmFjayA9IGFzeW5jIGZ1bmN0aW9uKF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgc3RhdHVzOiBzdGF0dXMyLCBkYXRhOiBkYXRhMiwgb3JpZ2luYWxfbXNnIH0gPSBoYW5kbGVfbWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAgX2RhdGEsXG4gICAgICAgICAgICAgICAgICAgIGxhc3Rfc3RhdHVzW2ZuX2luZGV4XVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IFwiaGVhcnRiZWF0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwidXBkYXRlXCIgJiYgc3RhdHVzMiAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgIGZuX2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsX21zZyxcbiAgICAgICAgICAgICAgICAgICAgICAuLi5zdGF0dXMyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSBzdGF0dXMyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IFwidW5leHBlY3RlZF9lcnJvclwiIHx8IHR5cGUgPT0gXCJicm9rZW5fY29ubmVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGVycm9yXCIsIHN0YXR1czIgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXR1czIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJyb2tlbiA9IHR5cGUgPT09IFwiYnJva2VuX2Nvbm5lY3Rpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgICBzdGFnZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IChzdGF0dXMyID09IG51bGwgPyB2b2lkIDAgOiBzdGF0dXMyLm1lc3NhZ2UpIHx8IFwiQW4gVW5leHBlY3RlZCBFcnJvciBPY2N1cnJlZCFcIixcbiAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgIGJyb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uX25vdF9mb3VuZDogc3RhdHVzMiA9PSBudWxsID8gdm9pZCAwIDogc3RhdHVzMi5zZXNzaW9uX25vdF9mb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgICBmbl9pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJsb2dcIikge1xuICAgICAgICAgICAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxvZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhMi50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICBsb2c6IGRhdGEyLmxvZyxcbiAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogZGF0YTIubGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZGF0YTIuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogZGF0YTIudmlzaWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICBmbl9pbmRleFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImdlbmVyYXRpbmdcIiB8fCB0eXBlID09PSBcInN0cmVhbWluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgLi4uc3RhdHVzMixcbiAgICAgICAgICAgICAgICAgICAgICBzdGFnZTogc3RhdHVzMiA9PSBudWxsID8gdm9pZCAwIDogc3RhdHVzMi5zdGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgIGZuX2luZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YTIgJiYgZGVwZW5kZW5jeS5jb25uZWN0aW9uICE9PSBcInN0cmVhbVwiICYmIFtcInNzZV92MlwiLCBcInNzZV92Mi4xXCIsIFwic3NlX3YzXCJdLmluY2x1ZGVzKHByb3RvY29sKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFwcGx5X2RpZmZfc3RyZWFtKHBlbmRpbmdfZGlmZl9zdHJlYW1zLCBldmVudF9pZCwgZGF0YTIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YTIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyZV9ldmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGFuZGxlX3BheWxvYWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhMi5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2l0aF9udWxsX3N0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogX2VuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgIGZuX2luZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YTIucmVuZGVyX2NvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZV9yZW5kZXJfY29uZmlnKGRhdGEyLnJlbmRlcl9jb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGZpcmVfZXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFnZTogc3RhdHVzMiA9PSBudWxsID8gdm9pZCAwIDogc3RhdHVzMi5zdGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuX2luZGV4XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKChzdGF0dXMyID09IG51bGwgPyB2b2lkIDAgOiBzdGF0dXMyLnN0YWdlKSA9PT0gXCJjb21wbGV0ZVwiIHx8IChzdGF0dXMyID09IG51bGwgPyB2b2lkIDAgOiBzdGF0dXMyLnN0YWdlKSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudF9jYWxsYmFja3NbZXZlbnRfaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50X2NhbGxiYWNrc1tldmVudF9pZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50X2lkIGluIHBlbmRpbmdfZGlmZl9zdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdfZGlmZl9zdHJlYW1zW2V2ZW50X2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIGNsaWVudCBleGNlcHRpb25cIiwgZSk7XG4gICAgICAgICAgICAgICAgICBmaXJlX2V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2U6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBbiBVbmV4cGVjdGVkIEVycm9yIE9jY3VycmVkIVwiLFxuICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IF9lbmRwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgZm5faW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmIChbXCJzc2VfdjJcIiwgXCJzc2VfdjIuMVwiLCBcInNzZV92M1wiXS5pbmNsdWRlcyhwcm90b2NvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2Vfc3RyZWFtKHN0cmVhbV9zdGF0dXMsIHRoYXQuYWJvcnRfY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbV9zdGF0dXMub3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50X2lkIGluIHBlbmRpbmdfc3RyZWFtX21lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ19zdHJlYW1fbWVzc2FnZXNbZXZlbnRfaWRdLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAobXNnKSA9PiBjYWxsYmFjayhtc2cpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGVuZGluZ19zdHJlYW1fbWVzc2FnZXNbZXZlbnRfaWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV2ZW50X2NhbGxiYWNrc1tldmVudF9pZF0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgdW5jbG9zZWRfZXZlbnRzLmFkZChldmVudF9pZCk7XG4gICAgICAgICAgICAgIGlmICghc3RyZWFtX3N0YXR1cy5vcGVuKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5vcGVuX3N0cmVhbSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgY29uc3QgcmVzb2x2ZXJzID0gW107XG4gICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdOiAoKSA9PiBpdGVyYXRvcixcbiAgICAgIG5leHQsXG4gICAgICB0aHJvdzogYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgIHB1c2hfZXJyb3IodmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfSxcbiAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbCxcbiAgICAgIGV2ZW50X2lkOiBldmVudF9pZF9jYlxuICAgIH07XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJTdWJtaXQgZnVuY3Rpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gdGhlbmFibGVfcmVqZWN0KGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgdGhlbjogKHJlc29sdmUsIHJlamVjdCkgPT4gcmVqZWN0KGVycm9yKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0X2VuZHBvaW50X2luZm8oYXBpX2luZm8sIGVuZHBvaW50LCBhcGlfbWFwLCBjb25maWcpIHtcbiAgbGV0IGZuX2luZGV4O1xuICBsZXQgZW5kcG9pbnRfaW5mbztcbiAgbGV0IGRlcGVuZGVuY3k7XG4gIGlmICh0eXBlb2YgZW5kcG9pbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICBmbl9pbmRleCA9IGVuZHBvaW50O1xuICAgIGVuZHBvaW50X2luZm8gPSBhcGlfaW5mby51bm5hbWVkX2VuZHBvaW50c1tmbl9pbmRleF07XG4gICAgZGVwZW5kZW5jeSA9IGNvbmZpZy5kZXBlbmRlbmNpZXMuZmluZCgoZGVwKSA9PiBkZXAuaWQgPT0gZW5kcG9pbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRyaW1tZWRfZW5kcG9pbnQgPSBlbmRwb2ludC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgZm5faW5kZXggPSBhcGlfbWFwW3RyaW1tZWRfZW5kcG9pbnRdO1xuICAgIGVuZHBvaW50X2luZm8gPSBhcGlfaW5mby5uYW1lZF9lbmRwb2ludHNbZW5kcG9pbnQudHJpbSgpXTtcbiAgICBkZXBlbmRlbmN5ID0gY29uZmlnLmRlcGVuZGVuY2llcy5maW5kKFxuICAgICAgKGRlcCkgPT4gZGVwLmlkID09IGFwaV9tYXBbdHJpbW1lZF9lbmRwb2ludF1cbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2YgZm5faW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZXJlIGlzIG5vIGVuZHBvaW50IG1hdGNoaW5nIHRoYXQgbmFtZSBvZiBmbl9pbmRleCBtYXRjaGluZyB0aGF0IG51bWJlci5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHsgZm5faW5kZXgsIGVuZHBvaW50X2luZm8sIGRlcGVuZGVuY3kgfTtcbn1cbmNsYXNzIENsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGFwcF9yZWZlcmVuY2UsIG9wdGlvbnMgPSB7IGV2ZW50czogW1wiZGF0YVwiXSB9KSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFwcF9yZWZlcmVuY2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRlZXBfbGlua1wiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uZmlnXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhcGlfcHJlZml4XCIsIFwiXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhcGlfaW5mb1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXBpX21hcFwiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNlc3Npb25faGFzaFwiLCBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJqd3RcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsYXN0X3N0YXR1c1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvb2tpZXNcIiwgbnVsbCk7XG4gICAgLy8gc3RyZWFtaW5nXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0cmVhbV9zdGF0dXNcIiwgeyBvcGVuOiBmYWxzZSB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2xvc2VkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGVuZGluZ19zdHJlYW1fbWVzc2FnZXNcIiwge30pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwZW5kaW5nX2RpZmZfc3RyZWFtc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImV2ZW50X2NhbGxiYWNrc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuY2xvc2VkX2V2ZW50c1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGVhcnRiZWF0X2V2ZW50XCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhYm9ydF9jb250cm9sbGVyXCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHJlYW1faW5zdGFuY2VcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImN1cnJlbnRfcGF5bG9hZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwid3NfbWFwXCIsIHt9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmlld19hcGlcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVwbG9hZF9maWxlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXBsb2FkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVfYmxvYlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicG9zdF9kYXRhXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdWJtaXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByZWRpY3RcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wZW5fc3RyZWFtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXNvbHZlX2NvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzb2x2ZV9jb29raWVzXCIpO1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmFwcF9yZWZlcmVuY2UgPSBhcHBfcmVmZXJlbmNlO1xuICAgIHRoaXMuZGVlcF9saW5rID0gKChfYSA9IG9wdGlvbnMucXVlcnlfcGFyYW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVlcF9saW5rKSB8fCBudWxsO1xuICAgIGlmICghb3B0aW9ucy5ldmVudHMpIHtcbiAgICAgIG9wdGlvbnMuZXZlbnRzID0gW1wiZGF0YVwiXTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnRfcGF5bG9hZCA9IHt9O1xuICAgIHRoaXMudmlld19hcGkgPSB2aWV3X2FwaS5iaW5kKHRoaXMpO1xuICAgIHRoaXMudXBsb2FkX2ZpbGVzID0gdXBsb2FkX2ZpbGVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVfYmxvYiA9IGhhbmRsZV9ibG9iLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wb3N0X2RhdGEgPSBwb3N0X2RhdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1Ym1pdCA9IHN1Ym1pdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJlZGljdCA9IHByZWRpY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9wZW5fc3RyZWFtID0gb3Blbl9zdHJlYW0uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlc29sdmVfY29uZmlnID0gcmVzb2x2ZV9jb25maWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlc29sdmVfY29va2llcyA9IHJlc29sdmVfY29va2llcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMudXBsb2FkID0gdXBsb2FkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5mZXRjaCA9IHRoaXMuZmV0Y2guYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZV9zcGFjZV9zdWNjZXNzID0gdGhpcy5oYW5kbGVfc3BhY2Vfc3VjY2Vzcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3RyZWFtID0gdGhpcy5zdHJlYW0uYmluZCh0aGlzKTtcbiAgfVxuICBnZXRfdXJsX2NvbmZpZyh1cmwgPSBudWxsKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKENPTkZJR19FUlJPUl9NU0cpO1xuICAgIH1cbiAgICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgICB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICB9XG4gICAgY29uc3Qgc3RyaXBTbGFzaGVzID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL15cXC8rfFxcLyskL2csIFwiXCIpO1xuICAgIGxldCByb290X3BhdGggPSBzdHJpcFNsYXNoZXMobmV3IFVSTCh0aGlzLmNvbmZpZy5yb290KS5wYXRobmFtZSk7XG4gICAgbGV0IHVybF9wYXRoID0gc3RyaXBTbGFzaGVzKG5ldyBVUkwodXJsKS5wYXRobmFtZSk7XG4gICAgbGV0IHBhZ2U7XG4gICAgaWYgKCF1cmxfcGF0aC5zdGFydHNXaXRoKHJvb3RfcGF0aCkpIHtcbiAgICAgIHBhZ2UgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWdlID0gc3RyaXBTbGFzaGVzKHVybF9wYXRoLnN1YnN0cmluZyhyb290X3BhdGgubGVuZ3RoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldF9wYWdlX2NvbmZpZyhwYWdlKTtcbiAgfVxuICBnZXRfcGFnZV9jb25maWcocGFnZSkge1xuICAgIGlmICghdGhpcy5jb25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihDT05GSUdfRVJST1JfTVNHKTtcbiAgICB9XG4gICAgbGV0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghKHBhZ2UgaW4gY29uZmlnLnBhZ2UpKSB7XG4gICAgICBwYWdlID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGN1cnJlbnRfcGFnZTogcGFnZSxcbiAgICAgIGxheW91dDogY29uZmlnLnBhZ2VbcGFnZV0ubGF5b3V0LFxuICAgICAgY29tcG9uZW50czogY29uZmlnLmNvbXBvbmVudHMuZmlsdGVyKFxuICAgICAgICAoYykgPT4gY29uZmlnLnBhZ2VbcGFnZV0uY29tcG9uZW50cy5pbmNsdWRlcyhjLmlkKVxuICAgICAgKSxcbiAgICAgIGRlcGVuZGVuY2llczogdGhpcy5jb25maWcuZGVwZW5kZW5jaWVzLmZpbHRlcihcbiAgICAgICAgKGQpID0+IGNvbmZpZy5wYWdlW3BhZ2VdLmRlcGVuZGVuY2llcy5pbmNsdWRlcyhkLmlkKVxuICAgICAgKVxuICAgIH07XG4gIH1cbiAgZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykgfHwge30pO1xuICAgIGlmICh0aGlzICYmIHRoaXMuY29va2llcykge1xuICAgICAgaGVhZGVycy5hcHBlbmQoXCJDb29raWVcIiwgdGhpcy5jb29raWVzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICBoZWFkZXJzLmFwcGVuZChuYW1lLCB0aGlzLm9wdGlvbnMuaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmZXRjaChpbnB1dCwgeyAuLi5pbml0LCBoZWFkZXJzIH0pO1xuICB9XG4gIHN0cmVhbSh1cmwpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBpZiAodGhpcyAmJiB0aGlzLmNvb2tpZXMpIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQ29va2llXCIsIHRoaXMuY29va2llcyk7XG4gICAgfVxuICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQobmFtZSwgdGhpcy5vcHRpb25zLmhlYWRlcnNbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMuaGZfdG9rZW4pIHtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwiQXV0aG9yaXphdGlvblwiLCBgQmVhcmVyICR7dGhpcy5vcHRpb25zLmhmX3Rva2VufWApO1xuICAgIH1cbiAgICB0aGlzLmFib3J0X2NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5zdHJlYW1faW5zdGFuY2UgPSByZWFkYWJsZV9zdHJlYW0odXJsLnRvU3RyaW5nKCksIHtcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzaWduYWw6IHRoaXMuYWJvcnRfY29udHJvbGxlci5zaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1faW5zdGFuY2U7XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICEoXCJXZWJTb2NrZXRcIiBpbiB3aW5kb3cpKSAmJiAhZ2xvYmFsLldlYlNvY2tldCkge1xuICAgICAge1xuICAgICAgICBjb25zdCB3cyA9IGF3YWl0IGltcG9ydChcIi4vd3JhcHBlci1DdmlTc2VsRy5qc1wiKTtcbiAgICAgICAgZ2xvYmFsLldlYlNvY2tldCA9IHdzLldlYlNvY2tldDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRoKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlc29sdmVfY29va2llcygpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9yZXNvbHZlX2NvbmZpZygpLnRoZW4oXG4gICAgICAoeyBjb25maWcgfSkgPT4gdGhpcy5fcmVzb2x2ZV9oZWFydGJlYXQoY29uZmlnKVxuICAgICk7XG4gICAgdGhpcy5hcGlfaW5mbyA9IGF3YWl0IHRoaXMudmlld19hcGkoKTtcbiAgICB0aGlzLmFwaV9tYXAgPSBtYXBfbmFtZXNfdG9faWRzKCgoX2EgPSB0aGlzLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlcGVuZGVuY2llcykgfHwgW10pO1xuICB9XG4gIGFzeW5jIF9yZXNvbHZlX2hlYXJ0YmVhdChfY29uZmlnKSB7XG4gICAgaWYgKF9jb25maWcpIHtcbiAgICAgIHRoaXMuY29uZmlnID0gX2NvbmZpZztcbiAgICAgIHRoaXMuYXBpX3ByZWZpeCA9IF9jb25maWcuYXBpX3ByZWZpeCB8fCBcIlwiO1xuICAgICAgaWYgKHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnLmNvbm5lY3RfaGVhcnRiZWF0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5zcGFjZV9pZCAmJiB0aGlzLm9wdGlvbnMuaGZfdG9rZW4pIHtcbiAgICAgICAgICB0aGlzLmp3dCA9IGF3YWl0IGdldF9qd3QoXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zcGFjZV9pZCxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5oZl90b2tlbixcbiAgICAgICAgICAgIHRoaXMuY29va2llc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9jb25maWcuc3BhY2VfaWQgJiYgdGhpcy5vcHRpb25zLmhmX3Rva2VuKSB7XG4gICAgICB0aGlzLmp3dCA9IGF3YWl0IGdldF9qd3QoX2NvbmZpZy5zcGFjZV9pZCwgdGhpcy5vcHRpb25zLmhmX3Rva2VuKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnICYmIHRoaXMuY29uZmlnLmNvbm5lY3RfaGVhcnRiZWF0KSB7XG4gICAgICBjb25zdCBoZWFydGJlYXRfdXJsID0gbmV3IFVSTChcbiAgICAgICAgYCR7dGhpcy5jb25maWcucm9vdH0ke3RoaXMuYXBpX3ByZWZpeH0vJHtIRUFSVEJFQVRfVVJMfS8ke3RoaXMuc2Vzc2lvbl9oYXNofWBcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5qd3QpIHtcbiAgICAgICAgaGVhcnRiZWF0X3VybC5zZWFyY2hQYXJhbXMuc2V0KFwiX19zaWduXCIsIHRoaXMuand0KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5oZWFydGJlYXRfZXZlbnQpIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRfZXZlbnQgPSB0aGlzLnN0cmVhbShoZWFydGJlYXRfdXJsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucyA9IHtcbiAgICBldmVudHM6IFtcImRhdGFcIl1cbiAgfSkge1xuICAgIGNvbnN0IGNsaWVudDIgPSBuZXcgdGhpcyhhcHBfcmVmZXJlbmNlLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5zZXNzaW9uX2hhc2gpIHtcbiAgICAgIGNsaWVudDIuc2Vzc2lvbl9oYXNoID0gb3B0aW9ucy5zZXNzaW9uX2hhc2g7XG4gICAgfVxuICAgIGF3YWl0IGNsaWVudDIuaW5pdCgpO1xuICAgIHJldHVybiBjbGllbnQyO1xuICB9XG4gIGFzeW5jIHJlY29ubmVjdCgpIHtcbiAgICBjb25zdCBhcHBfaWRfdXJsID0gbmV3IFVSTChcbiAgICAgIGAke3RoaXMuY29uZmlnLnJvb3R9JHt0aGlzLmFwaV9wcmVmaXh9LyR7QVBQX0lEX1VSTH1gXG4gICAgKTtcbiAgICBsZXQgYXBwX2lkO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goYXBwX2lkX3VybCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgYXBwX2lkID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkuYXBwX2lkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBcImJyb2tlblwiO1xuICAgIH1cbiAgICBpZiAoYXBwX2lkICE9PSB0aGlzLmNvbmZpZy5hcHBfaWQpIHtcbiAgICAgIHJldHVybiBcImNoYW5nZWRcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiY29ubmVjdGVkXCI7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIGNsb3NlX3N0cmVhbSh0aGlzLnN0cmVhbV9zdGF0dXMsIHRoaXMuYWJvcnRfY29udHJvbGxlcik7XG4gIH1cbiAgc2V0X2N1cnJlbnRfcGF5bG9hZChwYXlsb2FkKSB7XG4gICAgdGhpcy5jdXJyZW50X3BheWxvYWQgPSBwYXlsb2FkO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkdXBsaWNhdGUoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucyA9IHtcbiAgICBldmVudHM6IFtcImRhdGFcIl1cbiAgfSkge1xuICAgIHJldHVybiBkdXBsaWNhdGUoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgX3Jlc29sdmVfY29uZmlnKCkge1xuICAgIGNvbnN0IHsgaHR0cF9wcm90b2NvbCwgaG9zdCwgc3BhY2VfaWQgfSA9IGF3YWl0IHByb2Nlc3NfZW5kcG9pbnQoXG4gICAgICB0aGlzLmFwcF9yZWZlcmVuY2UsXG4gICAgICB0aGlzLm9wdGlvbnMuaGZfdG9rZW5cbiAgICApO1xuICAgIGNvbnN0IHsgc3RhdHVzX2NhbGxiYWNrIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHNwYWNlX2lkICYmIHN0YXR1c19jYWxsYmFjaykge1xuICAgICAgYXdhaXQgY2hlY2tfYW5kX3dha2Vfc3BhY2Uoc3BhY2VfaWQsIHN0YXR1c19jYWxsYmFjayk7XG4gICAgfVxuICAgIGxldCBjb25maWc7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb25maWdVcmwgPSBgJHtodHRwX3Byb3RvY29sfS8vJHtob3N0fWA7XG4gICAgICBjb25maWcgPSBhd2FpdCB0aGlzLnJlc29sdmVfY29uZmlnKGNvbmZpZ1VybCk7XG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09ORklHX0VSUk9SX01TRyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb25maWdfc3VjY2Vzcyhjb25maWcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChzcGFjZV9pZCAmJiBzdGF0dXNfY2FsbGJhY2spIHtcbiAgICAgICAgY2hlY2tfc3BhY2Vfc3RhdHVzKFxuICAgICAgICAgIHNwYWNlX2lkLFxuICAgICAgICAgIFJFX1NQQUNFX05BTUUudGVzdChzcGFjZV9pZCkgPyBcInNwYWNlX25hbWVcIiA6IFwic3ViZG9tYWluXCIsXG4gICAgICAgICAgdGhpcy5oYW5kbGVfc3BhY2Vfc3VjY2Vzc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXR1c19jYWxsYmFjaylcbiAgICAgICAgICBzdGF0dXNfY2FsbGJhY2soe1xuICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkNvdWxkIG5vdCBsb2FkIHRoaXMgc3BhY2UuXCIsXG4gICAgICAgICAgICBsb2FkX3N0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgICAgZGV0YWlsOiBcIk5PVF9GT1VORFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIHRocm93IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBjb25maWdfc3VjY2VzcyhfY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBfY29uZmlnO1xuICAgIHRoaXMuYXBpX3ByZWZpeCA9IF9jb25maWcuYXBpX3ByZWZpeCB8fCBcIlwiO1xuICAgIGlmICh0aGlzLmNvbmZpZy5hdXRoX3JlcXVpcmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVwYXJlX3JldHVybl9vYmooKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYXBpX2luZm8gPSBhd2FpdCB0aGlzLnZpZXdfYXBpKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihBUElfSU5GT19FUlJPUl9NU0cgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlX3JldHVybl9vYmooKTtcbiAgfVxuICBhc3luYyBoYW5kbGVfc3BhY2Vfc3VjY2VzcyhzdGF0dXMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoQ09ORklHX0VSUk9SX01TRyk7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhdHVzX2NhbGxiYWNrIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHN0YXR1c19jYWxsYmFjaylcbiAgICAgIHN0YXR1c19jYWxsYmFjayhzdGF0dXMpO1xuICAgIGlmIChzdGF0dXMuc3RhdHVzID09PSBcInJ1bm5pbmdcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBhd2FpdCB0aGlzLl9yZXNvbHZlX2NvbmZpZygpO1xuICAgICAgICB0aGlzLmFwaV9wcmVmaXggPSAoKF9hID0gdGhpcyA9PSBudWxsID8gdm9pZCAwIDogdGhpcy5jb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hcGlfcHJlZml4KSB8fCBcIlwiO1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPTkZJR19FUlJPUl9NU0cpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9jb25maWcgPSBhd2FpdCB0aGlzLmNvbmZpZ19zdWNjZXNzKHRoaXMuY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdGF0dXNfY2FsbGJhY2spIHtcbiAgICAgICAgICBzdGF0dXNfY2FsbGJhY2soe1xuICAgICAgICAgICAgc3RhdHVzOiBcImVycm9yXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIkNvdWxkIG5vdCBsb2FkIHRoaXMgc3BhY2UuXCIsXG4gICAgICAgICAgICBsb2FkX3N0YXR1czogXCJlcnJvclwiLFxuICAgICAgICAgICAgZGV0YWlsOiBcIk5PVF9GT1VORFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgY29tcG9uZW50X3NlcnZlcihjb21wb25lbnRfaWQsIGZuX25hbWUsIGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLmNvbmZpZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKENPTkZJR19FUlJPUl9NU0cpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgY29uc3QgeyBoZl90b2tlbiB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHsgc2Vzc2lvbl9oYXNoIH0gPSB0aGlzO1xuICAgIGlmIChoZl90b2tlbikge1xuICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3RoaXMub3B0aW9ucy5oZl90b2tlbn1gO1xuICAgIH1cbiAgICBsZXQgcm9vdF91cmw7XG4gICAgbGV0IGNvbXBvbmVudCA9IHRoaXMuY29uZmlnLmNvbXBvbmVudHMuZmluZChcbiAgICAgIChjb21wKSA9PiBjb21wLmlkID09PSBjb21wb25lbnRfaWRcbiAgICApO1xuICAgIGlmICgoX2EgPSBjb21wb25lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbXBvbmVudC5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJvb3RfdXJsKSB7XG4gICAgICByb290X3VybCA9IGNvbXBvbmVudC5wcm9wcy5yb290X3VybDtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdF91cmwgPSB0aGlzLmNvbmZpZy5yb290O1xuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICBpZiAoXCJiaW5hcnlcIiBpbiBkYXRhKSB7XG4gICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhLmRhdGEpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJiaW5hcnlcIilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYm9keS5hcHBlbmQoa2V5LCBkYXRhLmRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICBib2R5LnNldChcImNvbXBvbmVudF9pZFwiLCBjb21wb25lbnRfaWQudG9TdHJpbmcoKSk7XG4gICAgICBib2R5LnNldChcImZuX25hbWVcIiwgZm5fbmFtZSk7XG4gICAgICBib2R5LnNldChcInNlc3Npb25faGFzaFwiLCBzZXNzaW9uX2hhc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBjb21wb25lbnRfaWQsXG4gICAgICAgIGZuX25hbWUsXG4gICAgICAgIHNlc3Npb25faGFzaFxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgfVxuICAgIGlmIChoZl90b2tlbikge1xuICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2hmX3Rva2VufWA7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goXG4gICAgICAgIGAke3Jvb3RfdXJsfSR7dGhpcy5hcGlfcHJlZml4fS8ke0NPTVBPTkVOVF9TRVJWRVJfVVJMfS9gLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNvdWxkIG5vdCBjb25uZWN0IHRvIGNvbXBvbmVudCBzZXJ2ZXI6IFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICB9XG4gIHNldF9jb29raWVzKHJhd19jb29raWVzKSB7XG4gICAgdGhpcy5jb29raWVzID0gcGFyc2VfYW5kX3NldF9jb29raWVzKHJhd19jb29raWVzKS5qb2luKFwiOyBcIik7XG4gIH1cbiAgcHJlcGFyZV9yZXR1cm5fb2JqKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgcHJlZGljdDogdGhpcy5wcmVkaWN0LFxuICAgICAgc3VibWl0OiB0aGlzLnN1Ym1pdCxcbiAgICAgIHZpZXdfYXBpOiB0aGlzLnZpZXdfYXBpLFxuICAgICAgY29tcG9uZW50X3NlcnZlcjogdGhpcy5jb21wb25lbnRfc2VydmVyXG4gICAgfTtcbiAgfVxuICBhc3luYyBjb25uZWN0X3dzKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgd3M7XG4gICAgICB0cnkge1xuICAgICAgICB3cyA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy53c19tYXBbdXJsXSA9IFwiZmFpbGVkXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3NfbWFwW3VybF0gPSBcInBlbmRpbmdcIjtcbiAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgdGhpcy53c19tYXBbdXJsXSA9IHdzO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgd3Mub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiV2ViU29ja2V0IGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgIHRoaXMuY2xvc2Vfd3ModXJsKTtcbiAgICAgICAgdGhpcy53c19tYXBbdXJsXSA9IFwiZmFpbGVkXCI7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB3cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLndzX21hcFt1cmxdID0gXCJjbG9zZWRcIjtcbiAgICAgIH07XG4gICAgICB3cy5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2VuZF93c19tZXNzYWdlKHVybCwgZGF0YSkge1xuICAgIGlmICghKHVybCBpbiB0aGlzLndzX21hcCkpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdF93cyh1cmwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy53c19tYXBbdXJsXSA9PT0gXCJwZW5kaW5nXCIgfHwgdGhpcy53c19tYXBbdXJsXSA9PT0gXCJjbG9zZWRcIiB8fCB0aGlzLndzX21hcFt1cmxdID09PSBcImZhaWxlZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdzID0gdGhpcy53c19tYXBbdXJsXTtcbiAgICBpZiAod3MgaW5zdGFuY2VvZiBXZWJTb2NrZXQpIHtcbiAgICAgIHdzLnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvc3RfZGF0YSh1cmwsIGRhdGEpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjbG9zZV93cyh1cmwpIHtcbiAgICBpZiAodXJsIGluIHRoaXMud3NfbWFwKSB7XG4gICAgICBjb25zdCB3cyA9IHRoaXMud3NfbWFwW3VybF07XG4gICAgICBpZiAod3MgaW5zdGFuY2VvZiBXZWJTb2NrZXQpIHtcbiAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMud3NfbWFwW3VybF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjbGllbnQoYXBwX3JlZmVyZW5jZSwgb3B0aW9ucyA9IHtcbiAgZXZlbnRzOiBbXCJkYXRhXCJdXG59KSB7XG4gIHJldHVybiBhd2FpdCBDbGllbnQuY29ubmVjdChhcHBfcmVmZXJlbmNlLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGR1cGxpY2F0ZV9zcGFjZShhcHBfcmVmZXJlbmNlLCBvcHRpb25zKSB7XG4gIHJldHVybiBhd2FpdCBDbGllbnQuZHVwbGljYXRlKGFwcF9yZWZlcmVuY2UsIG9wdGlvbnMpO1xufVxuZXhwb3J0IHtcbiAgQ2xpZW50LFxuICBGaWxlRGF0YSxcbiAgTUlTU0lOR19DUkVERU5USUFMU19NU0csXG4gIGNsaWVudCxcbiAgZHVwbGljYXRlX3NwYWNlIGFzIGR1cGxpY2F0ZSxcbiAgaGFuZGxlX2ZpbGUsXG4gIHByZWRpY3QsXG4gIHByZXBhcmVfZmlsZXMsXG4gIHN1Ym1pdCxcbiAgdXBsb2FkLFxuICB1cGxvYWRfZmlsZXNcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@gradio/client/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@gradio/client/dist/wrapper-CviSselG.js":
/*!**************************************************************!*\
  !*** ./node_modules/@gradio/client/dist/wrapper-CviSselG.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* binding */ receiver$1),\n/* harmony export */   Sender: () => (/* binding */ sender$1),\n/* harmony export */   WebSocket: () => (/* binding */ WebSocket$2),\n/* harmony export */   WebSocketServer: () => (/* binding */ websocketServer$1),\n/* harmony export */   createWebSocketStream: () => (/* binding */ stream$1),\n/* harmony export */   \"default\": () => (/* binding */ WebSocket$2)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var tls__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tls */ \"tls\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! url */ \"url\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule)\n    return n;\n  var f = n.default;\n  if (typeof f == \"function\") {\n    var a = function a2() {\n      if (this instanceof a2) {\n        return Reflect.construct(f, arguments, this.constructor);\n      }\n      return f.apply(this, arguments);\n    };\n    a.prototype = f.prototype;\n  } else\n    a = {};\n  Object.defineProperty(a, \"__esModule\", { value: true });\n  Object.keys(n).forEach(function(k) {\n    var d = Object.getOwnPropertyDescriptor(n, k);\n    Object.defineProperty(a, k, d.get ? d : {\n      enumerable: true,\n      get: function() {\n        return n[k];\n      }\n    });\n  });\n  return a;\n}\nconst { Duplex } = stream__WEBPACK_IMPORTED_MODULE_0__;\nfunction emitClose$1(stream2) {\n  stream2.emit(\"close\");\n}\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\nfunction duplexOnError(err) {\n  this.removeListener(\"error\", duplexOnError);\n  this.destroy();\n  if (this.listenerCount(\"error\") === 0) {\n    this.emit(\"error\", err);\n  }\n}\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on(\"message\", function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data))\n      ws.pause();\n  });\n  ws.once(\"error\", function error2(err) {\n    if (duplex.destroyed)\n      return;\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once(\"close\", function close() {\n    if (duplex.destroyed)\n      return;\n    duplex.push(null);\n  });\n  duplex._destroy = function(err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose$1, duplex);\n      return;\n    }\n    let called = false;\n    ws.once(\"error\", function error2(err2) {\n      called = true;\n      callback(err2);\n    });\n    ws.once(\"close\", function close() {\n      if (!called)\n        callback(err);\n      process.nextTick(emitClose$1, duplex);\n    });\n    if (terminateOnDestroy)\n      ws.terminate();\n  };\n  duplex._final = function(callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n    if (ws._socket === null)\n      return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted)\n        duplex.destroy();\n    } else {\n      ws._socket.once(\"finish\", function finish() {\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function() {\n    if (ws.isPaused)\n      ws.resume();\n  };\n  duplex._write = function(chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on(\"end\", duplexOnEnd);\n  duplex.on(\"error\", duplexOnError);\n  return duplex;\n}\nvar stream = createWebSocketStream;\nconst stream$1 = /* @__PURE__ */ getDefaultExportFromCjs(stream);\nvar bufferUtil$1 = { exports: {} };\nvar constants = {\n  BINARY_TYPES: [\"nodebuffer\", \"arraybuffer\", \"fragments\"],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n  kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n  kListener: Symbol(\"kListener\"),\n  kStatusCode: Symbol(\"status-code\"),\n  kWebSocket: Symbol(\"websocket\"),\n  NOOP: () => {\n  }\n};\nvar bufferutil = { exports: {} };\nvar nodeGypBuild$1 = { exports: {} };\nfunction commonjsRequire(path) {\n  throw new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar nodeGypBuild;\nvar hasRequiredNodeGypBuild$1;\nfunction requireNodeGypBuild$1() {\n  if (hasRequiredNodeGypBuild$1)\n    return nodeGypBuild;\n  hasRequiredNodeGypBuild$1 = 1;\n  var fs = fs__WEBPACK_IMPORTED_MODULE_2__;\n  var path = path__WEBPACK_IMPORTED_MODULE_3__;\n  var os = os__WEBPACK_IMPORTED_MODULE_4__;\n  var runtimeRequire =  true ? require : 0;\n  var vars = process.config && process.config.variables || {};\n  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;\n  var abi = process.versions.modules;\n  var runtime = isElectron() ? \"electron\" : isNwjs() ? \"node-webkit\" : \"node\";\n  var arch = process.env.npm_config_arch || os.arch();\n  var platform = process.env.npm_config_platform || os.platform();\n  var libc = process.env.LIBC || (isAlpine(platform) ? \"musl\" : \"glibc\");\n  var armv = process.env.ARM_VERSION || (arch === \"arm64\" ? \"8\" : vars.arm_version) || \"\";\n  var uv = (process.versions.uv || \"\").split(\".\")[0];\n  nodeGypBuild = load;\n  function load(dir) {\n    return runtimeRequire(load.resolve(dir));\n  }\n  load.resolve = load.path = function(dir) {\n    dir = path.resolve(dir || \".\");\n    try {\n      var name = runtimeRequire(path.join(dir, \"package.json\")).name.toUpperCase().replace(/-/g, \"_\");\n      if (process.env[name + \"_PREBUILD\"])\n        dir = process.env[name + \"_PREBUILD\"];\n    } catch (err) {\n    }\n    if (!prebuildsOnly) {\n      var release = getFirst(path.join(dir, \"build/Release\"), matchBuild);\n      if (release)\n        return release;\n      var debug = getFirst(path.join(dir, \"build/Debug\"), matchBuild);\n      if (debug)\n        return debug;\n    }\n    var prebuild = resolve(dir);\n    if (prebuild)\n      return prebuild;\n    var nearby = resolve(path.dirname(process.execPath));\n    if (nearby)\n      return nearby;\n    var target = [\n      \"platform=\" + platform,\n      \"arch=\" + arch,\n      \"runtime=\" + runtime,\n      \"abi=\" + abi,\n      \"uv=\" + uv,\n      armv ? \"armv=\" + armv : \"\",\n      \"libc=\" + libc,\n      \"node=\" + process.versions.node,\n      process.versions.electron ? \"electron=\" + process.versions.electron : \"\",\n       true ? \"webpack=true\" : 0\n      // eslint-disable-line\n    ].filter(Boolean).join(\" \");\n    throw new Error(\"No native build was found for \" + target + \"\\n    loaded from: \" + dir + \"\\n\");\n    function resolve(dir2) {\n      var tuples = readdirSync(path.join(dir2, \"prebuilds\")).map(parseTuple);\n      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];\n      if (!tuple)\n        return;\n      var prebuilds = path.join(dir2, \"prebuilds\", tuple.name);\n      var parsed = readdirSync(prebuilds).map(parseTags);\n      var candidates = parsed.filter(matchTags(runtime, abi));\n      var winner = candidates.sort(compareTags(runtime))[0];\n      if (winner)\n        return path.join(prebuilds, winner.file);\n    }\n  };\n  function readdirSync(dir) {\n    try {\n      return fs.readdirSync(dir);\n    } catch (err) {\n      return [];\n    }\n  }\n  function getFirst(dir, filter) {\n    var files = readdirSync(dir).filter(filter);\n    return files[0] && path.join(dir, files[0]);\n  }\n  function matchBuild(name) {\n    return /\\.node$/.test(name);\n  }\n  function parseTuple(name) {\n    var arr = name.split(\"-\");\n    if (arr.length !== 2)\n      return;\n    var platform2 = arr[0];\n    var architectures = arr[1].split(\"+\");\n    if (!platform2)\n      return;\n    if (!architectures.length)\n      return;\n    if (!architectures.every(Boolean))\n      return;\n    return { name, platform: platform2, architectures };\n  }\n  function matchTuple(platform2, arch2) {\n    return function(tuple) {\n      if (tuple == null)\n        return false;\n      if (tuple.platform !== platform2)\n        return false;\n      return tuple.architectures.includes(arch2);\n    };\n  }\n  function compareTuples(a, b) {\n    return a.architectures.length - b.architectures.length;\n  }\n  function parseTags(file) {\n    var arr = file.split(\".\");\n    var extension2 = arr.pop();\n    var tags = { file, specificity: 0 };\n    if (extension2 !== \"node\")\n      return;\n    for (var i = 0; i < arr.length; i++) {\n      var tag = arr[i];\n      if (tag === \"node\" || tag === \"electron\" || tag === \"node-webkit\") {\n        tags.runtime = tag;\n      } else if (tag === \"napi\") {\n        tags.napi = true;\n      } else if (tag.slice(0, 3) === \"abi\") {\n        tags.abi = tag.slice(3);\n      } else if (tag.slice(0, 2) === \"uv\") {\n        tags.uv = tag.slice(2);\n      } else if (tag.slice(0, 4) === \"armv\") {\n        tags.armv = tag.slice(4);\n      } else if (tag === \"glibc\" || tag === \"musl\") {\n        tags.libc = tag;\n      } else {\n        continue;\n      }\n      tags.specificity++;\n    }\n    return tags;\n  }\n  function matchTags(runtime2, abi2) {\n    return function(tags) {\n      if (tags == null)\n        return false;\n      if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))\n        return false;\n      if (tags.abi !== abi2 && !tags.napi)\n        return false;\n      if (tags.uv && tags.uv !== uv)\n        return false;\n      if (tags.armv && tags.armv !== armv)\n        return false;\n      if (tags.libc && tags.libc !== libc)\n        return false;\n      return true;\n    };\n  }\n  function runtimeAgnostic(tags) {\n    return tags.runtime === \"node\" && tags.napi;\n  }\n  function compareTags(runtime2) {\n    return function(a, b) {\n      if (a.runtime !== b.runtime) {\n        return a.runtime === runtime2 ? -1 : 1;\n      } else if (a.abi !== b.abi) {\n        return a.abi ? -1 : 1;\n      } else if (a.specificity !== b.specificity) {\n        return a.specificity > b.specificity ? -1 : 1;\n      } else {\n        return 0;\n      }\n    };\n  }\n  function isNwjs() {\n    return !!(process.versions && process.versions.nw);\n  }\n  function isElectron() {\n    if (process.versions && process.versions.electron)\n      return true;\n    if (process.env.ELECTRON_RUN_AS_NODE)\n      return true;\n    return typeof window !== \"undefined\" && window.process && window.process.type === \"renderer\";\n  }\n  function isAlpine(platform2) {\n    return platform2 === \"linux\" && fs.existsSync(\"/etc/alpine-release\");\n  }\n  load.parseTags = parseTags;\n  load.matchTags = matchTags;\n  load.compareTags = compareTags;\n  load.parseTuple = parseTuple;\n  load.matchTuple = matchTuple;\n  load.compareTuples = compareTuples;\n  return nodeGypBuild;\n}\nvar hasRequiredNodeGypBuild;\nfunction requireNodeGypBuild() {\n  if (hasRequiredNodeGypBuild)\n    return nodeGypBuild$1.exports;\n  hasRequiredNodeGypBuild = 1;\n  if (typeof process.addon === \"function\") {\n    nodeGypBuild$1.exports = process.addon.bind(process);\n  } else {\n    nodeGypBuild$1.exports = requireNodeGypBuild$1();\n  }\n  return nodeGypBuild$1.exports;\n}\nvar fallback;\nvar hasRequiredFallback;\nfunction requireFallback() {\n  if (hasRequiredFallback)\n    return fallback;\n  hasRequiredFallback = 1;\n  const mask2 = (source, mask3, output, offset, length) => {\n    for (var i = 0; i < length; i++) {\n      output[offset + i] = source[i] ^ mask3[i & 3];\n    }\n  };\n  const unmask2 = (buffer, mask3) => {\n    const length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] ^= mask3[i & 3];\n    }\n  };\n  fallback = { mask: mask2, unmask: unmask2 };\n  return fallback;\n}\nvar hasRequiredBufferutil;\nfunction requireBufferutil() {\n  if (hasRequiredBufferutil)\n    return bufferutil.exports;\n  hasRequiredBufferutil = 1;\n  try {\n    bufferutil.exports = requireNodeGypBuild()(__dirname);\n  } catch (e) {\n    bufferutil.exports = requireFallback();\n  }\n  return bufferutil.exports;\n}\nvar unmask$1;\nvar mask;\nconst { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;\nconst FastBuffer$2 = Buffer[Symbol.species];\nfunction concat$1(list, totalLength) {\n  if (list.length === 0)\n    return EMPTY_BUFFER$3;\n  if (list.length === 1)\n    return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) {\n    return new FastBuffer$2(target.buffer, target.byteOffset, offset);\n  }\n  return target;\n}\nfunction _mask(source, mask2, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask2[i & 3];\n  }\n}\nfunction _unmask(buffer, mask2) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask2[i & 3];\n  }\n}\nfunction toArrayBuffer$1(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\nfunction toBuffer$2(data) {\n  toBuffer$2.readOnly = true;\n  if (Buffer.isBuffer(data))\n    return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer$2(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer$2.readOnly = false;\n  }\n  return buf;\n}\nbufferUtil$1.exports = {\n  concat: concat$1,\n  mask: _mask,\n  toArrayBuffer: toArrayBuffer$1,\n  toBuffer: toBuffer$2,\n  unmask: _unmask\n};\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil2 = requireBufferutil();\n    mask = bufferUtil$1.exports.mask = function(source, mask2, output, offset, length) {\n      if (length < 48)\n        _mask(source, mask2, output, offset, length);\n      else\n        bufferUtil2.mask(source, mask2, output, offset, length);\n    };\n    unmask$1 = bufferUtil$1.exports.unmask = function(buffer, mask2) {\n      if (buffer.length < 32)\n        _unmask(buffer, mask2);\n      else\n        bufferUtil2.unmask(buffer, mask2);\n    };\n  } catch (e) {\n  }\n}\nvar bufferUtilExports = bufferUtil$1.exports;\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\nlet Limiter$1 = class Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency)\n      return;\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n};\nvar limiter = Limiter$1;\nconst zlib = zlib__WEBPACK_IMPORTED_MODULE_1__;\nconst bufferUtil = bufferUtilExports;\nconst Limiter2 = limiter;\nconst { kStatusCode: kStatusCode$2 } = constants;\nconst FastBuffer$1 = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0, 0, 255, 255]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError$1 = Symbol(\"error\");\nlet zlibLimiter;\nlet PerMessageDeflate$4 = class PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter2(concurrency);\n    }\n  }\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return \"permessage-deflate\";\n  }\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n    return params;\n  }\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n      this._deflate.close();\n      this._deflate = null;\n      if (callback) {\n        callback(\n          new Error(\n            \"The deflate stream was closed while data was being processed\"\n          )\n        );\n      }\n    }\n  }\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n        return false;\n      }\n      return true;\n    });\n    if (!accepted) {\n      throw new Error(\"None of the extension offers can be accepted\");\n    }\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === \"number\") {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === \"number\") {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n    return accepted;\n  }\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === \"number\") {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n    return params;\n  }\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n        value = value[0];\n        if (key === \"client_max_window_bits\") {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === \"server_max_window_bits\") {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? \"client\" : \"server\";\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on(\"error\", inflateOnError);\n      this._inflate.on(\"data\", inflateOnData);\n    }\n    this._inflate[kCallback] = callback;\n    this._inflate.write(data);\n    if (fin)\n      this._inflate.write(TRAILER);\n    this._inflate.flush(() => {\n      const err = this._inflate[kError$1];\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n      const data2 = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n      callback(null, data2);\n    });\n  }\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? \"server\" : \"client\";\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      this._deflate.on(\"data\", deflateOnData);\n    }\n    this._deflate[kCallback] = callback;\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        return;\n      }\n      let data2 = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n      if (fin) {\n        data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);\n      }\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n      callback(null, data2);\n    });\n  }\n};\nvar permessageDeflate = PerMessageDeflate$4;\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n  this[kError$1] = new RangeError(\"Max payload size exceeded\");\n  this[kError$1].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n  this[kError$1][kStatusCode$2] = 1009;\n  this.removeListener(\"data\", inflateOnData);\n  this.reset();\n}\nfunction inflateOnError(err) {\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode$2] = 1007;\n  this[kCallback](err);\n}\nvar validation = { exports: {} };\nconst __viteOptionalPeerDep_utf8Validate_ws = {};\nconst __viteOptionalPeerDep_utf8Validate_ws$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: __viteOptionalPeerDep_utf8Validate_ws\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst require$$1 = /* @__PURE__ */ getAugmentedNamespace(__viteOptionalPeerDep_utf8Validate_ws$1);\nvar isValidUTF8_1;\nconst { isUtf8 } = buffer__WEBPACK_IMPORTED_MODULE_5__;\nconst tokenChars$2 = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 0 - 15\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 16 - 31\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  0,\n  // 32 - 47\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 48 - 63\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  // 64 - 79\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  1,\n  // 80 - 95\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  // 96 - 111\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  1,\n  0,\n  1,\n  0\n  // 112 - 127\n];\nfunction isValidStatusCode$2(code) {\n  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;\n}\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 128) === 0) {\n      i++;\n    } else if ((buf[i] & 224) === 192) {\n      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 240) === 224) {\n      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong\n      buf[i] === 237 && (buf[i + 1] & 224) === 160) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 248) === 240) {\n      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong\n      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nvalidation.exports = {\n  isValidStatusCode: isValidStatusCode$2,\n  isValidUTF8: _isValidUTF8,\n  tokenChars: tokenChars$2\n};\nif (isUtf8) {\n  isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF82 = require$$1;\n    isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);\n    };\n  } catch (e) {\n  }\n}\nvar validationExports = validation.exports;\nconst { Writable } = stream__WEBPACK_IMPORTED_MODULE_0__;\nconst PerMessageDeflate$3 = permessageDeflate;\nconst {\n  BINARY_TYPES: BINARY_TYPES$1,\n  EMPTY_BUFFER: EMPTY_BUFFER$2,\n  kStatusCode: kStatusCode$1,\n  kWebSocket: kWebSocket$2\n} = constants;\nconst { concat, toArrayBuffer, unmask } = bufferUtilExports;\nconst { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nlet Receiver$1 = class Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._binaryType = options.binaryType || BINARY_TYPES$1[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket$2] = void 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = void 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 8 && this._state == GET_INFO)\n      return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length)\n      return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    cb(err);\n  }\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 48) !== 0) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"RSV2 and RSV3 must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_RSV_2_3\"\n      );\n    }\n    const compressed = (buf[0] & 64) === 64;\n    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"RSV1 must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_RSV_1\"\n      );\n    }\n    this._fin = (buf[0] & 128) === 128;\n    this._opcode = buf[0] & 15;\n    this._payloadLength = buf[1] & 127;\n    if (this._opcode === 0) {\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"RSV1 must be clear\",\n          true,\n          1002,\n          \"WS_ERR_UNEXPECTED_RSV_1\"\n        );\n      }\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"invalid opcode 0\",\n          true,\n          1002,\n          \"WS_ERR_INVALID_OPCODE\"\n        );\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 1 || this._opcode === 2) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          \"WS_ERR_INVALID_OPCODE\"\n        );\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 7 && this._opcode < 11) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"FIN must be set\",\n          true,\n          1002,\n          \"WS_ERR_EXPECTED_FIN\"\n        );\n      }\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"RSV1 must be clear\",\n          true,\n          1002,\n          \"WS_ERR_UNEXPECTED_RSV_1\"\n        );\n      }\n      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\"\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        \"WS_ERR_INVALID_OPCODE\"\n      );\n    }\n    if (!this._fin && !this._fragmented)\n      this._fragmented = this._opcode;\n    this._masked = (buf[1] & 128) === 128;\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"MASK must be set\",\n          true,\n          1002,\n          \"WS_ERR_EXPECTED_MASK\"\n        );\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"MASK must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_MASK\"\n      );\n    }\n    if (this._payloadLength === 126)\n      this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127)\n      this._state = GET_PAYLOAD_LENGTH_64;\n    else\n      return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"Unsupported WebSocket frame: payload length > 2^53 - 1\",\n        false,\n        1009,\n        \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\"\n      );\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 8) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"Max payload size exceeded\",\n          false,\n          1009,\n          \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n        );\n      }\n    }\n    if (this._masked)\n      this._state = GET_MASK;\n    else\n      this._state = GET_DATA;\n  }\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER$2;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 7)\n      return this.controlMessage(data);\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    return this.dataMessage();\n  }\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err)\n        return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(\n              RangeError,\n              \"Max payload size exceeded\",\n              false,\n              1009,\n              \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n            )\n          );\n        }\n        this._fragments.push(buf);\n      }\n      const er = this.dataMessage();\n      if (er)\n        return cb(er);\n      this.startLoop(cb);\n    });\n  }\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n      if (this._opcode === 2) {\n        let data;\n        if (this._binaryType === \"nodebuffer\") {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === \"arraybuffer\") {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n        this.emit(\"message\", data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(\n            Error,\n            \"invalid UTF-8 sequence\",\n            true,\n            1007,\n            \"WS_ERR_INVALID_UTF8\"\n          );\n        }\n        this.emit(\"message\", buf, false);\n      }\n    }\n    this._state = GET_INFO;\n  }\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 8) {\n      this._loop = false;\n      if (data.length === 0) {\n        this.emit(\"conclude\", 1005, EMPTY_BUFFER$2);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode$1(code)) {\n          return error(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            \"WS_ERR_INVALID_CLOSE_CODE\"\n          );\n        }\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(\n            Error,\n            \"invalid UTF-8 sequence\",\n            true,\n            1007,\n            \"WS_ERR_INVALID_UTF8\"\n          );\n        }\n        this.emit(\"conclude\", code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 9) {\n      this.emit(\"ping\", data);\n    } else {\n      this.emit(\"pong\", data);\n    }\n    this._state = GET_INFO;\n  }\n};\nvar receiver = Receiver$1;\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode$1] = statusCode;\n  return err;\n}\nconst receiver$1 = /* @__PURE__ */ getDefaultExportFromCjs(receiver);\nconst { randomFillSync } = crypto__WEBPACK_IMPORTED_MODULE_8__;\nconst PerMessageDeflate$2 = permessageDeflate;\nconst { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants;\nconst { isValidStatusCode } = validationExports;\nconst { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nlet Sender$1 = class Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask2;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n    if (options.mask) {\n      mask2 = options.maskBuffer || maskBuffer;\n      if (options.generateMask) {\n        options.generateMask(mask2);\n      } else {\n        randomFillSync(mask2, 0, 4);\n      }\n      skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;\n      offset = 6;\n    }\n    let dataLength;\n    if (typeof data === \"string\") {\n      if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n    let payloadLength = dataLength;\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n    target[0] = options.fin ? options.opcode | 128 : options.opcode;\n    if (options.rsv1)\n      target[0] |= 64;\n    target[1] = payloadLength;\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n    if (!options.mask)\n      return [target, data];\n    target[1] |= 128;\n    target[offset - 4] = mask2[0];\n    target[offset - 3] = mask2[1];\n    target[offset - 2] = mask2[2];\n    target[offset - 1] = mask2[3];\n    if (skipMasking)\n      return [target, data];\n    if (merge) {\n      applyMask(data, mask2, target, offset, dataLength);\n      return [target];\n    }\n    applyMask(data, mask2, data, 0, dataLength);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask2, cb) {\n    let buf;\n    if (code === void 0) {\n      buf = EMPTY_BUFFER$1;\n    } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n      throw new TypeError(\"First argument must be a valid error code number\");\n    } else if (data === void 0 || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n      if (length > 123) {\n        throw new RangeError(\"The message must not be greater than 123 bytes\");\n      }\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      if (typeof data === \"string\") {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 8,\n      readOnly: false,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 9,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 10,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n    if (options.fin)\n      this._firstFragment = true;\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          \"The socket was closed while data was being compressed\"\n        );\n        if (typeof cb === \"function\")\n          cb(err);\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n          if (typeof callback === \"function\")\n            callback(err);\n        }\n        return;\n      }\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n};\nvar sender = Sender$1;\nconst sender$1 = /* @__PURE__ */ getDefaultExportFromCjs(sender);\nconst { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, \"target\", { enumerable: true });\nObject.defineProperty(Event.prototype, \"type\", { enumerable: true });\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === void 0 ? 0 : options.code;\n    this[kReason] = options.reason === void 0 ? \"\" : options.reason;\n    this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;\n  }\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, \"reason\", { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", { enumerable: true });\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === void 0 ? null : options.error;\n    this[kMessage] = options.message === void 0 ? \"\" : options.message;\n  }\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, \"message\", { enumerable: true });\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === void 0 ? null : options.data;\n  }\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", { enumerable: true });\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        return;\n      }\n    }\n    let wrapper;\n    if (type === \"message\") {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent(\"message\", {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"close\") {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent(\"close\", {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"error\") {\n      wrapper = function onError(error2) {\n        const event = new ErrorEvent(\"error\", {\n          error: error2,\n          message: error2.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"open\") {\n      wrapper = function onOpen() {\n        const event = new Event(\"open\");\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];\n    wrapper[kListener$1] = handler;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nvar eventTarget = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === \"object\" && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\nconst { tokenChars: tokenChars$1 } = validationExports;\nfunction push(dest, name, elem) {\n  if (dest[name] === void 0)\n    dest[name] = [elem];\n  else\n    dest[name].push(elem);\n}\nfunction parse$2(header) {\n  const offers = /* @__PURE__ */ Object.create(null);\n  let params = /* @__PURE__ */ Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n    if (extensionName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (i !== 0 && (code === 32 || code === 9)) {\n        if (end === -1 && start !== -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        const name = header.slice(start, end);\n        if (code === 44) {\n          push(offers, name, params);\n          params = /* @__PURE__ */ Object.create(null);\n        } else {\n          extensionName = name;\n        }\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (code === 32 || code === 9) {\n        if (end === -1 && start !== -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */ Object.create(null);\n          extensionName = void 0;\n        }\n        start = end = -1;\n      } else if (code === 61 && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      if (isEscaping) {\n        if (tokenChars$1[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1)\n          start = i;\n        else if (!mustUnescape)\n          mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars$1[code] === 1) {\n          if (start === -1)\n            start = i;\n        } else if (code === 34 && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 92) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (start !== -1 && (code === 32 || code === 9)) {\n        if (end === -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, \"\");\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */ Object.create(null);\n          extensionName = void 0;\n        }\n        paramName = void 0;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n  if (start === -1 || inQuotes || code === 32 || code === 9) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  if (end === -1)\n    end = i;\n  const token = header.slice(start, end);\n  if (extensionName === void 0) {\n    push(offers, token, params);\n  } else {\n    if (paramName === void 0) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, \"\"));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n  return offers;\n}\nfunction format$1(extensions) {\n  return Object.keys(extensions).map((extension2) => {\n    let configurations = extensions[extension2];\n    if (!Array.isArray(configurations))\n      configurations = [configurations];\n    return configurations.map((params) => {\n      return [extension2].concat(\n        Object.keys(params).map((k) => {\n          let values = params[k];\n          if (!Array.isArray(values))\n            values = [values];\n          return values.map((v) => v === true ? k : `${k}=${v}`).join(\"; \");\n        })\n      ).join(\"; \");\n    }).join(\", \");\n  }).join(\", \");\n}\nvar extension$1 = { format: format$1, parse: parse$2 };\nconst EventEmitter$1 = events__WEBPACK_IMPORTED_MODULE_9__;\nconst https = https__WEBPACK_IMPORTED_MODULE_10__;\nconst http$1 = http__WEBPACK_IMPORTED_MODULE_11__;\nconst net = net__WEBPACK_IMPORTED_MODULE_6__;\nconst tls = tls__WEBPACK_IMPORTED_MODULE_7__;\nconst { randomBytes, createHash: createHash$1 } = crypto__WEBPACK_IMPORTED_MODULE_8__;\nconst { URL } = url__WEBPACK_IMPORTED_MODULE_12__;\nconst PerMessageDeflate$1 = permessageDeflate;\nconst Receiver2 = receiver;\nconst Sender2 = sender;\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID: GUID$1,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket: kWebSocket$1,\n  NOOP\n} = constants;\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = eventTarget;\nconst { format, parse: parse$1 } = extension$1;\nconst { toBuffer } = bufferUtilExports;\nconst closeTimeout = 30 * 1e3;\nconst kAborted = Symbol(\"kAborted\");\nconst protocolVersions = [8, 13];\nconst readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nlet WebSocket$1 = class WebSocket extends EventEmitter$1 {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = \"\";\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === void 0) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === \"object\" && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type))\n      return;\n    this._binaryType = type;\n    if (this._receiver)\n      this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket)\n      return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver2 = new Receiver2({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    this._sender = new Sender2(socket, this._extensions, options.generateMask);\n    this._receiver = receiver2;\n    this._socket = socket;\n    receiver2[kWebSocket$1] = this;\n    socket[kWebSocket$1] = this;\n    receiver2.on(\"conclude\", receiverOnConclude);\n    receiver2.on(\"drain\", receiverOnDrain);\n    receiver2.on(\"error\", receiverOnError);\n    receiver2.on(\"message\", receiverOnMessage);\n    receiver2.on(\"ping\", receiverOnPing);\n    receiver2.on(\"pong\", receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0)\n      socket.unshift(head);\n    socket.on(\"close\", socketOnClose);\n    socket.on(\"data\", socketOnData);\n    socket.on(\"end\", socketOnEnd);\n    socket.on(\"error\", socketOnError$1);\n    this._readyState = WebSocket.OPEN;\n    this.emit(\"open\");\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit(\"close\", this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate$1.extensionName]) {\n      this._extensions[PerMessageDeflate$1.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit(\"close\", this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED)\n      return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      if (err)\n        return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0)\n      mask2 = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0)\n      mask2 = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain)\n      this._socket.resume();\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof options === \"function\") {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = {\n      binary: typeof data !== \"string\",\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n    if (!this._extensions[PerMessageDeflate$1.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED)\n      return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n};\nObject.defineProperty(WebSocket$1, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\n[\n  \"binaryType\",\n  \"bufferedAmount\",\n  \"extensions\",\n  \"isPaused\",\n  \"protocol\",\n  \"readyState\",\n  \"url\"\n].forEach((property) => {\n  Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });\n});\n[\"open\", \"error\", \"close\", \"message\"].forEach((method) => {\n  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute])\n          return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== \"function\")\n        return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket$1.prototype.addEventListener = addEventListener;\nWebSocket$1.prototype.removeEventListener = removeEventListener;\nvar websocket = WebSocket$1;\nfunction initAsClient(websocket2, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: void 0,\n    socketPath: void 0,\n    hostname: void 0,\n    protocol: void 0,\n    timeout: void 0,\n    method: \"GET\",\n    host: void 0,\n    path: void 0,\n    port: void 0\n  };\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(\", \")})`\n    );\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket2._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n    websocket2._url = address;\n  }\n  const isSecure = parsedUrl.protocol === \"wss:\";\n  const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n  let invalidUrlMessage;\n  if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = `The URL's protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"`;\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = \"The URL contains a fragment identifier\";\n  }\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n    if (websocket2._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket2, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString(\"base64\");\n  const request = isSecure ? https.request : http$1.request;\n  const protocolSet = /* @__PURE__ */ new Set();\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    \"Sec-WebSocket-Version\": opts.protocolVersion,\n    \"Sec-WebSocket-Key\": key,\n    Connection: \"Upgrade\",\n    Upgrade: \"websocket\"\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate$1(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError(\n          \"An invalid or duplicated subprotocol was specified\"\n        );\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    const parts = opts.path.split(\":\");\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  let req;\n  if (opts.followRedirects) {\n    if (websocket2._redirects === 0) {\n      websocket2._originalIpc = isIpcUrl;\n      websocket2._originalSecure = isSecure;\n      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers;\n      options = { ...options, headers: {} };\n      if (headers) {\n        for (const [key2, value] of Object.entries(headers)) {\n          options.headers[key2.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket2.listenerCount(\"redirect\") === 0) {\n      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;\n      if (!isSameHost || websocket2._originalSecure && !isSecure) {\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost)\n          delete opts.headers.host;\n        opts.auth = void 0;\n      }\n    }\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n    }\n    req = websocket2._req = request(opts);\n    if (websocket2._redirects) {\n      websocket2.emit(\"redirect\", websocket2.url, req);\n    }\n  } else {\n    req = websocket2._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on(\"timeout\", () => {\n      abortHandshake$1(websocket2, req, \"Opening handshake has timed out\");\n    });\n  }\n  req.on(\"error\", (err) => {\n    if (req === null || req[kAborted])\n      return;\n    req = websocket2._req = null;\n    emitErrorAndClose(websocket2, err);\n  });\n  req.on(\"response\", (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket2._redirects > opts.maxRedirects) {\n        abortHandshake$1(websocket2, req, \"Maximum redirects exceeded\");\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket2, err);\n        return;\n      }\n      initAsClient(websocket2, addr, protocols, options);\n    } else if (!websocket2.emit(\"unexpected-response\", req, res)) {\n      abortHandshake$1(\n        websocket2,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n  req.on(\"upgrade\", (res, socket, head) => {\n    websocket2.emit(\"upgrade\", res);\n    if (websocket2.readyState !== WebSocket$1.CONNECTING)\n      return;\n    req = websocket2._req = null;\n    if (res.headers.upgrade.toLowerCase() !== \"websocket\") {\n      abortHandshake$1(websocket2, socket, \"Invalid Upgrade header\");\n      return;\n    }\n    const digest = createHash$1(\"sha1\").update(key + GUID$1).digest(\"base64\");\n    if (res.headers[\"sec-websocket-accept\"] !== digest) {\n      abortHandshake$1(websocket2, socket, \"Invalid Sec-WebSocket-Accept header\");\n      return;\n    }\n    const serverProt = res.headers[\"sec-websocket-protocol\"];\n    let protError;\n    if (serverProt !== void 0) {\n      if (!protocolSet.size) {\n        protError = \"Server sent a subprotocol but none was requested\";\n      } else if (!protocolSet.has(serverProt)) {\n        protError = \"Server sent an invalid subprotocol\";\n      }\n    } else if (protocolSet.size) {\n      protError = \"Server sent no subprotocol\";\n    }\n    if (protError) {\n      abortHandshake$1(websocket2, socket, protError);\n      return;\n    }\n    if (serverProt)\n      websocket2._protocol = serverProt;\n    const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n    if (secWebSocketExtensions !== void 0) {\n      if (!perMessageDeflate) {\n        const message = \"Server sent a Sec-WebSocket-Extensions header but no extension was requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse$1(secWebSocketExtensions);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {\n        const message = \"Server indicated an extension that was not requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;\n    }\n    websocket2.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket2);\n  } else {\n    req.end();\n  }\n}\nfunction emitErrorAndClose(websocket2, err) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2.emit(\"error\", err);\n  websocket2.emitClose();\n}\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\nfunction tlsConnect(options) {\n  options.path = void 0;\n  if (!options.servername && options.servername !== \"\") {\n    options.servername = net.isIP(options.host) ? \"\" : options.host;\n  }\n  return tls.connect(options);\n}\nfunction abortHandshake$1(websocket2, stream2, message) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake$1);\n  if (stream2.setHeader) {\n    stream2[kAborted] = true;\n    stream2.abort();\n    if (stream2.socket && !stream2.socket.destroyed) {\n      stream2.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket2, err);\n  } else {\n    stream2.destroy(err);\n    stream2.once(\"error\", websocket2.emit.bind(websocket2, \"error\"));\n    stream2.once(\"close\", websocket2.emitClose.bind(websocket2));\n  }\n}\nfunction sendAfterClose(websocket2, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n    if (websocket2._socket)\n      websocket2._sender._bufferedBytes += length;\n    else\n      websocket2._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\nfunction receiverOnConclude(code, reason) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._closeFrameReceived = true;\n  websocket2._closeMessage = reason;\n  websocket2._closeCode = code;\n  if (websocket2._socket[kWebSocket$1] === void 0)\n    return;\n  websocket2._socket.removeListener(\"data\", socketOnData);\n  process.nextTick(resume, websocket2._socket);\n  if (code === 1005)\n    websocket2.close();\n  else\n    websocket2.close(code, reason);\n}\nfunction receiverOnDrain() {\n  const websocket2 = this[kWebSocket$1];\n  if (!websocket2.isPaused)\n    websocket2._socket.resume();\n}\nfunction receiverOnError(err) {\n  const websocket2 = this[kWebSocket$1];\n  if (websocket2._socket[kWebSocket$1] !== void 0) {\n    websocket2._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket2._socket);\n    websocket2.close(err[kStatusCode]);\n  }\n  websocket2.emit(\"error\", err);\n}\nfunction receiverOnFinish() {\n  this[kWebSocket$1].emitClose();\n}\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket$1].emit(\"message\", data, isBinary);\n}\nfunction receiverOnPing(data) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2.pong(data, !websocket2._isServer, NOOP);\n  websocket2.emit(\"ping\", data);\n}\nfunction receiverOnPong(data) {\n  this[kWebSocket$1].emit(\"pong\", data);\n}\nfunction resume(stream2) {\n  stream2.resume();\n}\nfunction socketOnClose() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"close\", socketOnClose);\n  this.removeListener(\"data\", socketOnData);\n  this.removeListener(\"end\", socketOnEnd);\n  websocket2._readyState = WebSocket$1.CLOSING;\n  let chunk;\n  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {\n    websocket2._receiver.write(chunk);\n  }\n  websocket2._receiver.end();\n  this[kWebSocket$1] = void 0;\n  clearTimeout(websocket2._closeTimer);\n  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {\n    websocket2.emitClose();\n  } else {\n    websocket2._receiver.on(\"error\", receiverOnFinish);\n    websocket2._receiver.on(\"finish\", receiverOnFinish);\n  }\n}\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket$1]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\nfunction socketOnEnd() {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2._receiver.end();\n  this.end();\n}\nfunction socketOnError$1() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"error\", socketOnError$1);\n  this.on(\"error\", NOOP);\n  if (websocket2) {\n    websocket2._readyState = WebSocket$1.CLOSING;\n    this.destroy();\n  }\n}\nconst WebSocket$2 = /* @__PURE__ */ getDefaultExportFromCjs(websocket);\nconst { tokenChars } = validationExports;\nfunction parse(header) {\n  const protocols = /* @__PURE__ */ new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1)\n        start = i;\n    } else if (i !== 0 && (code === 32 || code === 9)) {\n      if (end === -1 && start !== -1)\n        end = i;\n    } else if (code === 44) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n      if (end === -1)\n        end = i;\n      const protocol2 = header.slice(start, end);\n      if (protocols.has(protocol2)) {\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol2);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n  protocols.add(protocol);\n  return protocols;\n}\nvar subprotocol$1 = { parse };\nconst EventEmitter = events__WEBPACK_IMPORTED_MODULE_9__;\nconst http = http__WEBPACK_IMPORTED_MODULE_11__;\nconst { createHash } = crypto__WEBPACK_IMPORTED_MODULE_8__;\nconst extension = extension$1;\nconst PerMessageDeflate2 = permessageDeflate;\nconst subprotocol = subprotocol$1;\nconst WebSocket2 = websocket;\nconst { GUID, kWebSocket } = constants;\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket: WebSocket2,\n      ...options\n    };\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          \"Content-Length\": body.length,\n          \"Content-Type\": \"text/plain\"\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, \"connection\");\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, \"listening\"),\n        error: this.emit.bind(this, \"error\"),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true)\n      options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = /* @__PURE__ */ new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server)\n      return null;\n    return this._server.address();\n  }\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once(\"close\", () => {\n          cb(new Error(\"The server is not running\"));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb)\n      this.once(\"close\", cb);\n    if (this._state === CLOSING)\n      return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf(\"?\");\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path)\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on(\"error\", socketOnError);\n    const key = req.headers[\"sec-websocket-key\"];\n    const version = +req.headers[\"sec-websocket-version\"];\n    if (req.method !== \"GET\") {\n      const message = \"Invalid HTTP method\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n      const message = \"Invalid Upgrade header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!key || !keyRegex.test(key)) {\n      const message = \"Missing or invalid Sec-WebSocket-Key header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = \"Missing or invalid Sec-WebSocket-Version header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n    let protocols = /* @__PURE__ */ new Set();\n    if (secWebSocketProtocol !== void 0) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Protocol header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {\n      const perMessageDeflate = new PerMessageDeflate2(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate2.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);\n          extensions[PerMessageDeflate2.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info))\n        return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    if (!socket.readable || !socket.writable)\n      return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error(\n        \"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration\"\n      );\n    }\n    if (this._state > RUNNING)\n      return abortHandshake(socket, 503);\n    const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n    const headers = [\n      \"HTTP/1.1 101 Switching Protocols\",\n      \"Upgrade: websocket\",\n      \"Connection: Upgrade\",\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n    const ws = new this.options.WebSocket(null);\n    if (protocols.size) {\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate2.extensionName]) {\n      const params = extensions[PerMessageDeflate2.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate2.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n    this.emit(\"headers\", headers, req);\n    socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n    socket.removeListener(\"error\", socketOnError);\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on(\"close\", () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nvar websocketServer = WebSocketServer;\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map))\n    server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit(\"close\");\n}\nfunction socketOnError() {\n  this.destroy();\n}\nfunction abortHandshake(socket, code, message, headers) {\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: \"close\",\n    \"Content-Type\": \"text/html\",\n    \"Content-Length\": Buffer.byteLength(message),\n    ...headers\n  };\n  socket.once(\"finish\", socket.destroy);\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message\n  );\n}\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount(\"wsClientError\")) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit(\"wsClientError\", err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\nconst websocketServer$1 = /* @__PURE__ */ getDefaultExportFromCjs(websocketServer);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdyYWRpby9jbGllbnQvZGlzdC93cmFwcGVyLUN2aVNzZWxHLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDQTtBQUNGO0FBQ0U7QUFDSjtBQUNNO0FBQ0w7QUFDQTtBQUNHO0FBQ0U7QUFDRDtBQUNEO0FBQ0g7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLFNBQVMsRUFBRSxtQ0FBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0EsUUFBUSxTQUFTLEVBQUUsbUNBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXLEVBQUUsbUNBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLFFBQVEsZ0NBQWdDO0FBQ3hDLFFBQVEsc0RBQXNEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0I7QUFDN0UsQ0FBQztBQUNEO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQix1QkFBdUIsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUIsR0FBRyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUIsR0FBRyxtQ0FBbUM7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGFBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCLG1DQUFZO0FBQ2pDLGFBQWEsa0NBQVk7QUFDekIsUUFBUSxhQUFhLEVBQUUsbUNBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQixpQ0FBaUMsR0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHlCQUF5QjtBQUN0QztBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBa0Q7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU0sRUFBRSx3QkFBd0I7QUFDaEQsdUNBQXVDLEVBQUUsSUFBSSxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBUUUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcU2hsb2tcXENvbGxlZ2VcXGRpdHRvLXRhbGtpbmdoZWFkXFxJbnRlcmZhY2VcXG5vZGVfbW9kdWxlc1xcQGdyYWRpb1xcY2xpZW50XFxkaXN0XFx3cmFwcGVyLUN2aVNzZWxHLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZXF1aXJlJCQwIGZyb20gXCJzdHJlYW1cIjtcbmltcG9ydCByZXF1aXJlJCQwJDIgZnJvbSBcInpsaWJcIjtcbmltcG9ydCByZXF1aXJlJCQwJDEgZnJvbSBcImZzXCI7XG5pbXBvcnQgcmVxdWlyZSQkMSQxIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgcmVxdWlyZSQkMiBmcm9tIFwib3NcIjtcbmltcG9ydCByZXF1aXJlJCQwJDMgZnJvbSBcImJ1ZmZlclwiO1xuaW1wb3J0IHJlcXVpcmUkJDMgZnJvbSBcIm5ldFwiO1xuaW1wb3J0IHJlcXVpcmUkJDQgZnJvbSBcInRsc1wiO1xuaW1wb3J0IHJlcXVpcmUkJDUgZnJvbSBcImNyeXB0b1wiO1xuaW1wb3J0IHJlcXVpcmUkJDAkNCBmcm9tIFwiZXZlbnRzXCI7XG5pbXBvcnQgcmVxdWlyZSQkMSQyIGZyb20gXCJodHRwc1wiO1xuaW1wb3J0IHJlcXVpcmUkJDIkMSBmcm9tIFwiaHR0cFwiO1xuaW1wb3J0IHJlcXVpcmUkJDcgZnJvbSBcInVybFwiO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoeCkge1xuICByZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsIFwiZGVmYXVsdFwiKSA/IHhbXCJkZWZhdWx0XCJdIDogeDtcbn1cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuKSB7XG4gIGlmIChuLl9fZXNNb2R1bGUpXG4gICAgcmV0dXJuIG47XG4gIHZhciBmID0gbi5kZWZhdWx0O1xuICBpZiAodHlwZW9mIGYgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGEgPSBmdW5jdGlvbiBhMigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYTIpIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGYsIGFyZ3VtZW50cywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgYS5wcm90b3R5cGUgPSBmLnByb3RvdHlwZTtcbiAgfSBlbHNlXG4gICAgYSA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCBrKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuW2tdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSQkMDtcbmZ1bmN0aW9uIGVtaXRDbG9zZSQxKHN0cmVhbTIpIHtcbiAgc3RyZWFtMi5lbWl0KFwiY2xvc2VcIik7XG59XG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGR1cGxleE9uRXJyb3IoZXJyKSB7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoXCJlcnJvclwiKSA9PT0gMCkge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xuICBsZXQgdGVybWluYXRlT25EZXN0cm95ID0gdHJ1ZTtcbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuICB3cy5vbihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9ICFpc0JpbmFyeSAmJiBkdXBsZXguX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA/IG1zZy50b1N0cmluZygpIDogbXNnO1xuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpXG4gICAgICB3cy5wYXVzZSgpO1xuICB9KTtcbiAgd3Mub25jZShcImVycm9yXCIsIGZ1bmN0aW9uIGVycm9yMihlcnIpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZClcbiAgICAgIHJldHVybjtcbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcbiAgd3Mub25jZShcImNsb3NlXCIsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKVxuICAgICAgcmV0dXJuO1xuICAgIGR1cGxleC5wdXNoKG51bGwpO1xuICB9KTtcbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24oZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DTE9TRUQpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSQxLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgd3Mub25jZShcImVycm9yXCIsIGZ1bmN0aW9uIGVycm9yMihlcnIyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyMik7XG4gICAgfSk7XG4gICAgd3Mub25jZShcImNsb3NlXCIsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCFjYWxsZWQpXG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSQxLCBkdXBsZXgpO1xuICAgIH0pO1xuICAgIGlmICh0ZXJtaW5hdGVPbkRlc3Ryb3kpXG4gICAgICB3cy50ZXJtaW5hdGUoKTtcbiAgfTtcbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoXCJvcGVuXCIsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fZmluYWwoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh3cy5fc29ja2V0ID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKVxuICAgICAgICBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoXCJmaW5pc2hcIiwgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICB3cy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdzLmlzUGF1c2VkKVxuICAgICAgd3MucmVzdW1lKCk7XG4gIH07XG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoXCJvcGVuXCIsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuICBkdXBsZXgub24oXCJlbmRcIiwgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oXCJlcnJvclwiLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cbnZhciBzdHJlYW0gPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG5jb25zdCBzdHJlYW0kMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzdHJlYW0pO1xudmFyIGJ1ZmZlclV0aWwkMSA9IHsgZXhwb3J0czoge30gfTtcbnZhciBjb25zdGFudHMgPSB7XG4gIEJJTkFSWV9UWVBFUzogW1wibm9kZWJ1ZmZlclwiLCBcImFycmF5YnVmZmVyXCIsIFwiZnJhZ21lbnRzXCJdLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogXCIyNThFQUZBNS1FOTE0LTQ3REEtOTVDQS1DNUFCMERDODVCMTFcIixcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGU6IFN5bWJvbChcImtJc0Zvck9uRXZlbnRBdHRyaWJ1dGVcIiksXG4gIGtMaXN0ZW5lcjogU3ltYm9sKFwia0xpc3RlbmVyXCIpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKFwic3RhdHVzLWNvZGVcIiksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbChcIndlYnNvY2tldFwiKSxcbiAgTk9PUDogKCkgPT4ge1xuICB9XG59O1xudmFyIGJ1ZmZlcnV0aWwgPSB7IGV4cG9ydHM6IHt9IH07XG52YXIgbm9kZUd5cEJ1aWxkJDEgPSB7IGV4cG9ydHM6IHt9IH07XG5mdW5jdGlvbiBjb21tb25qc1JlcXVpcmUocGF0aCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlIFwiJyArIHBhdGggKyAnXCIuIFBsZWFzZSBjb25maWd1cmUgdGhlIGR5bmFtaWNSZXF1aXJlVGFyZ2V0cyBvci9hbmQgaWdub3JlRHluYW1pY1JlcXVpcmVzIG9wdGlvbiBvZiBAcm9sbHVwL3BsdWdpbi1jb21tb25qcyBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHJlcXVpcmUgY2FsbCB0byB3b3JrLicpO1xufVxudmFyIG5vZGVHeXBCdWlsZDtcbnZhciBoYXNSZXF1aXJlZE5vZGVHeXBCdWlsZCQxO1xuZnVuY3Rpb24gcmVxdWlyZU5vZGVHeXBCdWlsZCQxKCkge1xuICBpZiAoaGFzUmVxdWlyZWROb2RlR3lwQnVpbGQkMSlcbiAgICByZXR1cm4gbm9kZUd5cEJ1aWxkO1xuICBoYXNSZXF1aXJlZE5vZGVHeXBCdWlsZCQxID0gMTtcbiAgdmFyIGZzID0gcmVxdWlyZSQkMCQxO1xuICB2YXIgcGF0aCA9IHJlcXVpcmUkJDEkMTtcbiAgdmFyIG9zID0gcmVxdWlyZSQkMjtcbiAgdmFyIHJ1bnRpbWVSZXF1aXJlID0gdHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18gPT09IFwiZnVuY3Rpb25cIiA/IF9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fIDogY29tbW9uanNSZXF1aXJlO1xuICB2YXIgdmFycyA9IHByb2Nlc3MuY29uZmlnICYmIHByb2Nlc3MuY29uZmlnLnZhcmlhYmxlcyB8fCB7fTtcbiAgdmFyIHByZWJ1aWxkc09ubHkgPSAhIXByb2Nlc3MuZW52LlBSRUJVSUxEU19PTkxZO1xuICB2YXIgYWJpID0gcHJvY2Vzcy52ZXJzaW9ucy5tb2R1bGVzO1xuICB2YXIgcnVudGltZSA9IGlzRWxlY3Ryb24oKSA/IFwiZWxlY3Ryb25cIiA6IGlzTndqcygpID8gXCJub2RlLXdlYmtpdFwiIDogXCJub2RlXCI7XG4gIHZhciBhcmNoID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19hcmNoIHx8IG9zLmFyY2goKTtcbiAgdmFyIHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19wbGF0Zm9ybSB8fCBvcy5wbGF0Zm9ybSgpO1xuICB2YXIgbGliYyA9IHByb2Nlc3MuZW52LkxJQkMgfHwgKGlzQWxwaW5lKHBsYXRmb3JtKSA/IFwibXVzbFwiIDogXCJnbGliY1wiKTtcbiAgdmFyIGFybXYgPSBwcm9jZXNzLmVudi5BUk1fVkVSU0lPTiB8fCAoYXJjaCA9PT0gXCJhcm02NFwiID8gXCI4XCIgOiB2YXJzLmFybV92ZXJzaW9uKSB8fCBcIlwiO1xuICB2YXIgdXYgPSAocHJvY2Vzcy52ZXJzaW9ucy51diB8fCBcIlwiKS5zcGxpdChcIi5cIilbMF07XG4gIG5vZGVHeXBCdWlsZCA9IGxvYWQ7XG4gIGZ1bmN0aW9uIGxvYWQoZGlyKSB7XG4gICAgcmV0dXJuIHJ1bnRpbWVSZXF1aXJlKGxvYWQucmVzb2x2ZShkaXIpKTtcbiAgfVxuICBsb2FkLnJlc29sdmUgPSBsb2FkLnBhdGggPSBmdW5jdGlvbihkaXIpIHtcbiAgICBkaXIgPSBwYXRoLnJlc29sdmUoZGlyIHx8IFwiLlwiKTtcbiAgICB0cnkge1xuICAgICAgdmFyIG5hbWUgPSBydW50aW1lUmVxdWlyZShwYXRoLmpvaW4oZGlyLCBcInBhY2thZ2UuanNvblwiKSkubmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52W25hbWUgKyBcIl9QUkVCVUlMRFwiXSlcbiAgICAgICAgZGlyID0gcHJvY2Vzcy5lbnZbbmFtZSArIFwiX1BSRUJVSUxEXCJdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgIH1cbiAgICBpZiAoIXByZWJ1aWxkc09ubHkpIHtcbiAgICAgIHZhciByZWxlYXNlID0gZ2V0Rmlyc3QocGF0aC5qb2luKGRpciwgXCJidWlsZC9SZWxlYXNlXCIpLCBtYXRjaEJ1aWxkKTtcbiAgICAgIGlmIChyZWxlYXNlKVxuICAgICAgICByZXR1cm4gcmVsZWFzZTtcbiAgICAgIHZhciBkZWJ1ZyA9IGdldEZpcnN0KHBhdGguam9pbihkaXIsIFwiYnVpbGQvRGVidWdcIiksIG1hdGNoQnVpbGQpO1xuICAgICAgaWYgKGRlYnVnKVxuICAgICAgICByZXR1cm4gZGVidWc7XG4gICAgfVxuICAgIHZhciBwcmVidWlsZCA9IHJlc29sdmUoZGlyKTtcbiAgICBpZiAocHJlYnVpbGQpXG4gICAgICByZXR1cm4gcHJlYnVpbGQ7XG4gICAgdmFyIG5lYXJieSA9IHJlc29sdmUocGF0aC5kaXJuYW1lKHByb2Nlc3MuZXhlY1BhdGgpKTtcbiAgICBpZiAobmVhcmJ5KVxuICAgICAgcmV0dXJuIG5lYXJieTtcbiAgICB2YXIgdGFyZ2V0ID0gW1xuICAgICAgXCJwbGF0Zm9ybT1cIiArIHBsYXRmb3JtLFxuICAgICAgXCJhcmNoPVwiICsgYXJjaCxcbiAgICAgIFwicnVudGltZT1cIiArIHJ1bnRpbWUsXG4gICAgICBcImFiaT1cIiArIGFiaSxcbiAgICAgIFwidXY9XCIgKyB1dixcbiAgICAgIGFybXYgPyBcImFybXY9XCIgKyBhcm12IDogXCJcIixcbiAgICAgIFwibGliYz1cIiArIGxpYmMsXG4gICAgICBcIm5vZGU9XCIgKyBwcm9jZXNzLnZlcnNpb25zLm5vZGUsXG4gICAgICBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uID8gXCJlbGVjdHJvbj1cIiArIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gOiBcIlwiLFxuICAgICAgdHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18gPT09IFwiZnVuY3Rpb25cIiA/IFwid2VicGFjaz10cnVlXCIgOiBcIlwiXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbmF0aXZlIGJ1aWxkIHdhcyBmb3VuZCBmb3IgXCIgKyB0YXJnZXQgKyBcIlxcbiAgICBsb2FkZWQgZnJvbTogXCIgKyBkaXIgKyBcIlxcblwiKTtcbiAgICBmdW5jdGlvbiByZXNvbHZlKGRpcjIpIHtcbiAgICAgIHZhciB0dXBsZXMgPSByZWFkZGlyU3luYyhwYXRoLmpvaW4oZGlyMiwgXCJwcmVidWlsZHNcIikpLm1hcChwYXJzZVR1cGxlKTtcbiAgICAgIHZhciB0dXBsZSA9IHR1cGxlcy5maWx0ZXIobWF0Y2hUdXBsZShwbGF0Zm9ybSwgYXJjaCkpLnNvcnQoY29tcGFyZVR1cGxlcylbMF07XG4gICAgICBpZiAoIXR1cGxlKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgcHJlYnVpbGRzID0gcGF0aC5qb2luKGRpcjIsIFwicHJlYnVpbGRzXCIsIHR1cGxlLm5hbWUpO1xuICAgICAgdmFyIHBhcnNlZCA9IHJlYWRkaXJTeW5jKHByZWJ1aWxkcykubWFwKHBhcnNlVGFncyk7XG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IHBhcnNlZC5maWx0ZXIobWF0Y2hUYWdzKHJ1bnRpbWUsIGFiaSkpO1xuICAgICAgdmFyIHdpbm5lciA9IGNhbmRpZGF0ZXMuc29ydChjb21wYXJlVGFncyhydW50aW1lKSlbMF07XG4gICAgICBpZiAod2lubmVyKVxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHByZWJ1aWxkcywgd2lubmVyLmZpbGUpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gcmVhZGRpclN5bmMoZGlyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcy5yZWFkZGlyU3luYyhkaXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRGaXJzdChkaXIsIGZpbHRlcikge1xuICAgIHZhciBmaWxlcyA9IHJlYWRkaXJTeW5jKGRpcikuZmlsdGVyKGZpbHRlcik7XG4gICAgcmV0dXJuIGZpbGVzWzBdICYmIHBhdGguam9pbihkaXIsIGZpbGVzWzBdKTtcbiAgfVxuICBmdW5jdGlvbiBtYXRjaEJ1aWxkKG5hbWUpIHtcbiAgICByZXR1cm4gL1xcLm5vZGUkLy50ZXN0KG5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVHVwbGUobmFtZSkge1xuICAgIHZhciBhcnIgPSBuYW1lLnNwbGl0KFwiLVwiKTtcbiAgICBpZiAoYXJyLmxlbmd0aCAhPT0gMilcbiAgICAgIHJldHVybjtcbiAgICB2YXIgcGxhdGZvcm0yID0gYXJyWzBdO1xuICAgIHZhciBhcmNoaXRlY3R1cmVzID0gYXJyWzFdLnNwbGl0KFwiK1wiKTtcbiAgICBpZiAoIXBsYXRmb3JtMilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIWFyY2hpdGVjdHVyZXMubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghYXJjaGl0ZWN0dXJlcy5ldmVyeShCb29sZWFuKSlcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4geyBuYW1lLCBwbGF0Zm9ybTogcGxhdGZvcm0yLCBhcmNoaXRlY3R1cmVzIH07XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hUdXBsZShwbGF0Zm9ybTIsIGFyY2gyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHR1cGxlKSB7XG4gICAgICBpZiAodHVwbGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHR1cGxlLnBsYXRmb3JtICE9PSBwbGF0Zm9ybTIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0dXBsZS5hcmNoaXRlY3R1cmVzLmluY2x1ZGVzKGFyY2gyKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVUdXBsZXMoYSwgYikge1xuICAgIHJldHVybiBhLmFyY2hpdGVjdHVyZXMubGVuZ3RoIC0gYi5hcmNoaXRlY3R1cmVzLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVRhZ3MoZmlsZSkge1xuICAgIHZhciBhcnIgPSBmaWxlLnNwbGl0KFwiLlwiKTtcbiAgICB2YXIgZXh0ZW5zaW9uMiA9IGFyci5wb3AoKTtcbiAgICB2YXIgdGFncyA9IHsgZmlsZSwgc3BlY2lmaWNpdHk6IDAgfTtcbiAgICBpZiAoZXh0ZW5zaW9uMiAhPT0gXCJub2RlXCIpXG4gICAgICByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0YWcgPSBhcnJbaV07XG4gICAgICBpZiAodGFnID09PSBcIm5vZGVcIiB8fCB0YWcgPT09IFwiZWxlY3Ryb25cIiB8fCB0YWcgPT09IFwibm9kZS13ZWJraXRcIikge1xuICAgICAgICB0YWdzLnJ1bnRpbWUgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gXCJuYXBpXCIpIHtcbiAgICAgICAgdGFncy5uYXBpID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGFnLnNsaWNlKDAsIDMpID09PSBcImFiaVwiKSB7XG4gICAgICAgIHRhZ3MuYWJpID0gdGFnLnNsaWNlKDMpO1xuICAgICAgfSBlbHNlIGlmICh0YWcuc2xpY2UoMCwgMikgPT09IFwidXZcIikge1xuICAgICAgICB0YWdzLnV2ID0gdGFnLnNsaWNlKDIpO1xuICAgICAgfSBlbHNlIGlmICh0YWcuc2xpY2UoMCwgNCkgPT09IFwiYXJtdlwiKSB7XG4gICAgICAgIHRhZ3MuYXJtdiA9IHRhZy5zbGljZSg0KTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBcImdsaWJjXCIgfHwgdGFnID09PSBcIm11c2xcIikge1xuICAgICAgICB0YWdzLmxpYmMgPSB0YWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRhZ3Muc3BlY2lmaWNpdHkrKztcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cbiAgZnVuY3Rpb24gbWF0Y2hUYWdzKHJ1bnRpbWUyLCBhYmkyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhZ3MpIHtcbiAgICAgIGlmICh0YWdzID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0YWdzLnJ1bnRpbWUgIT09IHJ1bnRpbWUyICYmICFydW50aW1lQWdub3N0aWModGFncykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0YWdzLmFiaSAhPT0gYWJpMiAmJiAhdGFncy5uYXBpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAodGFncy51diAmJiB0YWdzLnV2ICE9PSB1dilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHRhZ3MuYXJtdiAmJiB0YWdzLmFybXYgIT09IGFybXYpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0YWdzLmxpYmMgJiYgdGFncy5saWJjICE9PSBsaWJjKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHJ1bnRpbWVBZ25vc3RpYyh0YWdzKSB7XG4gICAgcmV0dXJuIHRhZ3MucnVudGltZSA9PT0gXCJub2RlXCIgJiYgdGFncy5uYXBpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVUYWdzKHJ1bnRpbWUyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLnJ1bnRpbWUgIT09IGIucnVudGltZSkge1xuICAgICAgICByZXR1cm4gYS5ydW50aW1lID09PSBydW50aW1lMiA/IC0xIDogMTtcbiAgICAgIH0gZWxzZSBpZiAoYS5hYmkgIT09IGIuYWJpKSB7XG4gICAgICAgIHJldHVybiBhLmFiaSA/IC0xIDogMTtcbiAgICAgIH0gZWxzZSBpZiAoYS5zcGVjaWZpY2l0eSAhPT0gYi5zcGVjaWZpY2l0eSkge1xuICAgICAgICByZXR1cm4gYS5zcGVjaWZpY2l0eSA+IGIuc3BlY2lmaWNpdHkgPyAtMSA6IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGlzTndqcygpIHtcbiAgICByZXR1cm4gISEocHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm53KTtcbiAgfVxuICBmdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xuICAgIGlmIChwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuRUxFQ1RST05fUlVOX0FTX05PREUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCI7XG4gIH1cbiAgZnVuY3Rpb24gaXNBbHBpbmUocGxhdGZvcm0yKSB7XG4gICAgcmV0dXJuIHBsYXRmb3JtMiA9PT0gXCJsaW51eFwiICYmIGZzLmV4aXN0c1N5bmMoXCIvZXRjL2FscGluZS1yZWxlYXNlXCIpO1xuICB9XG4gIGxvYWQucGFyc2VUYWdzID0gcGFyc2VUYWdzO1xuICBsb2FkLm1hdGNoVGFncyA9IG1hdGNoVGFncztcbiAgbG9hZC5jb21wYXJlVGFncyA9IGNvbXBhcmVUYWdzO1xuICBsb2FkLnBhcnNlVHVwbGUgPSBwYXJzZVR1cGxlO1xuICBsb2FkLm1hdGNoVHVwbGUgPSBtYXRjaFR1cGxlO1xuICBsb2FkLmNvbXBhcmVUdXBsZXMgPSBjb21wYXJlVHVwbGVzO1xuICByZXR1cm4gbm9kZUd5cEJ1aWxkO1xufVxudmFyIGhhc1JlcXVpcmVkTm9kZUd5cEJ1aWxkO1xuZnVuY3Rpb24gcmVxdWlyZU5vZGVHeXBCdWlsZCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkTm9kZUd5cEJ1aWxkKVxuICAgIHJldHVybiBub2RlR3lwQnVpbGQkMS5leHBvcnRzO1xuICBoYXNSZXF1aXJlZE5vZGVHeXBCdWlsZCA9IDE7XG4gIGlmICh0eXBlb2YgcHJvY2Vzcy5hZGRvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbm9kZUd5cEJ1aWxkJDEuZXhwb3J0cyA9IHByb2Nlc3MuYWRkb24uYmluZChwcm9jZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlR3lwQnVpbGQkMS5leHBvcnRzID0gcmVxdWlyZU5vZGVHeXBCdWlsZCQxKCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVHeXBCdWlsZCQxLmV4cG9ydHM7XG59XG52YXIgZmFsbGJhY2s7XG52YXIgaGFzUmVxdWlyZWRGYWxsYmFjaztcbmZ1bmN0aW9uIHJlcXVpcmVGYWxsYmFjaygpIHtcbiAgaWYgKGhhc1JlcXVpcmVkRmFsbGJhY2spXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICBoYXNSZXF1aXJlZEZhbGxiYWNrID0gMTtcbiAgY29uc3QgbWFzazIgPSAoc291cmNlLCBtYXNrMywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2szW2kgJiAzXTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHVubWFzazIgPSAoYnVmZmVyLCBtYXNrMykgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmZmVyW2ldIF49IG1hc2szW2kgJiAzXTtcbiAgICB9XG4gIH07XG4gIGZhbGxiYWNrID0geyBtYXNrOiBtYXNrMiwgdW5tYXNrOiB1bm1hc2syIH07XG4gIHJldHVybiBmYWxsYmFjaztcbn1cbnZhciBoYXNSZXF1aXJlZEJ1ZmZlcnV0aWw7XG5mdW5jdGlvbiByZXF1aXJlQnVmZmVydXRpbCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkQnVmZmVydXRpbClcbiAgICByZXR1cm4gYnVmZmVydXRpbC5leHBvcnRzO1xuICBoYXNSZXF1aXJlZEJ1ZmZlcnV0aWwgPSAxO1xuICB0cnkge1xuICAgIGJ1ZmZlcnV0aWwuZXhwb3J0cyA9IHJlcXVpcmVOb2RlR3lwQnVpbGQoKShfX2Rpcm5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgYnVmZmVydXRpbC5leHBvcnRzID0gcmVxdWlyZUZhbGxiYWNrKCk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcnV0aWwuZXhwb3J0cztcbn1cbnZhciB1bm1hc2skMTtcbnZhciBtYXNrO1xuY29uc3QgeyBFTVBUWV9CVUZGRVI6IEVNUFRZX0JVRkZFUiQzIH0gPSBjb25zdGFudHM7XG5jb25zdCBGYXN0QnVmZmVyJDIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuZnVuY3Rpb24gY29uY2F0JDEobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBFTVBUWV9CVUZGRVIkMztcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiBsaXN0WzBdO1xuICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICBpZiAob2Zmc2V0IDwgdG90YWxMZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIkMih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrMiwgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W29mZnNldCArIGldID0gc291cmNlW2ldIF4gbWFzazJbaSAmIDNdO1xuICB9XG59XG5mdW5jdGlvbiBfdW5tYXNrKGJ1ZmZlciwgbWFzazIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gXj0gbWFzazJbaSAmIDNdO1xuICB9XG59XG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyJDEoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIHRvQnVmZmVyJDIoZGF0YSkge1xuICB0b0J1ZmZlciQyLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICByZXR1cm4gZGF0YTtcbiAgbGV0IGJ1ZjtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyJDIoZGF0YSk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYnVmID0gbmV3IEZhc3RCdWZmZXIkMihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyJDIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuYnVmZmVyVXRpbCQxLmV4cG9ydHMgPSB7XG4gIGNvbmNhdDogY29uY2F0JDEsXG4gIG1hc2s6IF9tYXNrLFxuICB0b0FycmF5QnVmZmVyOiB0b0FycmF5QnVmZmVyJDEsXG4gIHRvQnVmZmVyOiB0b0J1ZmZlciQyLFxuICB1bm1hc2s6IF91bm1hc2tcbn07XG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyVXRpbDIgPSByZXF1aXJlQnVmZmVydXRpbCgpO1xuICAgIG1hc2sgPSBidWZmZXJVdGlsJDEuZXhwb3J0cy5tYXNrID0gZnVuY3Rpb24oc291cmNlLCBtYXNrMiwgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA8IDQ4KVxuICAgICAgICBfbWFzayhzb3VyY2UsIG1hc2syLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmZmVyVXRpbDIubWFzayhzb3VyY2UsIG1hc2syLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIHVubWFzayQxID0gYnVmZmVyVXRpbCQxLmV4cG9ydHMudW5tYXNrID0gZnVuY3Rpb24oYnVmZmVyLCBtYXNrMikge1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCAzMilcbiAgICAgICAgX3VubWFzayhidWZmZXIsIG1hc2syKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmZmVyVXRpbDIudW5tYXNrKGJ1ZmZlciwgbWFzazIpO1xuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxudmFyIGJ1ZmZlclV0aWxFeHBvcnRzID0gYnVmZmVyVXRpbCQxLmV4cG9ydHM7XG5jb25zdCBrRG9uZSA9IFN5bWJvbChcImtEb25lXCIpO1xuY29uc3Qga1J1biA9IFN5bWJvbChcImtSdW5cIik7XG5sZXQgTGltaXRlciQxID0gY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgVGhlIGpvYiB0byBydW5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkKGpvYikge1xuICAgIHRoaXMuam9icy5wdXNoKGpvYik7XG4gICAgdGhpc1trUnVuXSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuam9icy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9icy5zaGlmdCgpO1xuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufTtcbnZhciBsaW1pdGVyID0gTGltaXRlciQxO1xuY29uc3QgemxpYiA9IHJlcXVpcmUkJDAkMjtcbmNvbnN0IGJ1ZmZlclV0aWwgPSBidWZmZXJVdGlsRXhwb3J0cztcbmNvbnN0IExpbWl0ZXIyID0gbGltaXRlcjtcbmNvbnN0IHsga1N0YXR1c0NvZGU6IGtTdGF0dXNDb2RlJDIgfSA9IGNvbnN0YW50cztcbmNvbnN0IEZhc3RCdWZmZXIkMSA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzAsIDAsIDI1NSwgMjU1XSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woXCJwZXJtZXNzYWdlLWRlZmxhdGVcIik7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woXCJ0b3RhbC1sZW5ndGhcIik7XG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woXCJjYWxsYmFja1wiKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKFwiYnVmZmVyc1wiKTtcbmNvbnN0IGtFcnJvciQxID0gU3ltYm9sKFwiZXJyb3JcIik7XG5sZXQgemxpYkxpbWl0ZXI7XG5sZXQgUGVyTWVzc2FnZURlZmxhdGUkNCA9IGNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzXSBBZHZlcnRpc2Ugc3VwcG9ydFxuICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gQWR2ZXJ0aXNlL1xuICAgKiAgICAgYWNrbm93bGVkZ2UgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcbiAgICogICAgIGNhbGxzIHRvIHpsaWJcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzXSBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIFJlcXVlc3QvYWNjZXB0XG4gICAqICAgICBkaXNhYmxpbmcgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcbiAgICogICAgIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZCBpZiBjb250ZXh0IHRha2VvdmVyIGlzIGRpc2FibGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBpbmZsYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3JcbiAgICogICAgIGNsaWVudCBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBtYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl90aHJlc2hvbGQgPSB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdm9pZCAwID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPSB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHZvaWQgMCA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCA6IDEwO1xuICAgICAgemxpYkxpbWl0ZXIgPSBuZXcgTGltaXRlcjIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gXCJwZXJtZXNzYWdlLWRlZmxhdGVcIjtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuICAgIHRoaXMucGFyYW1zID0gdGhpcy5faXNTZXJ2ZXIgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKSA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcbiAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZFwiXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzU2VydmVyKG9mZmVycykge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xuICAgICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciB8fCBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyAmJiAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fCB0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBcIm51bWJlclwiICYmIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSB8fCB0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBcIm51bWJlclwiICYmICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBpZiAoIWFjY2VwdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZFwiKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBcIm51bWJlclwiKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fCBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG4gIC8qKlxuICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmVzcG9uc2VbMF07XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3Zlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8IHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IFwibnVtYmVyXCIgJiYgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9mZmVycy9yZXNwb25zZSB3aXRoIG5vcm1hbGl6ZWQgcGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VydmVyX21heF93aW5kb3dfYml0c1wiKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIiB8fCBrZXkgPT09IFwic2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXJcIikge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/IFwiY2xpZW50XCIgOiBcInNlcnZlclwiO1xuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID0gdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09IFwibnVtYmVyXCIgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTIDogdGhpcy5wYXJhbXNba2V5XTtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKFwiZXJyb3JcIiwgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbihcImRhdGFcIiwgaW5mbGF0ZU9uRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbilcbiAgICAgIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvciQxXTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YTIgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YTIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyBcInNlcnZlclwiIDogXCJjbGllbnRcIjtcbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9IHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSBcIm51bWJlclwiID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUUyA6IHRoaXMucGFyYW1zW2tleV07XG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKFwiZGF0YVwiLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRhdGEyID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG4gICAgICBpZiAoZmluKSB7XG4gICAgICAgIGRhdGEyID0gbmV3IEZhc3RCdWZmZXIkMShkYXRhMi5idWZmZXIsIGRhdGEyLmJ5dGVPZmZzZXQsIGRhdGEyLmxlbmd0aCAtIDQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEyKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBwZXJtZXNzYWdlRGVmbGF0ZSA9IFBlck1lc3NhZ2VEZWZsYXRlJDQ7XG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuICBpZiAodGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fCB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXNba0Vycm9yJDFdID0gbmV3IFJhbmdlRXJyb3IoXCJNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkXCIpO1xuICB0aGlzW2tFcnJvciQxXS5jb2RlID0gXCJXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEhcIjtcbiAgdGhpc1trRXJyb3IkMV1ba1N0YXR1c0NvZGUkMl0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBpbmZsYXRlT25EYXRhKTtcbiAgdGhpcy5yZXNldCgpO1xufVxuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG4gIGVycltrU3RhdHVzQ29kZSQyXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxudmFyIHZhbGlkYXRpb24gPSB7IGV4cG9ydHM6IHt9IH07XG5jb25zdCBfX3ZpdGVPcHRpb25hbFBlZXJEZXBfdXRmOFZhbGlkYXRlX3dzID0ge307XG5jb25zdCBfX3ZpdGVPcHRpb25hbFBlZXJEZXBfdXRmOFZhbGlkYXRlX3dzJDEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZWZhdWx0OiBfX3ZpdGVPcHRpb25hbFBlZXJEZXBfdXRmOFZhbGlkYXRlX3dzXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuY29uc3QgcmVxdWlyZSQkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXRBdWdtZW50ZWROYW1lc3BhY2UoX192aXRlT3B0aW9uYWxQZWVyRGVwX3V0ZjhWYWxpZGF0ZV93cyQxKTtcbnZhciBpc1ZhbGlkVVRGOF8xO1xuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUkJDAkMztcbmNvbnN0IHRva2VuQ2hhcnMkMiA9IFtcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgLy8gMCAtIDE1XG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIC8vIDE2IC0gMzFcbiAgMCxcbiAgMSxcbiAgMCxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMCxcbiAgMCxcbiAgMSxcbiAgMSxcbiAgMCxcbiAgMSxcbiAgMSxcbiAgMCxcbiAgLy8gMzIgLSA0N1xuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAwLFxuICAvLyA0OCAtIDYzXG4gIDAsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIDEsXG4gIC8vIDY0IC0gNzlcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMSxcbiAgMCxcbiAgMCxcbiAgMCxcbiAgMSxcbiAgMSxcbiAgLy8gODAgLSA5NVxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAvLyA5NiAtIDExMVxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAxLFxuICAwLFxuICAxLFxuICAwLFxuICAxLFxuICAwXG4gIC8vIDExMiAtIDEyN1xuXTtcbmZ1bmN0aW9uIGlzVmFsaWRTdGF0dXNDb2RlJDIoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSAxZTMgJiYgY29kZSA8PSAxMDE0ICYmIGNvZGUgIT09IDEwMDQgJiYgY29kZSAhPT0gMTAwNSAmJiBjb2RlICE9PSAxMDA2IHx8IGNvZGUgPj0gM2UzICYmIGNvZGUgPD0gNDk5OTtcbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkVVRGOChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMTI4KSA9PT0gMCkge1xuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDIyNCkgPT09IDE5Mikge1xuICAgICAgaWYgKGkgKyAxID09PSBsZW4gfHwgKGJ1ZltpICsgMV0gJiAxOTIpICE9PSAxMjggfHwgKGJ1ZltpXSAmIDI1NCkgPT09IDE5Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMjQwKSA9PT0gMjI0KSB7XG4gICAgICBpZiAoaSArIDIgPj0gbGVuIHx8IChidWZbaSArIDFdICYgMTkyKSAhPT0gMTI4IHx8IChidWZbaSArIDJdICYgMTkyKSAhPT0gMTI4IHx8IGJ1ZltpXSA9PT0gMjI0ICYmIChidWZbaSArIDFdICYgMjI0KSA9PT0gMTI4IHx8IC8vIE92ZXJsb25nXG4gICAgICBidWZbaV0gPT09IDIzNyAmJiAoYnVmW2kgKyAxXSAmIDIyNCkgPT09IDE2MCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpICs9IDM7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMjQ4KSA9PT0gMjQwKSB7XG4gICAgICBpZiAoaSArIDMgPj0gbGVuIHx8IChidWZbaSArIDFdICYgMTkyKSAhPT0gMTI4IHx8IChidWZbaSArIDJdICYgMTkyKSAhPT0gMTI4IHx8IChidWZbaSArIDNdICYgMTkyKSAhPT0gMTI4IHx8IGJ1ZltpXSA9PT0gMjQwICYmIChidWZbaSArIDFdICYgMjQwKSA9PT0gMTI4IHx8IC8vIE92ZXJsb25nXG4gICAgICBidWZbaV0gPT09IDI0NCAmJiBidWZbaSArIDFdID4gMTQzIHx8IGJ1ZltpXSA+IDI0NCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YWxpZGF0aW9uLmV4cG9ydHMgPSB7XG4gIGlzVmFsaWRTdGF0dXNDb2RlOiBpc1ZhbGlkU3RhdHVzQ29kZSQyLFxuICBpc1ZhbGlkVVRGODogX2lzVmFsaWRVVEY4LFxuICB0b2tlbkNoYXJzOiB0b2tlbkNoYXJzJDJcbn07XG5pZiAoaXNVdGY4KSB7XG4gIGlzVmFsaWRVVEY4XzEgPSB2YWxpZGF0aW9uLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbihidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcbiAgfTtcbn0gZWxzZSBpZiAoIXByb2Nlc3MuZW52LldTX05PX1VURl84X1ZBTElEQVRFKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgaXNWYWxpZFVURjgyID0gcmVxdWlyZSQkMTtcbiAgICBpc1ZhbGlkVVRGOF8xID0gdmFsaWRhdGlvbi5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDMyID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1ZhbGlkVVRGODIoYnVmKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cbnZhciB2YWxpZGF0aW9uRXhwb3J0cyA9IHZhbGlkYXRpb24uZXhwb3J0cztcbmNvbnN0IHsgV3JpdGFibGUgfSA9IHJlcXVpcmUkJDA7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSQzID0gcGVybWVzc2FnZURlZmxhdGU7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUzogQklOQVJZX1RZUEVTJDEsXG4gIEVNUFRZX0JVRkZFUjogRU1QVFlfQlVGRkVSJDIsXG4gIGtTdGF0dXNDb2RlOiBrU3RhdHVzQ29kZSQxLFxuICBrV2ViU29ja2V0OiBrV2ViU29ja2V0JDJcbn0gPSBjb25zdGFudHM7XG5jb25zdCB7IGNvbmNhdCwgdG9BcnJheUJ1ZmZlciwgdW5tYXNrIH0gPSBidWZmZXJVdGlsRXhwb3J0cztcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGU6IGlzVmFsaWRTdGF0dXNDb2RlJDEsIGlzVmFsaWRVVEY4IH0gPSB2YWxpZGF0aW9uRXhwb3J0cztcbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xubGV0IFJlY2VpdmVyJDEgPSBjbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVMkMVswXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0JDJdID0gdm9pZCAwO1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHZvaWQgMDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pXG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuICAgIGlmIChuID09PSB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbik7XG4gICAgfVxuICAgIGNvbnN0IGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcbiAgICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbiAtPSBidWYubGVuZ3RoO1xuICAgIH0gd2hpbGUgKG4gPiAwKTtcbiAgICByZXR1cm4gZHN0O1xuICB9XG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0TG9vcChjYikge1xuICAgIGxldCBlcnI7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0SW5mbygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF8xNjpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGgxNigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldFBheWxvYWRMZW5ndGg2NCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIGVyciA9IHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcbiAgICBjYihlcnIpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEluZm8oKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcbiAgICBpZiAoKGJ1ZlswXSAmIDQ4KSAhPT0gMCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBcIlJTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhclwiLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICBcIldTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzNcIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiA2NCkgPT09IDY0O1xuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlJDMuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgXCJSU1YxIG11c3QgYmUgY2xlYXJcIixcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgXCJXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMVwiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9maW4gPSAoYnVmWzBdICYgMTI4KSA9PT0gMTI4O1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDE1O1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAxMjc7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMCkge1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBcIlJTVjEgbXVzdCBiZSBjbGVhclwiLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICBcIldTX0VSUl9VTkVYUEVDVEVEX1JTVl8xXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIFwiaW52YWxpZCBvcGNvZGUgMFwiLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICBcIldTX0VSUl9JTlZBTElEX09QQ09ERVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAxIHx8IHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgXCJXU19FUlJfSU5WQUxJRF9PUENPREVcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3NlZCA9IGNvbXByZXNzZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcGNvZGUgPiA3ICYmIHRoaXMuX29wY29kZSA8IDExKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIFwiRklOIG11c3QgYmUgc2V0XCIsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgIFwiV1NfRVJSX0VYUEVDVEVEX0ZJTlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIFwiUlNWMSBtdXN0IGJlIGNsZWFyXCIsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgIFwiV1NfRVJSX1VORVhQRUNURURfUlNWXzFcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPiAxMjUgfHwgdGhpcy5fb3Bjb2RlID09PSA4ICYmIHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgXCJXU19FUlJfSU5WQUxJRF9DT05UUk9MX1BBWUxPQURfTEVOR1RIXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgXCJXU19FUlJfSU5WQUxJRF9PUENPREVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9maW4gJiYgIXRoaXMuX2ZyYWdtZW50ZWQpXG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAxMjgpID09PSAxMjg7XG4gICAgaWYgKHRoaXMuX2lzU2VydmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX21hc2tlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIFwiTUFTSyBtdXN0IGJlIHNldFwiLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICBcIldTX0VSUl9FWFBFQ1RFRF9NQVNLXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBcIk1BU0sgbXVzdCBiZSBjbGVhclwiLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICBcIldTX0VSUl9VTkVYUEVDVEVEX01BU0tcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNilcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNylcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNigpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IHRoaXMuY29uc3VtZSgyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzY0KS5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDY0KCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcbiAgICBpZiAobnVtID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgIFwiVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxXCIsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5LFxuICAgICAgICBcIldTX0VSUl9VTlNVUFBPUlRFRF9EQVRBX1BBWUxPQURfTEVOR1RIXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBudW0gKiBNYXRoLnBvdygyLCAzMikgKyBidWYucmVhZFVJbnQzMkJFKDQpO1xuICAgIHJldHVybiB0aGlzLmhhdmVMZW5ndGgoKTtcbiAgfVxuICAvKipcbiAgICogUGF5bG9hZCBsZW5ndGggaGFzIGJlZW4gcmVhZC5cbiAgICpcbiAgICogQHJldHVybiB7KFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGF2ZUxlbmd0aCgpIHtcbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCAmJiB0aGlzLl9vcGNvZGUgPCA4KSB7XG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggKz0gdGhpcy5fcGF5bG9hZExlbmd0aDtcbiAgICAgIGlmICh0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgXCJNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkXCIsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICBcIldTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9tYXNrZWQpXG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUiQyO1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkYXRhID0gdGhpcy5jb25zdW1lKHRoaXMuX3BheWxvYWRMZW5ndGgpO1xuICAgICAgaWYgKHRoaXMuX21hc2tlZCAmJiAodGhpcy5fbWFza1swXSB8IHRoaXMuX21hc2tbMV0gfCB0aGlzLl9tYXNrWzJdIHwgdGhpcy5fbWFza1szXSkgIT09IDApIHtcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gNylcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuICAgIGlmICh0aGlzLl9jb21wcmVzc2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IElORkxBVElORztcbiAgICAgIHRoaXMuZGVjb21wcmVzcyhkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlJDMuZXh0ZW5zaW9uTmFtZV07XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICBpZiAoYnVmLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICAgIHJldHVybiBjYihcbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgICBcIk1heCBwYXlsb2FkIHNpemUgZXhjZWVkZWRcIixcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAgIFwiV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG4gICAgICBjb25zdCBlciA9IHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIGNiKGVyKTtcbiAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fZnJhZ21lbnRlZCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgICAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIGRhdGEsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICAgXCJpbnZhbGlkIFVURi04IHNlcXVlbmNlXCIsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgIFwiV1NfRVJSX0lOVkFMSURfVVRGOFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIGJ1ZiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb250cm9sTWVzc2FnZShkYXRhKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gOCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbmNsdWRlXCIsIDEwMDUsIEVNUFRZX0JVRkZFUiQyKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBkYXRhLnJlYWRVSW50MTZCRSgwKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZSQxKGNvZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgIGBpbnZhbGlkIHN0YXR1cyBjb2RlICR7Y29kZX1gLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgICBcIldTX0VSUl9JTlZBTElEX0NMT1NFX0NPREVcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgICAgZGF0YS5idWZmZXIsXG4gICAgICAgICAgZGF0YS5ieXRlT2Zmc2V0ICsgMixcbiAgICAgICAgICBkYXRhLmxlbmd0aCAtIDJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgIFwiaW52YWxpZCBVVEYtOCBzZXF1ZW5jZVwiLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgICBcIldTX0VSUl9JTlZBTElEX1VURjhcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiY29uY2x1ZGVcIiwgY29kZSwgYnVmKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gOSkge1xuICAgICAgdGhpcy5lbWl0KFwicGluZ1wiLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KFwicG9uZ1wiLCBkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufTtcbnZhciByZWNlaXZlciA9IFJlY2VpdmVyJDE7XG5mdW5jdGlvbiBlcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvckN0b3IoXG4gICAgcHJlZml4ID8gYEludmFsaWQgV2ViU29ja2V0IGZyYW1lOiAke21lc3NhZ2V9YCA6IG1lc3NhZ2VcbiAgKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICBlcnJba1N0YXR1c0NvZGUkMV0gPSBzdGF0dXNDb2RlO1xuICByZXR1cm4gZXJyO1xufVxuY29uc3QgcmVjZWl2ZXIkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhyZWNlaXZlcik7XG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlJCQ1O1xuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUkMiA9IHBlcm1lc3NhZ2VEZWZsYXRlO1xuY29uc3QgeyBFTVBUWV9CVUZGRVI6IEVNUFRZX0JVRkZFUiQxIH0gPSBjb25zdGFudHM7XG5jb25zdCB7IGlzVmFsaWRTdGF0dXNDb2RlIH0gPSB2YWxpZGF0aW9uRXhwb3J0cztcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlcjogdG9CdWZmZXIkMSB9ID0gYnVmZmVyVXRpbEV4cG9ydHM7XG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbChcImtCeXRlTGVuZ3RoXCIpO1xuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbmxldCBTZW5kZXIkMSA9IGNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIGNvbm5lY3Rpb24gc29ja2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0ZW5zaW9uc10gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lZ290aWF0ZWQgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMsIGdlbmVyYXRlTWFzaykge1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xuICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlTWFzayA9IGdlbmVyYXRlTWFzaztcbiAgICAgIHRoaXMuX21hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgfVxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gIH1cbiAgLyoqXG4gICAqIEZyYW1lcyBhIHBpZWNlIG9mIGRhdGEgYWNjb3JkaW5nIHRvIHRoZSBIeUJpIFdlYlNvY2tldCBwcm90b2NvbC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIGRhdGEgdG8gZnJhbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEByZXR1cm4geyhCdWZmZXJ8U3RyaW5nKVtdfSBUaGUgZnJhbWVkIGRhdGFcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc3RhdGljIGZyYW1lKGRhdGEsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWFzazI7XG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xuICAgICAgbWFzazIgPSBvcHRpb25zLm1hc2tCdWZmZXIgfHwgbWFza0J1ZmZlcjtcbiAgICAgIGlmIChvcHRpb25zLmdlbmVyYXRlTWFzaykge1xuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5kb21GaWxsU3luYyhtYXNrMiwgMCwgNCk7XG4gICAgICB9XG4gICAgICBza2lwTWFza2luZyA9IChtYXNrMlswXSB8IG1hc2syWzFdIHwgbWFzazJbMl0gfCBtYXNrMlszXSkgPT09IDA7XG4gICAgICBvZmZzZXQgPSA2O1xuICAgIH1cbiAgICBsZXQgZGF0YUxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICgoIW9wdGlvbnMubWFzayB8fCBza2lwTWFza2luZykgJiYgb3B0aW9uc1trQnl0ZUxlbmd0aF0gIT09IHZvaWQgMCkge1xuICAgICAgICBkYXRhTGVuZ3RoID0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seSAmJiAhc2tpcE1hc2tpbmc7XG4gICAgfVxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcbiAgICBpZiAoZGF0YUxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhTGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMTI4IDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSlcbiAgICAgIHRhcmdldFswXSB8PSA2NDtcbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMubWFzaylcbiAgICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgICB0YXJnZXRbMV0gfD0gMTI4O1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2syWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2syWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2syWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2syWzNdO1xuICAgIGlmIChza2lwTWFza2luZylcbiAgICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrMiwgdGFyZ2V0LCBvZmZzZXQsIGRhdGFMZW5ndGgpO1xuICAgICAgcmV0dXJuIFt0YXJnZXRdO1xuICAgIH1cbiAgICBhcHBseU1hc2soZGF0YSwgbWFzazIsIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrMiwgY2IpIHtcbiAgICBsZXQgYnVmO1xuICAgIGlmIChjb2RlID09PSB2b2lkIDApIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUiQxO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09IFwibnVtYmVyXCIgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyXCIpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdm9pZCAwIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXNcIik7XG4gICAgICB9XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBidWYud3JpdGUoZGF0YSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnVmLmxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzazogbWFzazIsXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2syLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlciQxKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlciQxLnJlYWRPbmx5O1xuICAgIH1cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXNcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrOiBtYXNrMixcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2syLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlciQxKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlciQxLnJlYWRPbmx5O1xuICAgIH1cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXNcIik7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrOiBtYXNrMixcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDEwLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcbiAgICogICAgIG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUkMi5leHRlbnNpb25OYW1lXTtcbiAgICBsZXQgb3Bjb2RlID0gb3B0aW9ucy5iaW5hcnkgPyAyIDogMTtcbiAgICBsZXQgcnN2MSA9IG9wdGlvbnMuY29tcHJlc3M7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyJDEoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyJDEucmVhZE9ubHk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAocnN2MSAmJiBwZXJNZXNzYWdlRGVmbGF0ZSAmJiBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyID8gXCJzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlclwiIDogXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiXSkge1xuICAgICAgICByc3YxID0gYnl0ZUxlbmd0aCA+PSBwZXJNZXNzYWdlRGVmbGF0ZS5fdGhyZXNob2xkO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29tcHJlc3MgPSByc3YxO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3YxID0gZmFsc2U7XG4gICAgICBvcGNvZGUgPSAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maW4pXG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICBpZiAocGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICAgIGZpbjogb3B0aW9ucy5maW4sXG4gICAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICAgIG9wY29kZSxcbiAgICAgICAgcmVhZE9ubHksXG4gICAgICAgIHJzdjFcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgICBTZW5kZXIuZnJhbWUoZGF0YSwge1xuICAgICAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgICAgICBvcGNvZGUsXG4gICAgICAgICAgcmVhZE9ubHksXG4gICAgICAgICAgcnN2MTogZmFsc2VcbiAgICAgICAgfSksXG4gICAgICAgIGNiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlJDIuZXh0ZW5zaW9uTmFtZV07XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9kZWZsYXRpbmcgPSB0cnVlO1xuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmNvbXByZXNzKGRhdGEsIG9wdGlvbnMuZmluLCAoXywgYnVmKSA9PiB7XG4gICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZFwiXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWVbaV07XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICAgIHRoaXMuX2RlZmxhdGluZyA9IGZhbHNlO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAoIXRoaXMuX2RlZmxhdGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgICBSZWZsZWN0LmFwcGx5KHBhcmFtc1swXSwgdGhpcywgcGFyYW1zLnNsaWNlKDEpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59O1xudmFyIHNlbmRlciA9IFNlbmRlciQxO1xuY29uc3Qgc2VuZGVyJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc2VuZGVyKTtcbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGU6IGtGb3JPbkV2ZW50QXR0cmlidXRlJDEsIGtMaXN0ZW5lcjoga0xpc3RlbmVyJDEgfSA9IGNvbnN0YW50cztcbmNvbnN0IGtDb2RlID0gU3ltYm9sKFwia0NvZGVcIik7XG5jb25zdCBrRGF0YSA9IFN5bWJvbChcImtEYXRhXCIpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKFwia0Vycm9yXCIpO1xuY29uc3Qga01lc3NhZ2UgPSBTeW1ib2woXCJrTWVzc2FnZVwiKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woXCJrUmVhc29uXCIpO1xuY29uc3Qga1RhcmdldCA9IFN5bWJvbChcImtUYXJnZXRcIik7XG5jb25zdCBrVHlwZSA9IFN5bWJvbChcImtUeXBlXCIpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKFwia1dhc0NsZWFuXCIpO1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcbiAgfVxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXNba1R5cGVdO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcInRhcmdldFwiLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCBcInR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb249JyddIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5XG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdm9pZCAwID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHZvaWQgMCA/IFwiXCIgOiBvcHRpb25zLnJlYXNvbjtcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB2b2lkIDAgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzW2tSZWFzb25dO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB3YXNDbGVhbigpIHtcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsIFwiY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsIFwicmVhc29uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgXCJ3YXNDbGVhblwiLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFcnJvckV2ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9iamVjdCB0aGF0IGFsbG93cyBmb3Igc2V0dGluZ1xuICAgKiAgICAgYXR0cmlidXRlcyB2aWEgb2JqZWN0IG1lbWJlcnMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLmVycm9yPW51bGxdIFRoZSBlcnJvciB0aGF0IGdlbmVyYXRlZCB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlPScnXSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG4gICAgdGhpc1trRXJyb3JdID0gb3B0aW9ucy5lcnJvciA9PT0gdm9pZCAwID8gbnVsbCA6IG9wdGlvbnMuZXJyb3I7XG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHZvaWQgMCA/IFwiXCIgOiBvcHRpb25zLm1lc3NhZ2U7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgXCJlcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB2b2lkIDAgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzW2tEYXRhXTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmICghb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZSQxXSAmJiBsaXN0ZW5lcltrTGlzdGVuZXIkMV0gPT09IGhhbmRsZXIgJiYgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlJDFdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHdyYXBwZXI7XG4gICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZVwiKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudChcIm1lc3NhZ2VcIiwge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2xvc2VcIikge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KFwiY2xvc2VcIiwge1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXG4gICAgICAgICAgd2FzQ2xlYW46IHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0aGlzLl9jbG9zZUZyYW1lU2VudFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IyKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgZXJyb3I6IGVycm9yMixcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvcjIubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib3BlblwiKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChcIm9wZW5cIik7XG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZSQxXSA9ICEhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZSQxXTtcbiAgICB3cmFwcGVyW2tMaXN0ZW5lciQxXSA9IGhhbmRsZXI7XG4gICAgaWYgKG9wdGlvbnMub25jZSkge1xuICAgICAgdGhpcy5vbmNlKHR5cGUsIHdyYXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKHR5cGUsIHdyYXBwZXIpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKGxpc3RlbmVyW2tMaXN0ZW5lciQxXSA9PT0gaGFuZGxlciAmJiAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGUkMV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBldmVudFRhcmdldCA9IHtcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnQsXG4gIEV2ZW50VGFyZ2V0LFxuICBNZXNzYWdlRXZlbnRcbn07XG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIobGlzdGVuZXIsIHRoaXNBcmcsIGV2ZW50KSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwib2JqZWN0XCIgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbmNvbnN0IHsgdG9rZW5DaGFyczogdG9rZW5DaGFycyQxIH0gPSB2YWxpZGF0aW9uRXhwb3J0cztcbmZ1bmN0aW9uIHB1c2goZGVzdCwgbmFtZSwgZWxlbSkge1xuICBpZiAoZGVzdFtuYW1lXSA9PT0gdm9pZCAwKVxuICAgIGRlc3RbbmFtZV0gPSBbZWxlbV07XG4gIGVsc2VcbiAgICBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5mdW5jdGlvbiBwYXJzZSQyKGhlYWRlcikge1xuICBjb25zdCBvZmZlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gIGxldCBpc0VzY2FwaW5nID0gZmFsc2U7XG4gIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uTmFtZTtcbiAgbGV0IHBhcmFtTmFtZTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBjb2RlID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzJDFbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSlcbiAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGkgIT09IDAgJiYgKGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSlcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSA1OSB8fCBjb2RlID09PSA0NCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpXG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ0KSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnMkMVtjb2RlXSA9PT0gMSkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMzIgfHwgY29kZSA9PT0gOSkge1xuICAgICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpXG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gNTkgfHwgY29kZSA9PT0gNDQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDQpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDYxICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRXNjYXBpbmcpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnMkMVtjb2RlXSAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKVxuICAgICAgICAgIG11c3RVbmVzY2FwZSA9IHRydWU7XG4gICAgICAgIGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZXMpIHtcbiAgICAgICAgaWYgKHRva2VuQ2hhcnMkMVtjb2RlXSA9PT0gMSkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpXG4gICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMzQgJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgaW5RdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDkyKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMzQgJiYgaGVhZGVyLmNoYXJDb2RlQXQoaSAtIDEpID09PSA2MSkge1xuICAgICAgICBpblF1b3RlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFycyQxW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDkpKSB7XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDU5IHx8IGNvZGUgPT09IDQ0KSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICBsZXQgdmFsdWUgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFwvZywgXCJcIik7XG4gICAgICAgICAgbXVzdFVuZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChwYXJhbXMsIHBhcmFtTmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gNDQpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgZXh0ZW5zaW9uTmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGluUXVvdGVzIHx8IGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dFwiKTtcbiAgfVxuICBpZiAoZW5kID09PSAtMSlcbiAgICBlbmQgPSBpO1xuICBjb25zdCB0b2tlbiA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgaWYgKGV4dGVuc2lvbk5hbWUgPT09IHZvaWQgMCkge1xuICAgIHB1c2gob2ZmZXJzLCB0b2tlbiwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGFyYW1OYW1lID09PSB2b2lkIDApIHtcbiAgICAgIHB1c2gocGFyYW1zLCB0b2tlbiwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChtdXN0VW5lc2NhcGUpIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuLnJlcGxhY2UoL1xcXFwvZywgXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbik7XG4gICAgfVxuICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICB9XG4gIHJldHVybiBvZmZlcnM7XG59XG5mdW5jdGlvbiBmb3JtYXQkMShleHRlbnNpb25zKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhleHRlbnNpb25zKS5tYXAoKGV4dGVuc2lvbjIpID0+IHtcbiAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbjJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25maWd1cmF0aW9ucykpXG4gICAgICBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICByZXR1cm4gW2V4dGVuc2lvbjJdLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoKGspID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWVzID0gcGFyYW1zW2tdO1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKVxuICAgICAgICAgICAgdmFsdWVzID0gW3ZhbHVlc107XG4gICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoKHYpID0+IHYgPT09IHRydWUgPyBrIDogYCR7a309JHt2fWApLmpvaW4oXCI7IFwiKTtcbiAgICAgICAgfSlcbiAgICAgICkuam9pbihcIjsgXCIpO1xuICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgfSkuam9pbihcIiwgXCIpO1xufVxudmFyIGV4dGVuc2lvbiQxID0geyBmb3JtYXQ6IGZvcm1hdCQxLCBwYXJzZTogcGFyc2UkMiB9O1xuY29uc3QgRXZlbnRFbWl0dGVyJDEgPSByZXF1aXJlJCQwJDQ7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUkJDEkMjtcbmNvbnN0IGh0dHAkMSA9IHJlcXVpcmUkJDIkMTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUkJDM7XG5jb25zdCB0bHMgPSByZXF1aXJlJCQ0O1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaDogY3JlYXRlSGFzaCQxIH0gPSByZXF1aXJlJCQ1O1xuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUkJDc7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSQxID0gcGVybWVzc2FnZURlZmxhdGU7XG5jb25zdCBSZWNlaXZlcjIgPSByZWNlaXZlcjtcbmNvbnN0IFNlbmRlcjIgPSBzZW5kZXI7XG5jb25zdCB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgRU1QVFlfQlVGRkVSLFxuICBHVUlEOiBHVUlEJDEsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlLFxuICBrTGlzdGVuZXIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0OiBrV2ViU29ja2V0JDEsXG4gIE5PT1Bcbn0gPSBjb25zdGFudHM7XG5jb25zdCB7XG4gIEV2ZW50VGFyZ2V0OiB7IGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIgfVxufSA9IGV2ZW50VGFyZ2V0O1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlOiBwYXJzZSQxIH0gPSBleHRlbnNpb24kMTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IGJ1ZmZlclV0aWxFeHBvcnRzO1xuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxZTM7XG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbChcImtBYm9ydGVkXCIpO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCByZWFkeVN0YXRlcyA9IFtcIkNPTk5FQ1RJTkdcIiwgXCJPUEVOXCIsIFwiQ0xPU0lOR1wiLCBcIkNMT1NFRFwiXTtcbmNvbnN0IHN1YnByb3RvY29sUmVnZXggPSAvXlshIyQlJicqK1xcLS4wLTlBLVpeX2B8YS16fl0rJC87XG5sZXQgV2ViU29ja2V0JDEgPSBjbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIkMSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IEVNUFRZX0JVRkZFUjtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBcIlwiO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcbiAgICAgIGlmIChwcm90b2NvbHMgPT09IHZvaWQgMCkge1xuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvY29scyA9PT0gXCJvYmplY3RcIiAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbml0QXNDbGllbnQodGhpcywgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBkZXZpYXRlcyBmcm9tIHRoZSBXSEFUV0cgaW50ZXJmYWNlIHNpbmNlIHdzIGRvZXNuJ3Qgc3VwcG9ydCB0aGVcbiAgICogcmVxdWlyZWQgZGVmYXVsdCBcImJsb2JcIiB0eXBlIChpbnN0ZWFkIHdlIGRlZmluZSBhIGN1c3RvbSBcIm5vZGVidWZmZXJcIlxuICAgKiB0eXBlKS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBiaW5hcnlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9iaW5hcnlUeXBlO1xuICB9XG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgICBpZiAodGhpcy5fcmVjZWl2ZXIpXG4gICAgICB0aGlzLl9yZWNlaXZlci5fYmluYXJ5VHlwZSA9IHR5cGU7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpXG4gICAgICByZXR1cm4gdGhpcy5fYnVmZmVyZWRBbW91bnQ7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5sZW5ndGggKyB0aGlzLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXM7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25jbG9zZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uZXJyb3IoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXZlcjIgPSBuZXcgUmVjZWl2ZXIyKHtcbiAgICAgIGJpbmFyeVR5cGU6IHRoaXMuYmluYXJ5VHlwZSxcbiAgICAgIGV4dGVuc2lvbnM6IHRoaXMuX2V4dGVuc2lvbnMsXG4gICAgICBpc1NlcnZlcjogdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBtYXhQYXlsb2FkOiBvcHRpb25zLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcjIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zLCBvcHRpb25zLmdlbmVyYXRlTWFzayk7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSByZWNlaXZlcjI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuICAgIHJlY2VpdmVyMltrV2ViU29ja2V0JDFdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldCQxXSA9IHRoaXM7XG4gICAgcmVjZWl2ZXIyLm9uKFwiY29uY2x1ZGVcIiwgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlcjIub24oXCJkcmFpblwiLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyMi5vbihcImVycm9yXCIsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIyLm9uKFwibWVzc2FnZVwiLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIyLm9uKFwicGluZ1wiLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIyLm9uKFwicG9uZ1wiLCByZWNlaXZlck9uUG9uZyk7XG4gICAgc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgc29ja2V0LnNldE5vRGVsYXkoKTtcbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKVxuICAgICAgc29ja2V0LnVuc2hpZnQoaGVhZCk7XG4gICAgc29ja2V0Lm9uKFwiY2xvc2VcIiwgc29ja2V0T25DbG9zZSk7XG4gICAgc29ja2V0Lm9uKFwiZGF0YVwiLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbihcImVuZFwiLCBzb2NrZXRPbkVuZCk7XG4gICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgc29ja2V0T25FcnJvciQxKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0Lk9QRU47XG4gICAgdGhpcy5lbWl0KFwib3BlblwiKTtcbiAgfVxuICAvKipcbiAgICogRW1pdCB0aGUgYCdjbG9zZSdgIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW1pdENsb3NlKCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUkMS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZSQxLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICogICAgIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIGNvbnN0IG1zZyA9IFwiV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZFwiO1xuICAgICAgYWJvcnRIYW5kc2hha2UkMSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VGcmFtZVNlbnQgJiYgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHwgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95LmJpbmQodGhpcy5fc29ja2V0KSxcbiAgICAgIGNsb3NlVGltZW91dFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFBhdXNlIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBhdXNlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NvY2tldC5wYXVzZSgpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwaW5nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrMiwgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2syID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2syID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNiID0gbWFzazI7XG4gICAgICBtYXNrMiA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKVxuICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWFzazIgPT09IHZvaWQgMClcbiAgICAgIG1hc2syID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5waW5nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrMiwgY2IpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGEgcG9uZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrMiwgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2syID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2syID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNiID0gbWFzazI7XG4gICAgICBtYXNrMiA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKVxuICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWFzazIgPT09IHZvaWQgMClcbiAgICAgIG1hc2syID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrMiwgY2IpO1xuICB9XG4gIC8qKlxuICAgKiBSZXN1bWUgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVzdW1lKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbilcbiAgICAgIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuICAvKipcbiAgICogU2VuZCBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmFyeV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGlzIGJpbmFyeSBvclxuICAgKiAgICAgdGV4dFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbXByZXNzXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj10cnVlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2tdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gZGF0YSBpcyB3cml0dGVuIG91dFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKVxuICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIixcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlJDEuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuICAvKipcbiAgICogRm9yY2libHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSBcIldlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWRcIjtcbiAgICAgIGFib3J0SGFuZHNoYWtlJDEodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQkMSwgXCJDT05ORUNUSU5HXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoXCJDT05ORUNUSU5HXCIpXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQkMS5wcm90b3R5cGUsIFwiQ09OTkVDVElOR1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKFwiQ09OTkVDVElOR1wiKVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0JDEsIFwiT1BFTlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKFwiT1BFTlwiKVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0JDEucHJvdG90eXBlLCBcIk9QRU5cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZihcIk9QRU5cIilcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCQxLCBcIkNMT1NJTkdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZihcIkNMT1NJTkdcIilcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCQxLnByb3RvdHlwZSwgXCJDTE9TSU5HXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoXCJDTE9TSU5HXCIpXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQkMSwgXCJDTE9TRURcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZihcIkNMT1NFRFwiKVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0JDEucHJvdG90eXBlLCBcIkNMT1NFRFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKFwiQ0xPU0VEXCIpXG59KTtcbltcbiAgXCJiaW5hcnlUeXBlXCIsXG4gIFwiYnVmZmVyZWRBbW91bnRcIixcbiAgXCJleHRlbnNpb25zXCIsXG4gIFwiaXNQYXVzZWRcIixcbiAgXCJwcm90b2NvbFwiLFxuICBcInJlYWR5U3RhdGVcIixcbiAgXCJ1cmxcIlxuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0JDEucHJvdG90eXBlLCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufSk7XG5bXCJvcGVuXCIsIFwiZXJyb3JcIiwgXCJjbG9zZVwiLCBcIm1lc3NhZ2VcIl0uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQkMS5wcm90b3R5cGUsIGBvbiR7bWV0aG9kfWAsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKVxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQoaGFuZGxlcikge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgaGFuZGxlciwge1xuICAgICAgICBba0Zvck9uRXZlbnRBdHRyaWJ1dGVdOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG5XZWJTb2NrZXQkMS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQkMS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG52YXIgd2Vic29ja2V0ID0gV2ViU29ja2V0JDE7XG5mdW5jdGlvbiBpbml0QXNDbGllbnQod2Vic29ja2V0MiwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY3JlYXRlQ29ubmVjdGlvbjogdm9pZCAwLFxuICAgIHNvY2tldFBhdGg6IHZvaWQgMCxcbiAgICBob3N0bmFtZTogdm9pZCAwLFxuICAgIHByb3RvY29sOiB2b2lkIDAsXG4gICAgdGltZW91dDogdm9pZCAwLFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBob3N0OiB2b2lkIDAsXG4gICAgcGF0aDogdm9pZCAwLFxuICAgIHBvcnQ6IHZvaWQgMFxuICB9O1xuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oXCIsIFwiKX0pYFxuICAgICk7XG4gIH1cbiAgbGV0IHBhcnNlZFVybDtcbiAgaWYgKGFkZHJlc3MgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBwYXJzZWRVcmwgPSBhZGRyZXNzO1xuICAgIHdlYnNvY2tldDIuX3VybCA9IGFkZHJlc3MuaHJlZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIHdlYnNvY2tldDIuX3VybCA9IGFkZHJlc3M7XG4gIH1cbiAgY29uc3QgaXNTZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09IFwid3NzOlwiO1xuICBjb25zdCBpc0lwY1VybCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gXCJ3cyt1bml4OlwiO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09IFwid3M6XCIgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID0gYFRoZSBVUkwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgb3IgXCJ3cyt1bml4OlwiYDtcbiAgfSBlbHNlIGlmIChpc0lwY1VybCAmJiAhcGFyc2VkVXJsLnBhdGhuYW1lKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSBcIlRoZSBVUkwncyBwYXRobmFtZSBpcyBlbXB0eVwiO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgaW52YWxpZFVybE1lc3NhZ2UgPSBcIlRoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyXCI7XG4gIH1cbiAgaWYgKGludmFsaWRVcmxNZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IFN5bnRheEVycm9yKGludmFsaWRVcmxNZXNzYWdlKTtcbiAgICBpZiAod2Vic29ja2V0Mi5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldDIsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlZmF1bHRQb3J0ID0gaXNTZWN1cmUgPyA0NDMgOiA4MDtcbiAgY29uc3Qga2V5ID0gcmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICBjb25zdCByZXF1ZXN0ID0gaXNTZWN1cmUgPyBodHRwcy5yZXF1ZXN0IDogaHR0cCQxLnJlcXVlc3Q7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHBlck1lc3NhZ2VEZWZsYXRlO1xuICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gPSBpc1NlY3VyZSA/IHRsc0Nvbm5lY3QgOiBuZXRDb25uZWN0O1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKFwiW1wiKSA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSkgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIG9wdHMuaGVhZGVycyA9IHtcbiAgICAuLi5vcHRzLmhlYWRlcnMsXG4gICAgXCJTZWMtV2ViU29ja2V0LVZlcnNpb25cIjogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgXCJTZWMtV2ViU29ja2V0LUtleVwiOiBrZXksXG4gICAgQ29ubmVjdGlvbjogXCJVcGdyYWRlXCIsXG4gICAgVXBncmFkZTogXCJ3ZWJzb2NrZXRcIlxuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUkMShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzW1wiU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zXCJdID0gZm9ybWF0KHtcbiAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZSQxLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb3RvY29scy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIHByb3RvY29scykge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbCAhPT0gXCJzdHJpbmdcIiB8fCAhc3VicHJvdG9jb2xSZWdleC50ZXN0KHByb3RvY29sKSB8fCBwcm90b2NvbFNldC5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBcIkFuIGludmFsaWQgb3IgZHVwbGljYXRlZCBzdWJwcm90b2NvbCB3YXMgc3BlY2lmaWVkXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuICAgIG9wdHMuaGVhZGVyc1tcIlNlYy1XZWJTb2NrZXQtUHJvdG9jb2xcIl0gPSBwcm90b2NvbHMuam9pbihcIixcIik7XG4gIH1cbiAgaWYgKG9wdHMub3JpZ2luKSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2xWZXJzaW9uIDwgMTMpIHtcbiAgICAgIG9wdHMuaGVhZGVyc1tcIlNlYy1XZWJTb2NrZXQtT3JpZ2luXCJdID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cbiAgaWYgKGlzSXBjVXJsKSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoXCI6XCIpO1xuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG4gIGxldCByZXE7XG4gIGlmIChvcHRzLmZvbGxvd1JlZGlyZWN0cykge1xuICAgIGlmICh3ZWJzb2NrZXQyLl9yZWRpcmVjdHMgPT09IDApIHtcbiAgICAgIHdlYnNvY2tldDIuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XG4gICAgICB3ZWJzb2NrZXQyLl9vcmlnaW5hbFNlY3VyZSA9IGlzU2VjdXJlO1xuICAgICAgd2Vic29ja2V0Mi5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoID0gaXNJcGNVcmwgPyBvcHRzLnNvY2tldFBhdGggOiBwYXJzZWRVcmwuaG9zdDtcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG4gICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXkyLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICBvcHRpb25zLmhlYWRlcnNba2V5Mi50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQyLmxpc3RlbmVyQ291bnQoXCJyZWRpcmVjdFwiKSA9PT0gMCkge1xuICAgICAgY29uc3QgaXNTYW1lSG9zdCA9IGlzSXBjVXJsID8gd2Vic29ja2V0Mi5fb3JpZ2luYWxJcGMgPyBvcHRzLnNvY2tldFBhdGggPT09IHdlYnNvY2tldDIuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCA6IGZhbHNlIDogd2Vic29ja2V0Mi5fb3JpZ2luYWxJcGMgPyBmYWxzZSA6IHBhcnNlZFVybC5ob3N0ID09PSB3ZWJzb2NrZXQyLl9vcmlnaW5hbEhvc3RPclNvY2tldFBhdGg7XG4gICAgICBpZiAoIWlzU2FtZUhvc3QgfHwgd2Vic29ja2V0Mi5fb3JpZ2luYWxTZWN1cmUgJiYgIWlzU2VjdXJlKSB7XG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVycy5jb29raWU7XG4gICAgICAgIGlmICghaXNTYW1lSG9zdClcbiAgICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmhvc3Q7XG4gICAgICAgIG9wdHMuYXV0aCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID0gXCJCYXNpYyBcIiArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIHJlcSA9IHdlYnNvY2tldDIuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG4gICAgaWYgKHdlYnNvY2tldDIuX3JlZGlyZWN0cykge1xuICAgICAgd2Vic29ja2V0Mi5lbWl0KFwicmVkaXJlY3RcIiwgd2Vic29ja2V0Mi51cmwsIHJlcSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcSA9IHdlYnNvY2tldDIuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG4gIH1cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbihcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgYWJvcnRIYW5kc2hha2UkMSh3ZWJzb2NrZXQyLCByZXEsIFwiT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dFwiKTtcbiAgICB9KTtcbiAgfVxuICByZXEub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcSA9PT0gbnVsbCB8fCByZXFba0Fib3J0ZWRdKVxuICAgICAgcmV0dXJuO1xuICAgIHJlcSA9IHdlYnNvY2tldDIuX3JlcSA9IG51bGw7XG4gICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0MiwgZXJyKTtcbiAgfSk7XG4gIHJlcS5vbihcInJlc3BvbnNlXCIsIChyZXMpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcbiAgICBpZiAobG9jYXRpb24gJiYgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiYgc3RhdHVzQ29kZSA+PSAzMDAgJiYgc3RhdHVzQ29kZSA8IDQwMCkge1xuICAgICAgaWYgKCsrd2Vic29ja2V0Mi5fcmVkaXJlY3RzID4gb3B0cy5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgYWJvcnRIYW5kc2hha2UkMSh3ZWJzb2NrZXQyLCByZXEsIFwiTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgbGV0IGFkZHI7XG4gICAgICB0cnkge1xuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XG4gICAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldDIsIGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQyLCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldDIuZW1pdChcInVuZXhwZWN0ZWQtcmVzcG9uc2VcIiwgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSQxKFxuICAgICAgICB3ZWJzb2NrZXQyLFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJlcS5vbihcInVwZ3JhZGVcIiwgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0Mi5lbWl0KFwidXBncmFkZVwiLCByZXMpO1xuICAgIGlmICh3ZWJzb2NrZXQyLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldCQxLkNPTk5FQ1RJTkcpXG4gICAgICByZXR1cm47XG4gICAgcmVxID0gd2Vic29ja2V0Mi5fcmVxID0gbnVsbDtcbiAgICBpZiAocmVzLmhlYWRlcnMudXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSQxKHdlYnNvY2tldDIsIHNvY2tldCwgXCJJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoJDEoXCJzaGExXCIpLnVwZGF0ZShrZXkgKyBHVUlEJDEpLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgICBpZiAocmVzLmhlYWRlcnNbXCJzZWMtd2Vic29ja2V0LWFjY2VwdFwiXSAhPT0gZGlnZXN0KSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSQxKHdlYnNvY2tldDIsIHNvY2tldCwgXCJJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlclwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVyUHJvdCA9IHJlcy5oZWFkZXJzW1wic2VjLXdlYnNvY2tldC1wcm90b2NvbFwiXTtcbiAgICBsZXQgcHJvdEVycm9yO1xuICAgIGlmIChzZXJ2ZXJQcm90ICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICghcHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgICBwcm90RXJyb3IgPSBcIlNlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZFwiO1xuICAgICAgfSBlbHNlIGlmICghcHJvdG9jb2xTZXQuaGFzKHNlcnZlclByb3QpKSB7XG4gICAgICAgIHByb3RFcnJvciA9IFwiU2VydmVyIHNlbnQgYW4gaW52YWxpZCBzdWJwcm90b2NvbFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gXCJTZXJ2ZXIgc2VudCBubyBzdWJwcm90b2NvbFwiO1xuICAgIH1cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSQxKHdlYnNvY2tldDIsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlcnZlclByb3QpXG4gICAgICB3ZWJzb2NrZXQyLl9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcy5oZWFkZXJzW1wic2VjLXdlYnNvY2tldC1leHRlbnNpb25zXCJdO1xuICAgIGlmIChzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICghcGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gd2FzIHJlcXVlc3RlZFwiO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSQxKHdlYnNvY2tldDIsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBleHRlbnNpb25zO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHBhcnNlJDEoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyXCI7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlJDEod2Vic29ja2V0Miwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZXMgPSBPYmplY3Qua2V5cyhleHRlbnNpb25zKTtcbiAgICAgIGlmIChleHRlbnNpb25OYW1lcy5sZW5ndGggIT09IDEgfHwgZXh0ZW5zaW9uTmFtZXNbMF0gIT09IFBlck1lc3NhZ2VEZWZsYXRlJDEuZXh0ZW5zaW9uTmFtZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJTZXJ2ZXIgaW5kaWNhdGVkIGFuIGV4dGVuc2lvbiB0aGF0IHdhcyBub3QgcmVxdWVzdGVkXCI7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlJDEod2Vic29ja2V0Miwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuYWNjZXB0KGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUkMS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiSW52YWxpZCBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyXCI7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlJDEod2Vic29ja2V0Miwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2Vic29ja2V0Mi5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZSQxLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuICAgIHdlYnNvY2tldDIuc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgZ2VuZXJhdGVNYXNrOiBvcHRzLmdlbmVyYXRlTWFzayxcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG4gIGlmIChvcHRzLmZpbmlzaFJlcXVlc3QpIHtcbiAgICBvcHRzLmZpbmlzaFJlcXVlc3QocmVxLCB3ZWJzb2NrZXQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXEuZW5kKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldDIsIGVycikge1xuICB3ZWJzb2NrZXQyLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0JDEuQ0xPU0lORztcbiAgd2Vic29ja2V0Mi5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgd2Vic29ja2V0Mi5lbWl0Q2xvc2UoKTtcbn1cbmZ1bmN0aW9uIG5ldENvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB2b2lkIDA7XG4gIGlmICghb3B0aW9ucy5zZXJ2ZXJuYW1lICYmIG9wdGlvbnMuc2VydmVybmFtZSAhPT0gXCJcIikge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyBcIlwiIDogb3B0aW9ucy5ob3N0O1xuICB9XG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlJDEod2Vic29ja2V0Miwgc3RyZWFtMiwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQyLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0JDEuQ0xPU0lORztcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlJDEpO1xuICBpZiAoc3RyZWFtMi5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW0yW2tBYm9ydGVkXSA9IHRydWU7XG4gICAgc3RyZWFtMi5hYm9ydCgpO1xuICAgIGlmIChzdHJlYW0yLnNvY2tldCAmJiAhc3RyZWFtMi5zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICBzdHJlYW0yLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2UsIHdlYnNvY2tldDIsIGVycik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtMi5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtMi5vbmNlKFwiZXJyb3JcIiwgd2Vic29ja2V0Mi5lbWl0LmJpbmQod2Vic29ja2V0MiwgXCJlcnJvclwiKSk7XG4gICAgc3RyZWFtMi5vbmNlKFwiY2xvc2VcIiwgd2Vic29ja2V0Mi5lbWl0Q2xvc2UuYmluZCh3ZWJzb2NrZXQyKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldDIsIGRhdGEsIGNiKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xuICAgIGlmICh3ZWJzb2NrZXQyLl9zb2NrZXQpXG4gICAgICB3ZWJzb2NrZXQyLl9zZW5kZXIuX2J1ZmZlcmVkQnl0ZXMgKz0gbGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHdlYnNvY2tldDIuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICBgV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlICR7d2Vic29ja2V0Mi5yZWFkeVN0YXRlfSAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQyLnJlYWR5U3RhdGVdfSlgXG4gICAgKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpO1xuICB9XG59XG5mdW5jdGlvbiByZWNlaXZlck9uQ29uY2x1ZGUoY29kZSwgcmVhc29uKSB7XG4gIGNvbnN0IHdlYnNvY2tldDIgPSB0aGlzW2tXZWJTb2NrZXQkMV07XG4gIHdlYnNvY2tldDIuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldDIuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Mi5fY2xvc2VDb2RlID0gY29kZTtcbiAgaWYgKHdlYnNvY2tldDIuX3NvY2tldFtrV2ViU29ja2V0JDFdID09PSB2b2lkIDApXG4gICAgcmV0dXJuO1xuICB3ZWJzb2NrZXQyLl9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQyLl9zb2NrZXQpO1xuICBpZiAoY29kZSA9PT0gMTAwNSlcbiAgICB3ZWJzb2NrZXQyLmNsb3NlKCk7XG4gIGVsc2VcbiAgICB3ZWJzb2NrZXQyLmNsb3NlKGNvZGUsIHJlYXNvbik7XG59XG5mdW5jdGlvbiByZWNlaXZlck9uRHJhaW4oKSB7XG4gIGNvbnN0IHdlYnNvY2tldDIgPSB0aGlzW2tXZWJTb2NrZXQkMV07XG4gIGlmICghd2Vic29ja2V0Mi5pc1BhdXNlZClcbiAgICB3ZWJzb2NrZXQyLl9zb2NrZXQucmVzdW1lKCk7XG59XG5mdW5jdGlvbiByZWNlaXZlck9uRXJyb3IoZXJyKSB7XG4gIGNvbnN0IHdlYnNvY2tldDIgPSB0aGlzW2tXZWJTb2NrZXQkMV07XG4gIGlmICh3ZWJzb2NrZXQyLl9zb2NrZXRba1dlYlNvY2tldCQxXSAhPT0gdm9pZCAwKSB7XG4gICAgd2Vic29ja2V0Mi5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBzb2NrZXRPbkRhdGEpO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQyLl9zb2NrZXQpO1xuICAgIHdlYnNvY2tldDIuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cbiAgd2Vic29ja2V0Mi5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldCQxXS5lbWl0Q2xvc2UoKTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gIHRoaXNba1dlYlNvY2tldCQxXS5lbWl0KFwibWVzc2FnZVwiLCBkYXRhLCBpc0JpbmFyeSk7XG59XG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldDIgPSB0aGlzW2tXZWJTb2NrZXQkMV07XG4gIHdlYnNvY2tldDIucG9uZyhkYXRhLCAhd2Vic29ja2V0Mi5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQyLmVtaXQoXCJwaW5nXCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXQkMV0uZW1pdChcInBvbmdcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtMikge1xuICBzdHJlYW0yLnJlc3VtZSgpO1xufVxuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0MiA9IHRoaXNba1dlYlNvY2tldCQxXTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBzb2NrZXRPbkRhdGEpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIHNvY2tldE9uRW5kKTtcbiAgd2Vic29ja2V0Mi5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldCQxLkNMT1NJTkc7XG4gIGxldCBjaHVuaztcbiAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgJiYgIXdlYnNvY2tldDIuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiAhd2Vic29ja2V0Mi5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmIChjaHVuayA9IHdlYnNvY2tldDIuX3NvY2tldC5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgd2Vic29ja2V0Mi5fcmVjZWl2ZXIud3JpdGUoY2h1bmspO1xuICB9XG4gIHdlYnNvY2tldDIuX3JlY2VpdmVyLmVuZCgpO1xuICB0aGlzW2tXZWJTb2NrZXQkMV0gPSB2b2lkIDA7XG4gIGNsZWFyVGltZW91dCh3ZWJzb2NrZXQyLl9jbG9zZVRpbWVyKTtcbiAgaWYgKHdlYnNvY2tldDIuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkIHx8IHdlYnNvY2tldDIuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgIHdlYnNvY2tldDIuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Mi5fcmVjZWl2ZXIub24oXCJlcnJvclwiLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQyLl9yZWNlaXZlci5vbihcImZpbmlzaFwiLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuZnVuY3Rpb24gc29ja2V0T25EYXRhKGNodW5rKSB7XG4gIGlmICghdGhpc1trV2ViU29ja2V0JDFdLl9yZWNlaXZlci53cml0ZShjaHVuaykpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNvY2tldE9uRW5kKCkge1xuICBjb25zdCB3ZWJzb2NrZXQyID0gdGhpc1trV2ViU29ja2V0JDFdO1xuICB3ZWJzb2NrZXQyLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0JDEuQ0xPU0lORztcbiAgd2Vic29ja2V0Mi5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yJDEoKSB7XG4gIGNvbnN0IHdlYnNvY2tldDIgPSB0aGlzW2tXZWJTb2NrZXQkMV07XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBzb2NrZXRPbkVycm9yJDEpO1xuICB0aGlzLm9uKFwiZXJyb3JcIiwgTk9PUCk7XG4gIGlmICh3ZWJzb2NrZXQyKSB7XG4gICAgd2Vic29ja2V0Mi5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldCQxLkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbmNvbnN0IFdlYlNvY2tldCQyID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHdlYnNvY2tldCk7XG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHZhbGlkYXRpb25FeHBvcnRzO1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IHByb3RvY29scyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcbiAgZm9yIChpOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpXG4gICAgICAgIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2UgaWYgKGkgIT09IDAgJiYgKGNvZGUgPT09IDMyIHx8IGNvZGUgPT09IDkpKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpXG4gICAgICAgIGVuZCA9IGk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0NCkge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICBlbmQgPSBpO1xuICAgICAgY29uc3QgcHJvdG9jb2wyID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wyKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2wyfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcbiAgICAgIH1cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wyKTtcbiAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCAhPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dFwiKTtcbiAgfVxuICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cbiAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gIHJldHVybiBwcm90b2NvbHM7XG59XG52YXIgc3VicHJvdG9jb2wkMSA9IHsgcGFyc2UgfTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUkJDAkNDtcbmNvbnN0IGh0dHAgPSByZXF1aXJlJCQyJDE7XG5jb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUkJDU7XG5jb25zdCBleHRlbnNpb24gPSBleHRlbnNpb24kMTtcbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlMiA9IHBlcm1lc3NhZ2VEZWZsYXRlO1xuY29uc3Qgc3VicHJvdG9jb2wgPSBzdWJwcm90b2NvbCQxO1xuY29uc3QgV2ViU29ja2V0MiA9IHdlYnNvY2tldDtcbmNvbnN0IHsgR1VJRCwga1dlYlNvY2tldCB9ID0gY29uc3RhbnRzO1xuY29uc3Qga2V5UmVnZXggPSAvXlsrLzAtOUEtWmEtel17MjJ9PT0kLztcbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuY2xhc3MgV2ViU29ja2V0U2VydmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBXZWJTb2NrZXRTZXJ2ZXJgIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhY2tsb2c9NTExXSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHF1ZXVlIG9mXG4gICAqICAgICBwZW5kaW5nIGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50VHJhY2tpbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICB0cmFjayBjbGllbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuICAgKiAgICAgY2xhc3MgdG8gdXNlLiBJdCBtdXN0IGJlIHRoZSBgV2ViU29ja2V0YCBjbGFzcyBvciBjbGFzcyB0aGF0IGV4dGVuZHMgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLFxuICAgICAgLy8gdXNlIGRlZmF1bHQgKDUxMSBhcyBpbXBsZW1lbnRlZCBpbiBuZXQuanMpXG4gICAgICBzZXJ2ZXI6IG51bGwsXG4gICAgICBob3N0OiBudWxsLFxuICAgICAgcGF0aDogbnVsbCxcbiAgICAgIHBvcnQ6IG51bGwsXG4gICAgICBXZWJTb2NrZXQ6IFdlYlNvY2tldDIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyIHx8IG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSB8fCBvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnT25lIGFuZCBvbmx5IG9uZSBvZiB0aGUgXCJwb3J0XCIsIFwic2VydmVyXCIsIG9yIFwibm9TZXJ2ZXJcIiBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucG9ydCAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXJ2ZXIgPSBodHRwLmNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IGh0dHAuU1RBVFVTX0NPREVTWzQyNl07XG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgXCJDb250ZW50LUxlbmd0aFwiOiBib2R5Lmxlbmd0aCxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgXCJjb25uZWN0aW9uXCIpO1xuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsIFwibGlzdGVuaW5nXCIpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgXCJlcnJvclwiKSxcbiAgICAgICAgdXBncmFkZTogKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBlbWl0Q29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSlcbiAgICAgIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N0YXRlID0gUlVOTklORztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NlcnZlcilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKFwiVGhlIHNlcnZlciBpcyBub3QgcnVubmluZ1wiKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2IpXG4gICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBjYik7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TSU5HKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzZXJ2ZXIgPSB0aGlzLl9zZXJ2ZXI7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICBzZXJ2ZXIuY2xvc2UoKCkgPT4ge1xuICAgICAgICBlbWl0Q2xvc2UodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKFwiP1wiKTtcbiAgICAgIGNvbnN0IHBhdGhuYW1lID0gaW5kZXggIT09IC0xID8gcmVxLnVybC5zbGljZSgwLCBpbmRleCkgOiByZXEudXJsO1xuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGEgSFRUUCBVcGdyYWRlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAgICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZVxuICAgKiAgICAgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGNiKSB7XG4gICAgc29ja2V0Lm9uKFwiZXJyb3JcIiwgc29ja2V0T25FcnJvcik7XG4gICAgY29uc3Qga2V5ID0gcmVxLmhlYWRlcnNbXCJzZWMtd2Vic29ja2V0LWtleVwiXTtcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzW1wic2VjLXdlYnNvY2tldC12ZXJzaW9uXCJdO1xuICAgIGlmIChyZXEubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIEhUVFAgbWV0aG9kXCI7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwNSwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXEuaGVhZGVycy51cGdyYWRlLnRvTG93ZXJDYXNlKCkgIT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcIkludmFsaWQgVXBncmFkZSBoZWFkZXJcIjtcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFrZXkgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFwiTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlclwiO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiAhPT0gOCAmJiB2ZXJzaW9uICE9PSAxMykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFwiTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXJcIjtcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbXCJzZWMtd2Vic29ja2V0LXByb3RvY29sXCJdO1xuICAgIGxldCBwcm90b2NvbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGlmIChzZWNXZWJTb2NrZXRQcm90b2NvbCAhPT0gdm9pZCAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcm90b2NvbHMgPSBzdWJwcm90b2NvbC5wYXJzZShzZWNXZWJTb2NrZXRQcm90b2NvbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlclwiO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyA9IHJlcS5oZWFkZXJzW1wic2VjLXdlYnNvY2tldC1leHRlbnNpb25zXCJdO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmIHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUyKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuICAgICAgICBpZiAob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlMi5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUyLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlMi5leHRlbnNpb25OYW1lXSA9IHBlck1lc3NhZ2VEZWZsYXRlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IFwiSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlclwiO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjogcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/IFwic2VjLXdlYnNvY2tldC1vcmlnaW5cIiA6IFwib3JpZ2luXCJ9YF0sXG4gICAgICAgIHNlY3VyZTogISEocmVxLnNvY2tldC5hdXRob3JpemVkIHx8IHJlcS5zb2NrZXQuZW5jcnlwdGVkKSxcbiAgICAgICAgcmVxXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8pKVxuICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDEpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKVxuICAgICAgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG4gICAgaWYgKHNvY2tldFtrV2ViU29ja2V0XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcInNlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldCwgcG9zc2libHkgZHVlIHRvIGEgbWlzY29uZmlndXJhdGlvblwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKVxuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNTAzKTtcbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKFwic2hhMVwiKS51cGRhdGUoa2V5ICsgR1VJRCkuZGlnZXN0KFwiYmFzZTY0XCIpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICBcIkhUVFAvMS4xIDEwMSBTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gICAgICBcIlVwZ3JhZGU6IHdlYnNvY2tldFwiLFxuICAgICAgXCJDb25uZWN0aW9uOiBVcGdyYWRlXCIsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuICAgIGNvbnN0IHdzID0gbmV3IHRoaXMub3B0aW9ucy5XZWJTb2NrZXQobnVsbCk7XG4gICAgaWYgKHByb3RvY29scy5zaXplKSB7XG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKSA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUyLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlMi5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUyLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdChcIlxcclxcblwiKS5qb2luKFwiXFxyXFxuXCIpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBzb2NrZXRPbkVycm9yKTtcbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgIHRoaXMuY2xpZW50cy5hZGQod3MpO1xuICAgICAgd3Mub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkRW1pdENsb3NlICYmICF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG52YXIgd2Vic29ja2V0U2VydmVyID0gV2ViU29ja2V0U2VydmVyO1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSlcbiAgICBzZXJ2ZXIub24oZXZlbnQsIG1hcFtldmVudF0pO1xuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KFwiY2xvc2VcIik7XG59XG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgaGVhZGVycyA9IHtcbiAgICBDb25uZWN0aW9uOiBcImNsb3NlXCIsXG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2h0bWxcIixcbiAgICBcIkNvbnRlbnQtTGVuZ3RoXCI6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgIC4uLmhlYWRlcnNcbiAgfTtcbiAgc29ja2V0Lm9uY2UoXCJmaW5pc2hcIiwgc29ja2V0LmRlc3Ryb3kpO1xuICBzb2NrZXQuZW5kKFxuICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7aHR0cC5TVEFUVVNfQ09ERVNbY29kZV19XFxyXG5gICsgT2JqZWN0LmtleXMoaGVhZGVycykubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApLmpvaW4oXCJcXHJcXG5cIikgKyBcIlxcclxcblxcclxcblwiICsgbWVzc2FnZVxuICApO1xufVxuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHNlcnZlciwgcmVxLCBzb2NrZXQsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KFwid3NDbGllbnRFcnJvclwiKSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcik7XG4gICAgc2VydmVyLmVtaXQoXCJ3c0NsaWVudEVycm9yXCIsIGVyciwgc29ja2V0LCByZXEpO1xuICB9IGVsc2Uge1xuICAgIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSk7XG4gIH1cbn1cbmNvbnN0IHdlYnNvY2tldFNlcnZlciQxID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHdlYnNvY2tldFNlcnZlcik7XG5leHBvcnQge1xuICByZWNlaXZlciQxIGFzIFJlY2VpdmVyLFxuICBzZW5kZXIkMSBhcyBTZW5kZXIsXG4gIFdlYlNvY2tldCQyIGFzIFdlYlNvY2tldCxcbiAgd2Vic29ja2V0U2VydmVyJDEgYXMgV2ViU29ja2V0U2VydmVyLFxuICBzdHJlYW0kMSBhcyBjcmVhdGVXZWJTb2NrZXRTdHJlYW0sXG4gIFdlYlNvY2tldCQyIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@gradio/client/dist/wrapper-CviSselG.js\n");

/***/ })

};
;